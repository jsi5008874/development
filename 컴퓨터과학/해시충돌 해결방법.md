  

### separate chaining : 추가적인 공간을 활용하여 해결하는 방식

*Linked List 사용

  

separate chaining은 배열에 value값을 넣는것이 아니고 Linked List의 포인터를 넣는다.

따라서 인덱스가 겹치는 충돌이 일어나도 포인터를 따라 헤드에 새로운 노드를 추가한다.

충돌이 생긴 해당 value값을 새로운 노드에 넣고 새로 생성한 노드가 기존 자리를 차지하고 있던 노드를 가리킨다.

이렇게 추가적인 공간(노드)를 활용하여 해시충돌을 해결한다.

  

### open addressing : 충돌 발생 시 인접한 비어있는 공간(bucket)에 저장(이미 있는 공간으로 해결)

- Linear probing : 고정폭으로 이동하여 빈공간을 찾음

*hf_lp(key, i) = hf(key) + i when i(충돌횟수) = 0, 1, 2 ……..

Linear Probing 방식은 충돌이 생기면 구한 해쉬 값에 +1을 하고 모듈러연산을 해준다.

만약 +1을 했는데도 배열이 차있다면 비어있는 배열이 나올 때 까지 +1씩해서 빈곳을 찾아간다.

  

- Quadratic probing : 제곱수로 이동하여 빈 공간을 찾음

*hf_qp(key, i) = hf(key) + i^2 when i(충돌횟수) = 0, 1, 2 …..

Quadratic Probing방식은 i^2말고 다른 식을 사용할 수 있다.

충돌이 발생하면 구한 해쉬값에 i^2값을 더한 후 모듈러 연산을 해준다.

그래도 충돌이 발생하면 i에 +1을 해서 값을 구한 후 빈곳을 찾을 때 까지 수행한다.

  

- Double hashing : 또 다른 hash fuction을 사용하여 빈 공간을 찾음

_hf_dh(key, i) = hf(key) + i_*2nd_hf(key) when i(충돌횟수) i = 0, 1, 2…..

전혀 다른 Hash Function을 새로 추가해서 충돌을 해결하는 개념이다.

주의점 : 2nd_hf(key)의 값이 map 사이즈와 서로소여야 한다. 그렇지 않으면 배열 내 모든 index 를 방문하지 못하는 경우가 생김

예를 들어 맵 사이즈가 10이고 hf(key) : 10, 2nd_hf(key) : 4 라고 했을 때

hf_dh(key, i) = 0 + i*4가 된다. 여기서 아무리 충돌횟수가 늘어난다해도

4i = 4 8 12 16 20 24 28 32 …. 이렇게 진행될 것인데 모듈러 연산을하면

4 8 2 6 0 4 8 2 6 0 만 계속 방문하는 경우가 생기므로 서로소여야한다는 것이다.

  

### **open addressing 주의점**

1. 중간 연결고리 역할을 하는 key 삭제 시, 이미 있는 값도 없다고 판단할 수 있음

  

예를 들면 1번 인덱스에는 10이 들어가있고 2번 인덱스에는 15가 들어가 있다.

원래 15도 1번 인덱스에 들어가야하지만 open adressing기능으로 2번 인덱스에 들어가 있다.

이 때 만약 1번 인덱스의 10을 삭제하고 15를 다시 넣는다면 15는 원래 hf의 값에 따라 1번 인덱스의 자리에 들어가게된다.

그렇다면 15가 두번 들어가는 버그가 발생한다.(배열은 중복값이 못 들어가기 때문에 버그)

  

이를 해결하기 위해 삭제 시 DELETE 같은 상징적인 형태로 표시를 한다.

이 말은 만약 1번 인덱스의 10을 삭제한다면 1번 인덱스에 DELETE라는 표시를 해놓는다.

그렇게 되면 15를 새로 집어넣을 때 DELETE가 1번 인덱스에 있으므로 인접 인덱스를 한번 탐색해보고 동일 숫자가 있으면 1번 인덱스에 들어가지 않고 동일 숫자가 없다면 1번 인덱스로 들어가게 된다.

DELETE 같은 상징적인 방법의 단점은 DELETE를 만나면 무조건 다음 위치를 확인해야한다는 것이다.

  

1. 삭제 위치 다음의 open addressing된 key들은 한 단계씩 앞으로 옮겨준다.

이동시키는데 추가적인 비용이 발생하고 구현에 어려움이 있다.

  

### JAVA에서 해시 충돌 해결방법

jdk7까지는 Linked List를 이용한 separate chaining을 활용

  

jdk8에서 Linked List와 red black tree를 혼용한 separate chaing을 활용

>> 해시충돌이 일어났을 때 Linked List를 사용하다가 동일한 인덱스에 충돌횟수가 일정 임계치를 넘어가면 tree구조로 저장하는 방식

Linked List는 탐색시간이 O(n)이지만 red black tree는 O(log n)으로 더 효율적이다.