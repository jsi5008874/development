이진수에서 맨 앞(왼쪽)부터 시작해서 첫 번째 1이 나올 때까지의 0의 개수

ex)
```
예시 1:
이진수: 0001101011...
       ^^^
Leading Zero = 3개 (첫 번째 1 앞의 0들)

예시 2:  
이진수: 0000000101...
      ^^^^^^^
Leading Zero = 7개

예시 3:
이진수: 1001101011...
        (첫 번째가 1)
Leading Zero = 0개
```

### Hyperloglog에서의 Leading Zero
핵심 아이디어 : Leading zero가 많을수록 희귀한 패턴이다.

```
확률 계산:
- Leading Zero가 1개인 확률: 1/2 = 50%
- Leading Zero가 2개인 확률: 1/4 = 25%  
- Leading Zero가 3개인 확률: 1/8 = 12.5%
- Leading Zero가 k개인 확률: 1/(2^k)
```

**데이터 개수 추정 원리**
데이터가 많을수록 더 큰 leading zero를 가진 해시값이 나올 확률 증가
관찰된 최대 leading zero를 통해 데이터 개수를 추정

ex)
최대 leading zero가 3개 >> 2^3 = 8개 정도의 데이터
최대 leading zero가 10개 >> 2^10 = 1024개 정도의 데이터

### 버킷(Bucket)
Hyperloglog의 정확도를 높이기 위해 데이터를 여러 그룹으로 나누어 처리하는 방식
버킷 = 데이터를 분류하는 바구니

Hyperloglog에서는 16,384개의 버킷으로 구성
각 버킷은 독립적으로 통계를 수집

**버킷을 사용하는 이유**
```
버킷 없이 (단일 카운터):
- 운이 나쁘면 매우 부정확한 결과
- 예: 첫 번째 데이터가 우연히 매우 큰 leading zero를 가지면 추정값 왜곡

버킷 사용 (16,384개 카운터):
- 여러 그룹의 평균을 내므로 안정적
- 일부 버킷의 이상값이 전체에 미치는 영향 최소화
```
확률의 왜곡성을 최소화 하기 위해 여러 개의 그룹으로 나누고 평균을 내서 정확도를 높이기 위해 버킷을 사용

**버킷 분할 방식**
해시값을 이용해 버킷을 배정받는다.

```
"aaa"라는 데이터를 hyperloglog에서 변환한다면

1. 데이터를 해시값으로 변환
2. 앞의 14비트 > 버킷번호로 변환
   
ex)
"aaa"를 변환한 해쉬 값 = 0b10110011010101 → 11,605번 버킷

"aaa"는 11,605번 버킷에서 사용된다.
```
변환된 해시 값의 앞쪽 14비트를 버킷번호로 사용한다.


### Hyperloglog의 데이터 변환 과정
1. 데이터를 해시값으로 변환
2. 앞의 14개 비트는 버킷 번호, 나머지 50개는 leading zero로 계산용으로 활용
3. 해당 버킷의 leading zero 최대값과 현재 데이터에서 변환한 leading zero의 값을 비교
4. 현재 데이터의 leading zero가 더 크다면 해당 버킷의 leading zero 최대값을 수정해준다.

```
"aaa"라는 데이터를 Hyperloglog에서 변환
1. 데이터를 해시값으로 변환
"aaa" >> 0b101100110101010011001...

2. 버킷 번호 추출
"aaa"를 변환한 해쉬 값 = 0b10110011010101 → 11,605번 버킷

3. leading zero 계산
010011001.. >> leading zero = 1

11,605 버킷의 최대값 = 2

4. 버킷의 최대값과 계산한 현재 데이터의 leading zero 값을 비교
11,605 버킷의 leading zero 최대값 = 2
현재 데이터 leading zero = 1

버킷의 값이 더 크므로 변화 없음
```

이런식으로 데이터가 추가될 때 마다 각 버킷의 leading zero 최대값과 현 데이터의 leading zero 값을 비교해서 update 하는 방식

카디널리티를 구할 때는 조화평균 방식으로 구한다.
카디널리티 = α × m² × (1 / Σ(1/2^버킷값))

각 버킷의 2^ 값을 더하는 것이 아닌 조화 평균 방식이 극단 값에 덜 민감하고 확률적 모델에 더 적합하기 때문이다.
(자세한 수학적 이유는 모르겠다...)


### 결론
결국 leading zero 기법은 실제 데이터를 저장하고 그 갯수를 세는것이 아니다.
확률적인 방법에 의해 숫자를 추정하는 방식이지만 그 오차가 매우 적어서 정확한 데이터를 얻을 수 있다.
이러한 방식을 사용하기 때문에 획기적으로 데이터를 아낄 수 있고 속도의 이점도 생긴다.