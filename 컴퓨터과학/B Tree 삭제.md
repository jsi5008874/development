  

![[image 343.png]]

  

  

![[image 344.png]]

여기서 5를 삭제한다면

  

![[image 345.png]]

해당 조건을 통해 키를 재조정한다.

  

![[image 346.png]]

형제의 지원을 받아 2를 5의 자리로 놓는다 해도 B Tree의 규칙에 위반되므로

부모인 3을 내리고 형제인 2가 부모 노드로 가서 규칙에 맞게 재조정

  

![[image 347.png]]

3을 삭제할 때도 우선 형제 노드 중 여유가 있는 오른쪽 8, 9가 있는 노드에서 빌려오는데

그러면 규칙에 위반되서 부모에 있는 7을 내려보내고 8을 부모 노드로 재배치해서

규칙에 맞도록 한다.

  

![[image 348.png]]

현 상황에서 7을 삭제한다면 7을 기준으로 형제들 모두 key가 1개씩 가지고 있어서 빌려올 수 없다.

이럴 때 2번의 규칙인 형제의 지원이 불가하면 부모의 지원을 받아 형제와 합친다는 규칙을 적용

결과적으로 부모에 있는 2를 왼쪽 노드에 합쳐서 규칙을 준수한다.

  

![[image 349.png]]

빨간색의 노드가 모두 삭제 된 상황

  

![[image 350.png]]

2번 규칙을 수행해서 8, 9가 한 노드로 합쳐졌지만 부모 노드에 문제가 생겼다.

이럴 때는 3번 규칙에 따라야한다.

  

![[image 351.png]]

이 때는 1번 규칙부터 다시 시작을 해야하는데

형제 노드에 여유가 없어서(형제노드에 키가 30밖에 없어서 지원을 못함) 부모 노드인 15를

가져오고 형제 노드(30)와 합친다.

그럼 위 그림같은 형태가 되고

  

![[image 352.png]]

최종적으로 비어있는 노드들을 삭제하고 15, 30이 있는 노드가 루트 노드가 된다.

  

B tree의 삭제는 모두 leaf노드에서 삭제를 하는데 internal 노드 데이터를 삭제할 때는 어떻게?

  

### Internal node 삭제

![[image 353.png]]

삭제는 항상 leaf 노드에서 하므로 internal 노드의 값과 leaf 노드의 값 위치를 바꿔서 삭제를 하는데

어떤 값과 바꿀 것인가?

바로 삭제할 internal 노드의 선임자 또는 후임자와 바꿔서 삭제한다.

선임자 : 나보다 작은 데이터 중 가장 큰 데이터

후임자 : 나보다 큰 데이터 중 가장 작은 데이터

15를 기준으로 선임자 = 9, 후임자 = 20

  

![[image 354.png]]

선임자와 바꾼다고 하면 9와 위치를 바꾸고 15를 삭제

  

![[image 355.png]]

최종적으로 이렇게 바뀌게 되고 B Tree의 규칙도 만족하게 된다.

  

![[image 356.png]]

1. 삭제는 항상 leaf 노드에서 실시하고
2. 삭제 후 최소 key 수보다 적어지면 재조정(삽입과 동일하게)


**출처 : 유튜브 쉬운코드 https://www.youtube.com/@ezcd