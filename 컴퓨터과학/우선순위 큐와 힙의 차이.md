  

### priority queue : 큐와 유사하지만 우선순위가 높은 아이템 먼저 처리

  

우선순위 큐 주요 동작

-insert : 우선순위 정보와 같이 아이템을 넣는 것

-delete : 우선순위 높은 것 부터 빼냄

-peek : 우선순위 높은것 확인(빼내진 않음)

  

### Heap : 주로 이진트리(binary tree) 기반으로 구현

  

heap은 max heap과 min heap이 있음

-max heap : 부모 노드의 키가 자식 노드들의 키보다 크거나 같은 트리

-min heap : 부모 노드의 키가 자식 노드들의 키보다 작거나 같은 트리

  

힙의 주요 동작

-insert : 키값을 넣어줌

ex) max heap일 때 root 노드가 20이고 그 하위에 15와 5가 있다고 가정하고 17을 넣었을 때

우선 17을 제일 하위 노드로 넣는다(15의 자식노드로)

그 후 17과 그 부모인 15와 비교하고 17이 더 크기 때문에 17과 15의 자리를 스위칭한다.

다음 17과 그 부모인 20을 비교하는데 20이 더 크기 때문에 현재 자리에서 멈춘다.

min heap일 때는 반대로 작으면 스위칭

  

-delete : 가장 키값이 큰 값을 꺼냄(즉 루트 노드를 빼냄)

ex) max heap일 때 루트노드가 20이고 그 하위에 15와 5가 있고 15 밑에 2와 3이 있다고 가정

delete를 했을 때 루트노드인 20을 없애고 순번 상 가장 마지막의 노드(값이 가장 작은게 아님, 이진 트리는 위에서 아래 왼쪽에서 오른쪽 순으로 순번을 가짐)를 루트 노드로 옮김

여기서는 3이 순번 상 가장 마지막이므로 3이 루트 노드 자리로 옮겨짐

3을 자식노드인 15, 5와 비교를 해야하는데 15가 더 크므로 15와 3 스위칭

3과 그 자식 노드인 2를 비교하는데 3이 더 크므로 현 위치에 고정

min heap은 반대로 실행

  

-peek : 가장 큰 값을 확인(루트노드 확인)

  

### 우선순위 큐와 힙의 관계

힙의 키를 우선순위로 사용한다면 힙은 우선순위 큐의 구현체가 된다.

즉 우선순위 큐는 ADT이고 힙은 data structure이다.

  

### 우선순위 큐와 힙의 사용사례

프로세스 스케줄링(process scheduling)

>> CPU에서 멀티태스킹을 할 때 CPU에서 실행을 대기중인 프로세스/스레드 들은 ready queue라는 곳에서 대기를 한다.

여기서는 FIFO구조로 나가는게 아니라 우선순위를 매겨서 우선순위가 높은 애들이 먼저 CPU에서 실행된다.

  

힙 정렬(heap sort)

힙에 n개의 아이템을 넣어서 차례로 delete하면 정렬이 됨

  

### 여기서 정리한 힙과 힙 메모리는 관련이 없다.