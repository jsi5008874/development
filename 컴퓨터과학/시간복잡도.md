  

시간복잡도 : 함수의 실행 시간을 표현하는 것

주로 점근적 분석을 통해 실행 시간을 단순하게 표현하며 이 때 점근적 표기법으로 표현함

  

  

### 점근적 분석(Asymptotic analysis)

임의의 함수가 N → 무한대 일 때 어떤 함수 형태에 근접해지는지 분석

  

프로그래밍에서 어떤 함수를 실행했을 때 실행 시간이 어느정도일지 표현하려는 시도가 있었다.

그래서 실행 시간(running time)이란 개념을 함수/알고리즘 수행에 필요한 스텝(step)수 로 정의하고

각 라인을 수행하기 위해 필요한 스텝 수는 상수(고정된 값)로 가정했다.

  

![[점근적_분석.png]]

  

cost는 총 스텝 수를 표현한 것 >> 총 몇 단계로 이루어지는지

times는 각 스텝별 실행 횟수를 뜻함

c1 >> 1번만 실행, c2 >> for루프를 n번동안 돌고 마지막으로 탈출을 위한 점검을 위해 1번 더 실행

c3 >> for안에서 n번만큼 실행, c4 >> 1번만 실행

  

이를 바탕으로 계산하는 방법은

![[점근적_분석2.png]]

오른쪽의 T(N)을 구하는 식과 같다.

각 스텝별로 times를 곱해서 구하는 것인데 결국 이를 계산하는 이유 자체가 N이 작을 때는 의미가 없고 N이 높을 때를 위해 필요한 것이다.

예를들어 크기가 5인 배열을 통해 어떤 함수의 실행시간을 구하고자 하는것은 의미가 없다.

아무리 오래걸려봤자 금방 끝나기 때문이고 결국 N이 큰 함수들 즉 실행시간이 오래 걸릴만한 함수들을 위해 계산하는것이기 때문에 N이 큰 것에만 관심이 있는것이다.

  

여기서 최고차항만 의미가 있다는 것은 큰 수인 N과 관련된 항목만 있으면 된다는 것이고

최고차항의 계수가 의미 없다는 것은 N앞의 상수인 a는 의미가 없고 N만 필요하다는 뜻이다.

이로인한 결과물이 θ(N)이 되는 것이다.

**θ(N)이 점근적 표기법이다.**

  

  

### 상한선과 하한선

상한선(upper bound) : 함수 실행 시간은 아무리 오래 걸려도 N에 비례하는 정도 이하 >> O(N)

하한선(lower bound) : 함수 실행 시간은 아무리 빨라도 상수 시간 이상입니다. >> Ω(1)

  

ex) 크기가 5인 배열 inputs[5]가 있다고 가정

배열 내에 있는 숫자를 찾는다고 가정했을 때

상한선 >> 배열 제일 마지막에 있으면 n만큼 걸림(worst case)

하한선 >> 배열 제일 마지막에 있으면 1만큼 걸림(best case)

  

보통 worst case인 상한선을 기준으로 구한다.

  

![[점근적_분석3.png]]

  

표로 정리해보면 **θ(N)은 상한선, 하한선이 같을 때 표기하고 tight bound라고 한다.**

  

### 이진탐색 시간복잡도 구하기

  

worst case 구할 때

![[이진탐색_worst.png]]

  

결국 매번 실행할 때 마다 1/2씩 사이즈가 줄어든다 몇 번만에 사이즈는 1이 되는가?

input size를 N이라고 했을 때 N*(1/2)^k = 1

>> N/2^k = 1 >> N=2^k >> 양쪽에 lo2를 붙이면 log2 N = log2 2^k >> log2 2^k는 결국 k

따라서 k = log2 N >>> **θ(log N)**

  

best case 구할 때

![[이진탐색_best.png]]

이 때 시간복잡도는 **θ(1)**

  

### 시간복잡도 속도 비교

  

O(1) < O(log N) < O(N) < O(N*log N) < O(N^2) < O(2^N) < O(N!)

  

### big O 표기법을 많이 쓰는 이유

1. 일반적으로 upper bound만 알아도 충분하기 때문에
2. 다른 bound를 계산하기 귀찮아서
3. 괜히 tight boound로 말했다가 태클 받기 싫어서
4. 주위에서 다들 그렇게 쓰니까
5. 실은 점근적 표기법의 개념을 잘 모르고 씀..


**출처 : 유튜브 쉬운코드 https://www.youtube.com/@ezcd