  

서버에 들어오는 요청을 처리하는 방식 중

thread per request 모델이라는 방식이 있다.

이 방식은 들어오는 요청 한 개마다 한 개의 thread를 매핑하여 처리하게 하는 방식이다.

  

그런데 이렇게 서버에 들어오는 요청마다 스레드를 새로 만들어서 처리하고

처리가 끝난 스레드를 버리는 식으로 종작한다면 어떤 문제점이 있을까?

  

1. 스레드 생성에 소요되는 시간 때문에 요청 처리가 더 오래 걸린다.
2. 처리속도보다 더 빠르게 요청이 늘어나면 > 스레드 계속 생성(스레드 수 증가)

> 컨텍스트 스위칭 더 자주 발생 > CPU 오버헤드 증가로 CPU time 낭비 및 메모리 고갈

> 어느 순간 서버 전체가 응답 불가능 상태에 빠짐

  

### 이를 해결하기 위해 스레드 풀 개념이 등장

  

스레드 풀이라는 울타리 안에 제한된 개수의 스레드를 만들어두고

들어오는 요청을 스레드 풀 내부의 queue(자료구조, FIFO)에 순차적으로 저장한 후

스레드 풀에 있는 스레드들이 매핑해서 처리하고 처리가 완료되면 스레드들은 다시

스레드 풀로 돌아와서 다음 요청을 처리해준다.

  

즉 스레드 풀은 미리 스레드를 여러 개 만들어 놓고 재사용한다.

>스레드 생성 시간 절약, 스레드가 무제한으로 생성되는 것을 방지

  

### 스레드 풀 사례 : 여러 작업을 동시에 처리해야할 때

1. task를 subtask로 나뉘어서 동시에 처리

ex) 게임에 존재하는 모든 아이템의 가격을 더해야 한다면 무기류끼리 더하고, 방어구끼리 더한 값을

다시 더해주면 모든 아이템의 가격을 구할 수 있으므로 이를 동시에 처리

1. 순서 상관없이 동시 실행이 가능한 task 처리

  

### 스레드 풀에 몇 개의 스레드를 만들어 두는 게 적절한가?

CPU의 코어 개수와 task의 성향에 따라 다름

1. CPU-bound task 라면 코어 개수 만큼 혹은 그 보다 몇 개 더 많은 정도
2. I/O bound task라면 코어 개수보다 1.5배 ~ 3배 >> 경험적으로 찾아야함

  

### 스레드 풀에서 실행 될 task 개수에 제한이 없다면 스레드 풀의 큐 사이즈 제한이 있는지 확인해야함

  

예를 들어 요청이 계속 들어오는 상황에서 스레드풀에 있는 모든 스레드가 요청을 처리중이지만

큐에 요청이 계속해서 쌓이고 있다.

이는 메모리고갈을 유발하여 전체 시스템이 마비될 잠재적 위험요인이 된다.

따라서 스레드풀을 만들 때 큐 사이즈를 제한해줄 필요가 있다.

  

실제로 java에서 스레드풀을 만들 때 필요한 Excutor클래스의 newFixedThreadPool 메서드를 보면

큐사이즈가 무한정에 가깝다.

이렇듯 자바에서 제공하는 클래스라고 안심하지말고 확인해 볼 필요가 있다.

  

pool 이라는 개념은 스레드에서만 쓰이는것은 아니다.

connection pool : TCP 커넥션을 맺을 때 시간이 걸리는데 미리 TCP 커넥션을 만들어놓고 요청이 들어오면 커넥션을 맺어주는 개념

process pool : 프로세스를 여러개 만들어놓고 사용하는 것
