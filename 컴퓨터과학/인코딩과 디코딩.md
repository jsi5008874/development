  

인코딩 : **인코딩**은 사람이 읽을 수 있는 **문자 데이터를 이진 데이터(바이트 시퀀스)로 변환하는 과정**

- 예: `**A**` → `**01000001**` (ASCII 코드에 따라 변환)
- **목적**: 데이터를 저장하거나 전송할 때 컴퓨터가 처리할 **문자로 복원하는 과정**
- 예: `**01000001**` → `**A**`
- **목적**: 저장된 데이터를 사람이 읽거나 사용할 수 있도록 변환.

  

문자집합 : **특정 문자에 고유한 숫자를 매핑**한 표  
  

- **ASCII**: 영어 알파벳, 숫자, 기호 등을 7비트 숫자(0~127)로 매핑.
    - `**A**` → 65
    - `**B**` → 66
- **Unicode**: 전 세계의 모든 문자와 기호를 고유한 숫자로 매핑.
    - `**가**` → U+AC00
    - `**한**` → U+D55C

  

  

인코딩 방식 : **문자 집합에서 정의된 숫자를 바이트 시퀀스로 변환하는 방법**

- **UTF-8**: **가변 길이**(1~4바이트)를 사용하여 Unicode 문자를 표현.
    - `**A**` → 1바이트 (`**01000001**`)
    - `**한**` → 3바이트 (`**11101111 10101001 10001100**`)
- **UTF-16**: **고정 길이**(2바이트 또는 4바이트)로 Unicode 문자를 표현.
    - `**A**` → 2바이트 (`**00000000 01000001**`)
    - `**한**` → 2바이트 (`**11011000 11010101**`)

  

### 인코딩 과정

### **인코딩(문자 → 바이트 시퀀스)**

- 문자: `**한**`
    - Unicode 코드 포인트: U+D55C
    - UTF-8로 변환: `**11101111 10101001 10001100**`

  

### 디코딩 과정

### **디코딩(바이트 시퀀스 → 문자)**

- 바이트 시퀀스: `**11101111 10101001 10001100**`
    - UTF-8로 디코딩 → Unicode 코드 포인트: U+D55C → 문자 `**한**`

  

  

### 인코딩 방식과 다른 방식으로 디코딩 하면 문자가 깨지는 이유

ex) 한글을 UTF-8로 인코딩하고 ISO-8859-1로 디코딩 했을 경우 문자가 깨진다

반면 영어를 UTF-8로 인코딩하고 ISO-8859-1로 디코딩해도 깨지지 않는다.

  

우선 ASCII 코드를 알아야 하는데 ASCII는 7비트 문자체계로 가장 기본이 되는 인코딩 방식이다.

0~127 범위의 숫자로 영어 알파벳과 기호를 표현하는 체계이다.

  

ISO-8859-1도 1바이트 문자 인코딩 방식으로 ASCII와 비슷한 크기를 가지고 영어를 포함하고 있다.

  

반면 한글은 UTF-8로 인코딩 될 때 3byte의 크기를 가진다.

  

따라서 한글을 UTF-8로 인코딩을 하면 `**11101111 10101001 10001100**` (3바이트)

이런식으로 3바이트의 크기를 가진 바이트 시퀀스를 가지는데

이를 1바이트 체계인 ISO-8859-1로 디코딩을 한다면

  

- 첫 바이트 `**11101111**` → 문자 `**ï**`
- 두 번째 바이트 `**10101001**` → 문자 `**©**`
- 세 번째 바이트 `**10001100**` → 문자 `**ì**`

이런식으로 하나의 글자가 아닌 세 개의 글자로 쪼개져서 인식이 된다.