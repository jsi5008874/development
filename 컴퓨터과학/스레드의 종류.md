  

### 하드웨어 스레드

CPU core에서는 연산작업보다 메모리에서 데이터를 기다리는 시간이 상대적으로 더 길다.

그래서 이러면 core가 연산작업을 안하는 시간이 길어지는데 core를 낭비하는게 아닌가? 하는

의문이 생겼고 메모리를 기다리는 동안 다른 스레드를 실행하는건 어떨까? 하는 아이디어가

떠올랐다.

그래서 인텔의 hyper-threading이라는 기술이 생겼고 물리적인 코어마다 하드웨어 스레드가 두 개인

형태가 등장했다.

즉 하드웨어 스레드는 CPU core의 갯수로 인식하는 것이다.

  

하드웨어 스레드는 OS 관점에서는 가상의 코어이다.

이말은 싱글 코어 CPU에 하드웨어 스레드가 두 개라면 OS는 이 CPU를 듀얼 코어라고 인식하고

듀얼 코어에 맞춰 OS 레벨의 스레드들을 스케줄링한다.

  

### OS 스레드 : OS 커널 레벨에서 생성되고 관리되는 스레드

-CPU에서 실제로 실행되는 단위, CPU 스케줄링의 단위

-OS 스레드의 컨텍스트 스위칭은 커널이 개입 → CPU 연산 비용 발생

-개발자가 작성한 사용자 코드와 시스템 콜에 의한 커널 코드 모두 OS 스레드에서 실행된다.

  

OS 스레드의 또 다른 이름

1. 네이티브 스레드
2. 커널 스레드 >> OS 커널의 역할을 수행하는 스레드의 뜻으로 사용되기도 함
3. 커널-레벨 스레드
4. OS-레벨 스레드

  

ex) intel의 hyper-threading이 적용된 듀얼코어 CPU에 8개의 OS 스레드가 동작된다면?

hyper-threading으로 듀얼코어는 4개의 코어로 인식되고, 각각 코어마다 2개씩 OS 스레드가 실행

  

### User 스레드 : 스레드 개념을 프로그래밍 레벨에서 추상화 한 것

ex) java에서 thread를 생성할 때

Thread t1 = new Thread();

t1.start();

>> Thread 클래스의 start()메서드의 구현을 보면 start0()라는 메서드를 호출하는데 이것이

OS레벨의 Thread 생성을 하는 시스템 콜을 호출한다. 이로 인해 간접적으로 OS레벨의 스레드를 생성하는 것이다.

  

즉 유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 한다.

  

### 그렇다면 유저 스레드와 OS 스레드를 어떻게 연결시킬 것인가?

  

1. One to One model

>> 위의 java 예시처럼 유저 스레드와 OS 스레드가 1대1로 연결되는 것(start() 선언 당 OS 스레드 하나 생성)

특징 : 스레드 관리는 OS에게 위임(스케줄링 커널이 수행)

race condition 일어날 가능성 있음(OS레벨에 여러 스레드가 존재하면서 CPU에 실행되려고 하기 떄문에)

멀티코어 활용 가능(OS 스레드가 여러개 존재하기 때문에)

  

1. Many to One model

>> 유저 스레드가 여러개 있고 OS 스레드는 1개 있는 것

특징 : 컨텍스트 스위칭이 빠름(컨텍스트 스위칭이 유저레벨에서 일어나고 커널이 개입하지 않아서)

race condition 일어날 가능성 적음(OS 레벨에 스레드가 하나만 있어서)

멀티코어 활용 못함(OS 스레드가 한개만 있어서)

  

1. Many to Many model

>> 유저, OS 스레드 모두 다수이지만 상황에 맞춰 짝을 지어줌

one to one과 다른 점은 one to one은 정해진 짝에게만 할당되지만 Many to Many는 상황에 맞춰 짝이 바뀜

특징 : one to one과 Many to One 의 장점을 모두 가짐 하지만 구현이 어려움

  

하지만 기술 문서에서 OS와는 독립적으로 유저 레벨에서 스케줄링되는 스레드로 표현할 때도 있는데 맥락에 따라 잘 파악해서 읽어야함

  

### 그린 스레드 : java 초창기 버전은 Many to One 스레딩 모델을 사용, 이 때

### 유저 스레드들을 그린 스레드라고 호칭 하지만 이제는 확장 된 의미로 사용되는데 OS와는 독립적으로 유저 레벨에서 스케줄링되는 스레드를 뜻함