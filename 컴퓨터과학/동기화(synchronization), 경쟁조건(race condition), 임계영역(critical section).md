  

### 경쟁조건(race condition)

여러 프로세스/스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가

달라질 수 있는 상황

  

ex)

하나의 객체를 두 개의 스레드가 접근할 때 생기는 일

  

귤 두박스에서 상한귤을 골라내는데 두개의 스레드를 사용해서 스레드당 한개의 박스씩 맡아서

상한귤을 카운트한다고 가정해보자

  

for(귤 in 귤박스){

if(귤 상태 is 불량){

badCounter.increment();}}

  

public class Counter{

private int state = 0;

public void increment(){ state++; }

public int get(){ return state; }}

  

T1, T2 스레드가 싱글코어인 CPU에 접근해서 상한귤을 센다고 가정

  

1. T1, T2는 동일 프로세스의 스레드들이고 같은 힙을 공유하는 스레드들이다.
2. 여기서 힙에 badCounter 객체가 생성되고 힙 안에 state = 0이 자리를 잡는다.
3. 우선 알고 있어야할 개념은 state++가 cpu에서는 어떻게 작동하는지 알아야한다.
4. state++는 인간이 알아보기 편한 프로그래밍언어이고 cpu에서 작동하는 명령어는

ㄱ. Load state to R1(레지스터1이라는 뜻) >> state를 1번 레지스터에 로드

ㄴ. R1 = R1 + 1 >> r1(state)에 1을 더해줌

ㄷ. store R1 to state >> R1을 state로 전환(메모리로 로드)

1. cpu에서는 이렇게 3단계로 나눠서 state++를 연산한다.
2. 여기서 문제는 T1이 먼저 CPU에서 실행 중 ㄴ에서 ㄷ으로 넘어가는중에 T2로 컨텍스트 스위칭이 발생했다.
3. 그럼 T1은 실행을 멈추고 대기에 들어가고 T2의 연산이 시작된다.
4. T2의 연산이 끝나고 힙에 있는 state = 1로 변경된다.
5. T1은 아까 멈췄던 연산을 이어서 하는데 이미 R1은 1이기 때문에 1을 더하지 않고 실행을 멈춘다.
6. 우리가 처음 기대 했던것은 T1, T2 모두 상한귤을 한 개씩 찾았기 때문에 state=2일 것으로 기대했지만
7. 결국 컨텍스트 스위칭으로 인해 문제가 생겨 state=1로 연산이 끝났다.

  

위의 예시에서 본것이 경쟁조건의 개념이다. 여러 프로세스나 스레드가 동시에 같은 데이터를 조작하면 결과가 달라질 수 있다.

  

### 이런 문제를 해결하기위해 동기화(synchronization)이 등장했다.

정의 : 여러 프로세스 / 스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것

  

동기화를 어떻게 할 것인가?

CPU에 load가 되면 컨텍스트 스위칭을 못하게 막아보면 어떨까?

그것도 방법이 되지만 CPU가 듀얼코어라면 아무런 의미가 없다.

  

그래서 생각한 방법이 임계영역이다.

위의 예시를 통해 보면 한 프로세스나 스레드가 increment() 메서드를 사용중이라면

다른 프로세스나 스레드가 해당 메서드를 사용하지 못하도록 하는 것이다.

이를 통해 경쟁조건으로 생기는 오류를 막을 수 있다.

  

### 임계 영역(critical section)

정의 : 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스 / 스레드만 진입해서 실행

가능한 영역

  

임계영역의 뼈대는 아래의 모양과 같다.

  

do{

entry section >> 임계영역 진입점

critical section >> 임계영역에서 수행

exit section >> 수행완료 후 퇴장점

remainder section >> 이후에 각자 해야할 수행들

} while(true)

  

critical section problem의 해결책이 되기 위한 조건

1. mutual exclusion(상호 배제) : 한번에 하나의 프로세스 / 스레드만 임계영역에서 실행가능
2. progerss(진행) : 임계영역이 비어있고 어떤 프로세스나 스레드가 임계영역에 진입해서 실행하고 싶다면 들어가서 실행해야한다.(지속적으로 실행되어야한다.)
3. bounded waiting(한정된 대기) : 어떤 프로세스나 스레드가 임계영역에 들어가지 못하고 무한정으로 대기만해서는 안된다.

  

개발할 때 항상 Thread-unsafe를 조심해야한다.

예로 java에 SimpleDateFormat이라는 클래스가 있는데 해당 클래스 문서를 읽어보면

이 클래스는 동기화 되어있지 않아서 멀티스레드가 접근하면 반드시 동기화를 시켜줘야한다고 나와있다. 이처럼 개발 시 확인을 해봐야한다.

  

[[동기화를 위한 락 메커니즘]]

[[모니터(monitor)]]


**출처 : 유튜브 쉬운코드 https://www.youtube.com/@ezcd