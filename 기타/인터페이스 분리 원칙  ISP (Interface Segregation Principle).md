  

범용적인 인터페이스 보다는 클라이언트(사용자)가 실제로 사용하는 Interface를 만들어야 한다는 의미로, **인터페이스를 사용에 맞게 끔 각기 분리**해야한다는 설계 원칙  
  

인터페이스를 잘게 분리함으로써, **클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공**  
  

![[image 322.png]]

  

위의 예시처럼 Dog는 인터페이스의 bark() 추상메서드를 사용하지만 Cat은 사용하지 않으므로

우측 그림처럼 Dog 인터페이스와 Cat 인터페이스로 분리해서 설계

  

인터페이스 분리 원칙은 마치 단일 책임 원칙과 비슷하게 보이는데, **SRP 원칙이 클래스의 단일 책임**을 강조한다면, **ISP는 인터페이스의 단일 책임**을 강조  
  
  

### ISP 위반 예제

  

```Java
interface ISmartPhone {
void call(String number); // 통화 기능
void message(String number, String text); // 문제 메세지 전송 기능
void wirelessCharge(); // 무선 충전 기능
void AR(); // 증강 현실(AR) 기능
void biometrics(); // 생체 인식 기능
}
```

스마트폰의 기능을 담은 인터페이스

현재의 스마트폰은 가능한 생체인식기능, 무선충전기능 등이 담겨있다.

현재 존재하는 스마트폰은 모두 오버라이딩이 가능하지만

옛날 기종인 갤럭시 S2, S3와 같은 핸드폰이 상속받는다면 문제가 생긴다.

해당 핸드폰에는 없는 기능이므로 오버라이딩을 해도 비어있는 메서드로 만들거나

exception 처리를 해줘야한다.

  

따라서 각각의 기능에 맞게 인터페이스를 잘게 분리해준다.

![[image 323.png]]

이처럼 인터페이스를 분리해서 상속받는 클래스에서 쓸데없는 오버라이딩을 하지 않게 만들어준다.

  

  

```Java
class S21 implements IPhone, WirelessChargable, ARable, Biometricsable {
public void call(String number) {
}
public void message(String number, String text) {
}

public void wirelessCharge() {
}

public void AR() {
}

public void biometrics() {
}
}

class S3 implements IPhone {
public void call(String number) {
}
public void message(String number, String text) {
}
}
```

  

### **SRP 와 ISP 원칙 사이의 관계**

  

SRP가 클래스의 단일 책임 원칙이라면, ISP는 인터페이스의 단일 책임 원칙이라고 했다.

즉, 인터페이스에 기능에 대한 책임에 맞게 추상 메소드를 구성하면 된다는 말이다.

하지만 책임을 준수하더라도 실무에서는 ISP가 만족되지 않을 수 있는 케이스가 존재한다.

  

![[image 324.png]]

위와 같이 게시판 인터페이스엔 글쓰기, 읽기, 삭제 추상 메서드가 정의되어 있다. 이들은 모두 게시판에 필요한 기능들이며 게시판만을 이용하는 단일 책임에 위배되지 않는다.

하지만 이를 구현하는 일반 사용자 입장에선 게시글 강제 삭제 기능은 사용할 수 없기 때문에 결국 ISP 위반으로 이어진다.

따라서 책임을 잘 구성해 놓은 것 같지만 실제 적용되는 객체에겐 부합되지 않을 수 있기 때문에 책임을 더 분리해야 한다.

정리하자면, **ISP는 SRP를 만족하면 성립되는가** 라고 질문한다면 **반드시 그렇다고는 볼 수 없다**고 답변하는게 맞을지도 모른다.

  

### **인터페이스 분리는 한번만**

한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말라는 점

  

이미 구현되어 있는 프로젝트에 또 인터페이스들을 분리한다면, 이미 해당 인터페이스를 구현하고 있는 온갖 클래스들과 이를 사용하고 있는 클라이언트(사용자)에서 문제가 일어날 수 있기 때문이다.

본래 인터페이스라는 건 **한번 구성하였으면 왠만해선 변하면 안되는 정책**같은 개념이다.

따라서 처음 설계부터 기능의 변화를 생각해두고 인터페이스를 설계해야 하는데, 이는 현실적으로 참 힘든 부분이며 역시 개발자의 역량에 달렸다.



**출처 : https://inpa.tistory.com/