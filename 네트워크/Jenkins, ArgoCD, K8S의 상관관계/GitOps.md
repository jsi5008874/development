클라우드 네이티브 애플리케이션과 인프라의 배포와 운영을 자동화하는 실천 방법론
Git 저장소를 진실의 원천(source of truth)로 활용하여 인프라와 애플리케이션이 원하는 상태를 선언적으로 정의

### GitOps 주요 원칙
- **선언적 인프라**:
    - 시스템의 원하는 상태를 코드(YAML, JSON 등)로 정의
    - "어떻게(how)" 배포할지가 아닌 "무엇(what)"을 배포할지 선언
- **Git을 단일 진실 원천으로 사용**:
    - 인프라와 애플리케이션의 모든 구성이 Git 저장소에 저장
    - 버전 관리, 변경 이력 추적, 감사 가능성을 제공
- **변경 사항 자동 감지 및 적용**:
    - 도구(예: ArgoCD, Flux)가 Git 저장소의 변경을 감지하고 클러스터에 적용
    - 환경(개발, 스테이징, 프로덕션)의 상태가 저장소와 일치하도록 유지
- **차이 해결(State Reconciliation)**:
    - 실제 시스템 상태와 선언된 상태 간의 차이를 지속적으로 감지하고 해결
    - 드리프트(drift, 수동 변경으로 인한 불일치)를 자동으로 교정

### GitOps의 장점
- **향상된 보안**:
    - 인프라에 직접 접근할 필요 없이 Git을 통해 변경 사항을 적용
    - Git의 접근 제어 및 승인 메커니즘을 활용
- **일관성과 표준화**:
    - 모든 환경이 동일한 방식으로 정의되고 업데이트
    - 수동 배포로 인한 오류가 감소
- **신속한 복구**:
    - 문제 발생 시 이전 상태로 신속하게 롤백
    - Git 기록을 활용한 시스템 상태 추적이 가능
- **개발자 경험 향상**:
    - 개발자가 친숙한 Git 워크플로우로 인프라 변경을 제안하고 검토
    - Pull Request로 변경 사항을 논의하고 승인

### 전통적인 CI/CD와 GitOps의 차이점

전통적인 CI/CD 파이프라인은 push 기반이다.
jenkins 같은 도구가 코드를 빌드하고 직접 환경에 배포(예전에는 jenkins가 CI/CD 모두 수행)
jenkins가 쿠버네티스에 직접 배포를 실행했었음

하지만 GitOps는 pull 기반 접근 방식
jenkins는 CI와 git 저장소 업데이트만 담당하고 실제 배포는 ArgoCd 같은 도구가 pull 방식으로 처리


### push 방식과 pull 방식의 차이점
**push 방식**
CI도구(jenkins)가 코드를 빌드하고 직접 환경(쿠버네티스)에 밀어 넣고 CI 서버가 배포 프로세스를 주도
CI 서버가 모든 환경(개발, 스테이징, 프로덕션)에 직접 접근 권한을 가진다.

**pull 방식**
배포 환경 내부의 에이전트(ArgoCD)가 git에서 원하는 상태를 당겨와 적용
배포환경(쿠버네티스)이 배포 프로세스를 주도
jenkins는 매니페스트만 업데이트하고 ArgoCD가 이를 클러스터에 적용


### pull 방식이 안정성이 더 좋은 이유
push 방식은 여러 변수로 인해 git 저장소와 배포 환경이 일치하지 않을 수 있다.
개발자가 긴급 상황에서 git을 거치지 않고 배포를 하거나, CI도구가 git 저장소의 코드를 빌드한 후 배포를 시도했지만
배포 실패 했을 때 git과 실제 환경 사이에 불일치가 발생하기도 한다.

**하지만 pull 방식은 배포 환경이 주도적으로 싱크를 맞추기 때문에 싱크가 맞지 않는 경우가 현저히 적다.**
**그래서 현재는 pull 방식의 배포 환경을 주로 세팅한다.**