  

논리적인 의미로 컴퓨터 네트워크를 경유하는 프로세스 간 통신(Inter-Process Communication, IPC)의 **종착점(end-point)**
네트워크를 이용해 데이터를 송수신 하고 싶은 프로그램들은 소켓을 거쳐야 한다.

통신을 통해 전달되는 모든 데이터 포맷은 5-tuple 이라는 규격에 맞추어 흐르게 된다.

1. **프로토콜 (Protocol)**
2. **호스트 IP 주소 (source IP address)**
3. **호스트 port 번호 (source port nunber)**
4. **목적지 IP 주소 (destination IP address)**
5. **목적지 port 번호 (destination port number)**

- **IP 주소:** 호스트(컴퓨터, 스마트 폰 등의 단말기)들을 식별할 수 있는 고유한 주소다. IP 주소가 있으면 어떤 호스트에 데이터를 보내는 지, 누가 보내는 지를 알 수 있다.
- **port 번호:** 호스트 내의 프로세스들을 식별할 수 있는 번호다.

소켓도 위 정보들인 프로토콜, IP 주소, port 번호가 있어야 정의된다.

  

누가 어디로 보낼 지를 정의하기 위한 주소로 IP와 port 정보가 필요하다. **IP 주소**는 어떤 호스트(단말기)로 데이터를 보내야 할 지 알려준다. IP 주소를 이용해 원하는 호스트에 도착했다고 끝이 아니라 송수신할 프로세스를 찾아야 한다. 소켓은 프로세스 간 통신을 하기 위한 api다. 이때 **port 번호**를 통해 어떤 프로세스에 가야할 지 정할 수 있다.

  

## 특징

### server-client 구조

TCP/UDP 위에서 동작하므로 당연하게 server-client 통신 구조를 갖춘다.

처음에 데이터를 보내는 쪽이 client가 되고, 받는 쪽이 server가 된다. 이후에는 서로가 데이터를 송수신할 수 있다. (자세한 설명은 아래)

### 양방향 통신

socket은 한 쪽에서 데이터를 보내고 반대 편에서 이를 수신한 뒤 연결이 끊어지는게 아니라 양 쪽에서 실시간으로 데이터를 송수신할 수 있다. 따라서 실시간 스트리밍이나 채팅에 주로 유용하게 사용된다.

### 프로그래밍 언어나 운영체제에 종속적

socket은 TCP/IP 표준이 아니라 네트워크 프로그래밍 인터페이스다. 따라서 운영체제마다 사용법이 약간씩 다르며, 그 안에서 또 프로그래밍 언어마다 소켓 api를 구현한 라이브러리가 다 다르다.


## 하나의 포트에 여러 개의 소켓 연결이 가능한 이유
```
[서버: localhost:8080]  ← 하나의 포트만 열림
         ↓
    ┌────┴────┐
    │  Listen │  ← 이 포트가 계속 열려있음
    └────┬────┘
         ├─→ 연결1: 클라이언트A (192.168.1.10:54321) ↔ 서버 (localhost:8080)
         ├─→ 연결2: 클라이언트B (192.168.1.11:54322) ↔ 서버 (localhost:8080)
         ├─→ 연결3: 클라이언트C (192.168.1.12:54323) ↔ 서버 (localhost:8080)
         └─→ ... (수천 개 가능)
```

### 파일 디스크립터를 통한 관리(리눅스 기준)
파일 디스크립터란 운영체제가 관리하는 열린 파일/소켓/장치를 가리키는 정수
즉 소켓 통신도 연결이 되면 파일 디스크립터로 관리가 시작된다.

파일 디스크립터 생성 과정
```
소켓 통신 연결 시 서버에서 accept() 시스템콜을 호출
1. 대기 중인 연결을 하나 꺼냄 
2. 새로운 파일 디스크립터 생성
3. 해당 FD를 클라이언트와의 연결에 연결

ex)   
int client_fd_2 = accept(server_fd, &client_addr, &addr_len); 
// 반환값: client_fd_2 = 5 


메모리 상태:
 [프로세스 파일 디스크립터 테이블]
 FD 0: stdin 
 FD 1: stdout 
 FD 2: stderr 
 FD 3: 소켓(포트 8080, LISTEN) ← 서버에서 실행중인 프로세스 LISTEN 상태로 대기중
 FD 4: 소켓(192.168.1.10:54321 ↔ localhost:8080) ← 클라이언트 A 소켓 통신 
 FD 5: 소켓(192.168.1.11:54322 ↔ localhost:8080) ← 클라이언트 B 소켓 통신

핵심: 하나의 포트, 여러 파일 디스크립터
포트 8080 (FD 3):
├─ 역할: 새 연결 받기 (LISTEN)
├─ 상태: 계속 열려있음
└─ accept() 호출 시마다 새 FD 생성

연결 1 (FD 4):
├─ 클라이언트: 192.168.1.10:54321
├─ 서버: localhost:8080
└─ 이 연결을 통해 데이터 송수신

연결 2 (FD 5):
├─ 클라이언트: 192.168.1.11:54322
├─ 서버: localhost:8080
└─ 이 연결을 통해 데이터 송수신
```
즉 하나의 포트에 한 개의 연결만 가능한게 아니라
파일 디스크립터를 통해 여러 개의 소켓 통신이 연결될 수 있다.