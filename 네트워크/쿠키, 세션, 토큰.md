  

로그인 할 때 서버에서 로그인 여부를 알기 위해 쿠키, 세션, 토큰 3가지 방법을 사용

  

로그인 중인지 확인하는 이유는 HTTP의 특성 때문이다.

HTTP는 stateless(무상태) 특성이 있다.

**무상태 특성이란 HTTP 각각의 요청은 독립적이며 이전 요청과는 아무 상관이 없어서**

**요청의 상태를 유지하지 않는다는 뜻이다.**

ex) A가 로그인 요청을 보낸 후 로그인을 하고 나면 이후에 게시판 조회 요청을 보냈다고 가정

이 때 로그인 요청과 게시판 조회 요청은 서로 다른 요청이므로 아무 연관이 없다.

따라서 로그인 완료된 상태를 유지하지 않으면 게시판 조회 요청을 했을 때 서버에서는 해당 요청을 보낸 사용자가 로그인을 한 상태인지 모르기 때문에 요청을 거절하게 된다.

  

**서버에서는 사용자의 로그인 상태를 유지해야 하는데 그 때 사용되는 것이 쿠키, 세션, 토큰이다.**

  

### 쿠키

사용자의 브라우저에 저장되는 작은 데이터 파일, 주로 클라이언트 측에서 세션 관리나 사용자 상태 유지에 사용

  

용도 : 로그인 상태 유지, 사용자 설정 저장, 트래킹 등

만료 시간 : 세션 쿠키(브라우저 종료 시 삭제), 영속 쿠키(정해진 만료 날짜까지 유지)

보안 : 기본적으로 암호화 되지 않으나 Secure, HttpOnly, SameSite 같은 보안 옵션 설정

  

### 세션

서버 측에서 사용자의 상태 정보를 저장하는 방법

사용자가 웹 어플리케이션에 접속할 때 서버에서 세션을 생성, 세션 ID를 클라이언트에 전달

이후의 요청에서 세션 ID를 통해 세션을 추적

주로 세션 정보를 세션 스토리지(개별적인 세션 DB 서버)에 저장하거나 Redis를 활용하여

세션 정보를 관리

  

용도 : 서버 측에서 인증과 사용자 추적에 사용

만료 시간 : 일정 시간 동안 활동이 없으면 만료되거나 클라이언트가 브라우저를 닫으면 종료

보안 : 세션 ID가 쿠키로 클라이언트에 전달되며 세션 데이터를 서버에서 관리하므로 더 안전

  

### 토큰

사용자 인증 정보를 담고 있는 문자열 주로 JWT(Json Web Token) 방식 사용

세션과 다른 점은 서버 측에 추가적인 저장소 없이 클라이언트와 상태 정보를 교환

토큰은 클라이언트 측에 저장

  

용도 : 토큰 기반 인증에 사용되며 서버에서 토큰을 생성 후 클라이언트에 전달하고

이후 요청에서 클라이언트가 토큰을 서버로 보내어 인증 수행

만료 시간 : 토큰 내부에 만료 시간을 포함

보안 : 서명을 통해 데이터 무결성 보장

  

  

**보통 쿠키 + 세션 또는 쿠키 + 토큰을 사용**

  

### 쿠키 + 세션

1. 사용자가 로그인하면 서버가 세션 생성 및 세션 ID 발급
2. 서버는 세션ID를 클라이언트의 쿠키에 저장
3. 클라이언트가 요청을 보낼 때 브라우저가 자동으로 쿠키를 포함
4. 서버는 해당 세션ID를 통해 세션 정보를 찾아 인증을 유지

  

### 쿠키 + 토큰

1. 사용자가 로그인하면 서버가 JWT(토큰)를 발급하고 쿠키에 저장
2. 클라이언트가 요청 시 토큰을 포함하면 서버가 검증 후 인증
```
## 토큰의 생성 및 검증 방법

토큰의 구조
Header : 토큰 타입과 알고리즘 정보
payload : 실제 데이터(사용자 ID, 권한 등)
signature : header + payload를 비밀키로 암호화한 서명

토큰의 생성
header, payload를 비밀키로 암호화하여 서명을 생성
header + payload + signature의 구조가 만들어져 토큰을 생성한다.

토큰의 검증 : 서명을 검증하는 방식
1. 받은 토큰의 header, payload를 이용하여 서버의 비밀키로 다시 암호화한다.
2. 새로 생성한 서명과 받은 토큰의 서명을 비교한다.
3. 일치하면 인증 성공, 일치하지 않으면 인증 실패

ex)
실제 토큰 : abc(header).jsclient(payload).sqwer12345s(signature)
위조된 토큰 : abc(header).jsadmin(payload).sqwer12345s(signature)
>> 역할을 클라이언트에서 어드민으로 변조한 경우

1. 클라이언트 역할일 때 header+payload를 서버의 비밀키로 암호화 했을 때 나오는 서명은 sqwer12345s
2. 위조된 토큰은 header+payload를 암호화해도 역할을 admind으로 바꿨기 때문에 서명이 sqwer12345s값이 아닌 다른 값이 나오게됨
3. 서버에서 위조된 토큰에서 받은 서명(sqwer12345s)과 위조된 토큰의 header+payload로 암호화한 값이 다르기 때문에 인증을 거부한다.

따라서 토큰을 위조하더라도 서버의 비밀키를 알지 못하면 결국 서명을 검증하는 과정에서 걸러진다.
```
  

  

[[쿠키, 세션, 토큰 보안 문제]]