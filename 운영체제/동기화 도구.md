## mutex
한 번에 하나의 스레드만 임계 영역에 접근 가능
Binary Lock(0또는, 잠김/열림)

### 뮤텍스의 구성
lock()/acquire() : lock 획득
unlock()/release() : lock 해제
owner : 락 소유자(프로세스/스레드)
wait queue : 락 대기 큐

```java
    public void lock() {
        if (locked) {
            현재_스레드를_waitQueue에_추가();
            현재_스레드를_블록();
        } else {
            locked = true;
            owner = 현재_스레드;
        }
    }
    // lock이 있으면 현재 스레드가 락 획득 그렇지 않으면 현재 스레드를 wait queue에 추가
    
    public void unlock() {
        if (owner != 현재_스레드) {
            예외_발생();  // ← 중요! 소유자만 해제 가능
        }
        locked = false;
        owner = null;
        waitQueue에서_하나_깨움();
    }
	// unlock은 락 소유자만 해제 가능, 해제 후 wait queue에서 대기중인 스레드 중 하나를 깨움
```

### 뮤텍스의 예시
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample1 {
    
    static class BankAccount {
        private int balance = 1000;
        private final Lock mutex = new ReentrantLock();
        
        public void withdraw(String name, int amount) {
            System.out.println("\n[" + name + "] 출금 시도: " + amount + "원");
            System.out.println("[" + name + "] mutex.lock() 호출...");
            
            mutex.lock();  // ← Mutex 획득 (lock)
            
            try {
                System.out.println("[" + name + "] ✅ Mutex 획득! (Owner: " + name + ")");
                System.out.println("[" + name + "] 현재 잔액: " + balance + "원");
                
                if (balance >= amount) {
                    System.out.println("[" + name + "] 출금 처리 중...");
                    Thread.sleep(1000);  // 처리 시간 시뮬레이션
                    
                    balance -= amount;
                    System.out.println("[" + name + "] 출금 완료!");
                    System.out.println("[" + name + "] 남은 잔액: " + balance + "원");
                } else {
                    System.out.println("[" + name + "] ❌ 잔액 부족!");
                }
                
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println("[" + name + "] mutex.unlock() - Mutex 해제");
                mutex.unlock();  // ← Mutex 해제 (unlock)
                // 중요: 반드시 같은 스레드가 unlock 해야 함!
            }
        }
        
        public void deposit(String name, int amount) {
            System.out.println("\n[" + name + "] 입금 시도: " + amount + "원");
            
            mutex.lock();
            try {
                System.out.println("[" + name + "] ✅ Mutex 획득!");
                System.out.println("[" + name + "] 현재 잔액: " + balance + "원");
                
                balance += amount;
                System.out.println("[" + name + "] 입금 완료!");
                System.out.println("[" + name + "] 남은 잔액: " + balance + "원");
                
            } finally {
                mutex.unlock();
            }
        }
    }
    
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        
        // 3명이 동시에 출금 시도
        Thread t1 = new Thread(() -> account.withdraw("철수", 300), "철수");
        Thread t2 = new Thread(() -> account.withdraw("영희", 500), "영희");
        Thread t3 = new Thread(() -> account.withdraw("민수", 400), "민수");
        
        t1.start();
        t2.start();
        t3.start();
    }
}

실행 과정:
시작: balance = 1000

[철수] mutex.lock() → 성공! (Owner: 철수)
┌──────────────────────┐
│ Mutex                │
│ locked: true         │
│ owner: 철수          │
│ Wait Queue: []       │
└──────────────────────┘

[영희] mutex.lock() → 대기!
[민수] mutex.lock() → 대기!
┌──────────────────────┐
│ Mutex                │
│ locked: true         │
│ owner: 철수          │
│ Wait Queue: [영희, 민수]
└──────────────────────┘

[철수] balance -= 300 → balance = 700
[철수] mutex.unlock()
┌──────────────────────┐
│ Mutex                │
│ locked: false        │
│ owner: null          │
│ Wait Queue: [민수]   │  ← 영희 깨어남
└──────────────────────┘

[영희] mutex.lock() 성공!
```

## semaphore
정수 값을 가진 카운팅 메커니즘
여러 스레드가 동시에 리소스에 접근할 수 있는 개수를 제어

### 세마포의 구성
counter(정수 값) : 접근 가능 개수를 뜻함
waiting queue : 대기 큐로 접근 가능 개수를 초과하는 프로세스/스레드가 접근 시 초과되는 프로세스/스레드가 대기하는 큐

wait()/acquire() : 카운터를 감소시키고 임계구역 진입을 허용, 카운터가 0보다 클 때만 실행 가능
signal()/release() : 임계구역 퇴장 시 카운터를 증가시키고 대기 큐의 스레드 중 한 개를 깨움

### 세마포의 예시
```java
public class SemaphoreDetailExample {
    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(2); // 카운터 = 2     
        
        // Thread-1
        Thread t1 = new Thread(() -> {
            try {
                semaphore.wait();
                
                //임계 구역
                Thread.sleep(3000);
                
                semaphore.signal();
                
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        // Thread-2
        Thread t2 = new Thread(() -> {
            // t1과 동일
        });
        
        // Thread-3(블로킹됨)
        Thread t3 = new Thread(() -> {
            // t1과 동일
        });
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
    }
}

실행 결과 해석:

시간 0초: 카운터 = 2
    ↓
Thread-1 wait() → 카운터 = 1 (성공)
    ↓
Thread-2 wait() → 카운터 = 0 (성공)
    ↓
Thread-3 wait() → 대기 큐 진입 (블록!)
    ↓
Thread-1 signal() → 카운터 = 1, Thread-3 깨어남!
    ↓
Thread-3 wait() 완료 → 카운터 = 0
```
예시와 같이 동시 접근 가능 개수는 2이므로 t1, t2가 먼저 접근을 했고
t3이 접근 시에는 블록 됐다가 t1이 signal()로 waiting queue에서 t3을 깨워야 t3이 실행가능하다.


## monitor
객체 지향적 동기화 메커니즘
한 번에 하나의 스레드만 모니터 내부에 접근 가능

Java의 synchronized가 모니터를 활용함
### 모니터의 구성
Lock(뮤텍스) : 모니터에 진입하기 위한 lock
Entry Queue : 진입 대기 큐
Wait Set : 조건 대기 큐
```
# Entry Queue와 Wait Set의 차이점
모니터는 락을 획득한 후 모니터 내부로 진입하여 코드를 실행하고 빠져나와야한다.

Entry Queue는 락을 획득하지 못해서 모니터의 외부에서 대기하는 것이고
Wait Set은 락은 획득 했으나 모니터 내부 코드 실행 중 조건을 만족하지 못해 대기 할 때 모니터 내부에서 대기하는 것이다.
(모니터 내부 코드 실행 중 if(vaue>1) 조건식이 존재하는데 현재 실행중에 해당 조건을 만족하지 못하는 경우 wait set에서 대기)

그래서 Entry Queue는 진입 대기 큐이고 Wait Set은 조건 대기 큐이다.
```

wait() : 락을 해제하여 프로세스/스레드를 wait set으로 이동
notify() : wait set에서 프로세스/스레드 중 하나를 Entry Queue로 이동
notifyall() : wait set에 존재하는 모든 프로세스/스레드를 Entry Queue로 이동

### 예시
```java
public class MonitorDetailExample {
    
    static class SharedBuffer {
        private int data = 0;
        private boolean hasData = false;
        
        // 생산자 메서드
        public synchronized void produce(int value) throws InterruptedException {
            System.out.println("\n[생산자] synchronized 블록 진입 시도");
            System.out.println("[생산자] 모니터 락 획득!");
            
            // 버퍼가 비어있을 때까지 대기
            while (hasData) {
                System.out.println("[생산자] 버퍼 가득참 → wait() 호출");
                System.out.println("[생산자] 모니터 락 해제 + Wait Set 진입");
                
                wait();  // 락 해제하고 대기
                
                System.out.println("[생산자] 깨어남! 다시 락 획득 시도");
                System.out.println("[생산자] 락 재획득 성공!");
            }
            
            // 데이터 생산
            data = value;
            hasData = true;
            System.out.println("[생산자] 데이터 생산: " + value);
            
            System.out.println("[생산자] notifyAll() 호출 - Wait Set의 모든 스레드 깨움");
            notifyAll();
            
            System.out.println("[생산자] synchronized 블록 종료 → 락 해제");
        }
        
        // 소비자 메서드
        public synchronized int consume() throws InterruptedException {
            System.out.println("\n[소비자] synchronized 블록 진입 시도");
            System.out.println("[소비자] 모니터 락 획득!");
            
            // 버퍼에 데이터가 있을 때까지 대기
            while (!hasData) {
                System.out.println("[소비자] 버퍼 비어있음 → wait() 호출");
                System.out.println("[소비자] 모니터 락 해제 + Wait Set 진입");
                
                wait();  // 락 해제하고 대기
                
                System.out.println("[소비자] 깨어남! 다시 락 획득 시도");
                System.out.println("[소비자] 락 재획득 성공!");
            }
            
            // 데이터 소비
            int value = data;
            hasData = false;
            System.out.println("[소비자] 데이터 소비: " + value);
            
            System.out.println("[소비자] notifyAll() 호출 - Wait Set의 모든 스레드 깨움");
            notifyAll();
            
            System.out.println("[소비자] synchronized 블록 종료 → 락 해제");
            return value;
        }
    }
    
    public static void main(String[] args) {
        SharedBuffer buffer = new SharedBuffer();
        
        // 소비자 먼저 시작 (버퍼 비어있어서 대기할 것)
        Thread consumer = new Thread(() -> {
            try {
                buffer.consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "소비자");
        
        // 생산자는 1초 후 시작
        Thread producer = new Thread(() -> {
            try {
                Thread.sleep(1000);
                buffer.produce(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "생산자");
        
        consumer.start();
        producer.start();
        
        try {
            consumer.join();
            producer.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

### 실행 과정 상세 분석
1. 소비자 시작
   ├─ synchronized 블록 진입
   ├─ 모니터 락 획득
   ├─ hasData == false → wait() 호출
   ├─ 모니터 락 해제!
   ├─ Wait Set에 진입
   └─ 블록 상태로 대기...

2. 생산자 시작 (1초 후)
   ├─ synchronized 블록 진입 시도
   ├─ 모니터 락 획득 (소비자가 wait()로 해제했으므로)
   ├─ data = 100, hasData = true 설정
   ├─ notifyAll() 호출
   │  └─ 소비자를 Wait Set에서 Entry Queue로 이동
   └─ synchronized 블록 종료 → 락 해제

3. 소비자 깨어남
   ├─ Entry Queue에서 대기
   ├─ 모니터 락 획득 (생산자가 해제했으므로)
   ├─ wait() 다음 줄부터 실행 재개
   ├─ while 조건 재확인 → hasData == true (통과!)
   ├─ data 소비
   ├─ notifyAll() 호출 (대기 중인 스레드 없음)
   └─ synchronized 블록 종료
```
예시처럼 모니터는 내부의 조건식 충족 여부에 따라 임계구역의 코드 실행 또는 대기를 하게 된다.

