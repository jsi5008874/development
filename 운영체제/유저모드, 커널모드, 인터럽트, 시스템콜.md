  

User mode : 내가 개발하는 프로그램은 일반적으로 유저모드에서 실행

Kernel mode : 운영체제의 핵심, 시스템의 전반을 관리/감독하는 역할

하드웨어와 관련된 작업을 직접 수행

커널모드가 존재하는 이유 : 시스템을 보호하기 위해

  

  

user mode > kernel mode

1. 프로그램 실행 중에 인터럽트(interrupt)가 발생하거나 시스템 콜을 호출하게 되면

커널 모드로 전환

  

1. 프로그램의 현재 CPU 상태를 저장함

  

1. 커널이 인터럽트나 시스템 콜을 직접 처리 즉, CPU에서 커널 코드가 실행됨

처리가 완료되면 중단됐던 프로그램의 CPU 상태를 복원

  

kernel mode > user mode

1. 다시 통제권을 프로그램에게 반환
2. user mode에서 중단됐던 프로그램이 다시 실행

  

### Interrupt : 시스템에서 발생 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘

  

인터럽트의 종류

1. 전원(power)에 문제가 생겼을 때
2. I/O 작업이 완료됐을 때
3. 시간이 다 됐을 때(timer 관련)
4. 0으로 나눴을 때
5. 잘못된 메모리 공간에 접근을 시도할 때

등등 수많은 종류가 있음

  

인터럽트가 발생하면 CPU에서는 즉각적으로 인터럽트 처리를 위해 커널 코드를 커널모드에서 실행

  

### 시스템 콜 : 프로그램이 OS 커널이 제공하는 서비스를 이용하고 싶을 때 시스템 콜을 통해 실행

  

시스템 콜의 종류

1. 프로세스/스레드 관련
2. 파일 I/O 관련
3. 소켓 관련
4. 장치(device) 관련
5. 프로세스 통신 관련

등등 많은 종류가 있음

  

시스템 콜이 발생하면 해당 커널 코드가 커널 모드에서 실행

  

### 시스템 콜 & 인터럽트 예제 : 파일 read

![[OS_프로세스_상태변화.png]]

t1, t2 두개의 스레드가 있다고 가정

  

1. t1은 running 상태이고 t2는 ready상태이다.
2. user mode에서 실행중인 t1에 파일을 읽는 read 시스템 콜이 발생해서 kernel mode로 변경
3. kernel은 t1 cpu 상태를 저장하고 파일 읽을 준비를 한다. t1을 waiting 상태로 변환하고 t2를 running으로 변경하면서 유저모드 입
4. t2가 running 중 t1이 파읽 read가 끝났다는 interrupt 발생, 다시 kernel mode로 진입하면서 t2 cpu상태 저장, t1을 ready로 변경, t2 cpu 상태 복원 및 user mode에서 t2 running
5. t2의 time slice가 모두 지나서 실행을 끝내야한다는 interrupt 발생, kernel mode 진입, t2 cpu 상태저장, t2 ready로 변경, t1 running 및 cpu 상태복원

이런식으로 프로세스/스레드가 실행할 때 interrupt와 시스템 콜이 발생하면서 상태를 변화시킨다.

  

### 프로그래밍 언어와 시스템 콜

하드웨어 혹은 시스템 관련 기능은 어떤 프로그램이라도 반드시 시스템 콜을 통해서만 사용 가능

하지만 보통 우리는 개발할 때 직접 OS 시스템 콜을 사용한 적이 없다.

I/O관련, 프로세스/스레드 관련, 네트워크 통신 관련 시스템 콜을 사용한 적이 없다.

  

우리가 사용하는 프로그래밍 언어들이 시스템 콜을 포장(wrapping)하여 간접적으로 사용할 수 있도록 제공하기 때문