## 전제조건
WebSocketConfig를 통해 미리 웹소켓에 대한 설정이 이루어져 있어야 한다.

```java
@Configuration  
@EnableWebSocket  
@RequiredArgsConstructor  
public class WebSocketConfig implements WebSocketConfigurer {  
  
    private final ChatWebSocketHandler chatWebSocketHandler;  
  
    @Value("${websocket.allowed-origins}")  
    private String[] allowedOrigins;  
  
    @Override  
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {  
        registry  
                .addHandler(chatWebSocketHandler, "/chat")  
                .setAllowedOrigins(allowedOrigins);  
    }  
}
```
이는 Spring 어플리케이션 시작 시 자동으로 등록되며 @EnableWebSocket을 감지하여 WebSocketHandlerRegistry를 초기화하고
/chat 경로에  대한 WebSocket 리스너를 등록한다.
```
@EnableWebSocket
- Spring에서 WebSocket 기능을 활성화하는 스위치 같은 역할
- Spring이 WebSocket 관련 인프라를 자동으로 구성
- WebSocketConfigurer를 구현한 설정 클래스를 찾아서 실행
>> 쉽게 말하면 어플리케이션에서 웹소켓을 사용할 것이라고 스프링에게 알려주는 역할

WebSocketHandlerRegistry
- WebSocket 엔드포인트를 등록하는 등록소
- 어떤 핸들러가 요청을 처리할지 연결
```
즉 스프링 시작 후 /chat으로부터 오는 요청을 받아 웹소켓 처리를 준비 하고 있는 것


## 프론트 연결 요청
```React
const ws = new WebSocket(wsUrl);
```
프론트에서 해당 코드를 통해 WebSocket 연결을 요청



## 웹소켓 연결 요청 시 스프링 내부 동작

### 1. HTTP 업그레이드 요청
```
GET /chat HTTP/1.1 
Host: localhost:8080 
Upgrade: websocket 
Connection: Upgrade
```
프론트에서 HTTP > webSocket으로 업그레이드 요청

### 2. 경로 매칭
WebSocketHandlerRegistry가 /chat 경로를 매칭하여 핸들러를 찾는다.
anonichat 프로젝트에서는 직접 설정한 chatWebSocketHandler이다.
### 3. WebSocket Handshake 처리
Spring의 WebSocketHttpRequestHandler가 실행되어 웹소켓 연결을 한다.
```java
public class WebSocketHttpRequestHandler { 
public void handleRequest(HttpServletRequest request, HttpServletResponse response) { 
// 1. HTTP를 WebSocket으로 Upgrade 
// 2. WebSocketSession 객체 생성 
WebSocketSession sessionA = createWebSocketSession(request); 
// 3. Handler에게 연결 성공 알림 
chatWebSocketHandler.afterConnectionEstablished(sessionA); } }
```
여기서 WebSocket 업그레이드, WebSocketSession 생성을 한다.
```
WebSocketSession
로그인 등 사용자의 인증 정보를 유지하기 위한 수단인 Session과 다른 개념
WebSocket 통신에서 사용자를 확인하기 위한 것으로 Session과 별도로 저장된다.
```

### 4. WebSocketSession을 활용한 사용자 웹소켓 매칭
```java
[클라이언트 A 프론트 엔드] 
socketA.send(JSON.stringify({ type: 'JOIN', roomId: 'room-123' })); 
↓ 
[Spring] 
handleTextMessage(sessionA, message) 호출
↓ 
handleJoin(sessionA, message)
↓ 
sessionManager.addSession("room-123", sessionA) 
↓ 
[메모리 상태] 
roomSessions = { "room-123": { "session-A-001": sessionA } }
```
현재 로직 상 프론트에서 보낸 type이 "JOIN"이면(매칭 > 웹소켓 등록완료 후 채팅방 입장 시점) WebSocketSessionManager를 통해
roomID별로 WebSocketSession을 등록한다.

```java
[클라이언트 B 프론트 엔드]
 socketB.send(JSON.stringify({ type: 'JOIN', roomId: 'room-123' })); 
 ↓ 
[Spring] 
 handleTextMessage(sessionB, message) 호출 
 ↓ 
 handleJoin(sessionB, message) 
 ↓ 
 sessionManager.addSession("room-123", sessionB) 
 ↓ 
 [메모리 상태] 
 roomSessions = { "room-123": { "session-A-001": sessionA, "session-B-002": sessionB } }
```

이렇게 같은 채팅룸 번호를 가진 사용자들 끼리 동일한 roomSession에 속하여 웹소켓을 연결한다.

헷갈리지 말아야할 부분은 클라이언트끼리 직접 소켓 통신이 되는 구조가 아니고 서버가 중계하는 구조이다.
```
클라이언트 A ←──WebSocket──→ 서버 ←──WebSocket──→ 클라이언트 B
                           ↓
                    roomSession으로 그룹 관리
```