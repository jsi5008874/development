---
~
---
## 1. 세션 관리
### 세션 관련 설정
#### SessionConfig
```java
@Configuration  
public class SessionConfig {  
    @Value("${session.cookie.secure}")  
    private boolean secure;  
  
    @Value("${session.cookie.same-site}")  
    private String sameSite;  
  
    @Bean  
    public CookieSerializer cookieSerializer() {  
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();  
        serializer.setCookieName("JSESSIONID");  
        serializer.setUseHttpOnlyCookie(true);  
        serializer.setUseSecureCookie(secure);  
        serializer.setSameSite(sameSite);  
        serializer.setCookiePath("/");  
        return serializer;  
    }  
}
```
세션, 쿠키 설정
#### RedisConfig
```java
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 7200)
```
Redis를 이용한 세션 저장소 설정
해당 어노테이션이 자동으로 필터 등록 > 이 필터가 모든 HTTP 요청을 가로채서 세션을 처리

### 세션 발급 흐름
1. 클라이언트 첫 요청
	클라이언트(브라우저) > HTTP 요청(세션 없는 상태) > spring boot 서버
	anonichat은 메인 페이지 접속이 아닌 매칭 요청이 백엔드 서버에게 넘어오는 첫 요청이다.
	실제 서비스를 사용하는 시점부터 세션을 발급하여 불필요한 세션을 발급하지 않도록 하기 위함이다.
	**따라서 실제로 세션이 발급되는 순간은 메인 페이지 접속이 아닌 매칭 요청 시점이다.**

2. Spring Session Filter 동작
```
SessionRepositoryFilter > 요청에 세션 쿠키가 있는지 확인 > 없으면 새 세션 생성 필요 요청
> @EnableRedisHttpSession 어노테이션이 요청을 가로채서 처리

SessionRepositoryFilter 필터는 스프링이 자동으로 등록하는 필터 체인으로 개발자가 따로 설정하는 것은 없다.
```

3. Redis Session 생성
```
// Spring Session 내부 동작 (자동)

 RedisIndexedSessionRepository.createSession() 호출
   ↓
 새로운 RedisSession 객체 생성
   - Session ID 생성 (UUID 기반)
   - 생성 시간 기록
   - 만료 시간 설정 (7200초)
   ↓
 아직 Redis에 저장하지 않음 (메모리에만 존재)
```

4. Redis Session 저장
```java
public QueueResponse enqueueUser(QueueRequest request, String ip, HttpSession session) {  
    String category = request.getCategory();  
    String queueKey = "matching_queue:" + category;  
  
    session.setAttribute("category", request.getCategory());
```
session.setAttribute() 부분에서 redis에 세션을 저장

5. 응답에 session 정보 추가
	이후 프론트에 응답을 보낼 때 쿠키에 session 정보를 추가해서 응답을 보낸다.

### 최종 정리
```
프론트 > 백엔드 첫 요청(매칭 요청 시)
↓
SprigSessionFilter 동작
요청에 session 정보가 있는지 확인
↓
없다면 @EnableRedisHttpSession을 통해 Redis Session 생성
↓
controller 진입
@PostMapping("/queue")  
public ResponseEntity<QueueResponse> matchingStart(@RequestBody QueueRequest request, HttpServletRequest httpRequest, HttpSession session)

여기서 session 파라미터가 직전에 생성한 Redis Session
↓
Service 진입
public QueueResponse enqueueUser(QueueRequest request, String ip, HttpSession session) {  
    String category = request.getCategory();  
    String queueKey = "matching_queue:" + category;  
  
    session.setAttribute("category", request.getCategory());

session.setAttribute()에서 해당 세션을 Redis에 저장
↓
비즈니스 로직 처리 후 응답 시
응답 헤더에 JSESSION 데이터를 포함하여 응답
↓
이후 클라이언트 - 서버 통신은 해당 SESSION 정보를 통해 진행
```
## 2. 매칭

### 매칭 로직
```
프론트 매칭 버튼 클릭
↓
컨트롤러 동작(/matching/queue)
↓
서비스 동작
	1. 레디스 큐 삽입(right push)
	2. 큐 사이즈 확인(1이상인 경우 매칭 로직 실행)
	3. 결과 응답(매칭 대기열 등록 성공 여부)
↓
매칭 알림 전송
```

### 매칭 플로우 동작 방식
#### 컨트롤러 동작
```java
@PostMapping("/matching/queue")
public ResponseEntity<QueueResponse> matchingStart(
    @RequestBody QueueRequest request,
    HttpServletRequest httpRequest,
    HttpSession session  // ← Spring이 자동 생성
) {
    // 1. HTTP 세션 생성
    String sessionId = session.getId();
    
    // 2. MatchingService 호출
    QueueResponse response = matchingService.enqueueUser(
        request, 
        httpRequest.getRemoteAddr(), 
        session
    );
    
    return ResponseEntity.ok(response);
}
```

#### 레디스 대기열 등록
``` java
// MatchingServiceImpl.java
@Override  
public QueueResponse enqueueUser(QueueRequest request, String ip, HttpSession session) {  
    String category = request.getCategory();  
    String queueKey = "matching_queue:" + category;  
    String sessionId = session.getId();  
  
    try {  
        ensureQueueExists(queueKey);  
  
        if(Boolean.TRUE.equals(redisTemplate.hasKey(sessionId))){  
            throw new IllegalStateException("이미 매칭 대기중입니다.");  
        }  
  
        Long queueSize = queueRedisTemplate.opsForList().size(queueKey);  
        queueRedisTemplate.opsForList().rightPush(queueKey, sessionId);  
  
        if (queueSize != null && queueSize >= 1) {  
            processMatchingAsync(category, queueKey);  
        }  
  
        return QueueResponse.builder()  
                .sessionId(sessionId)  
                .queueSize(queueSize)  
                .category(category)  
                .message("매칭 대기열에 등록되었습니다.")  
                .status("SUCCESS")  
                .build();  
  
    } catch (Exception e) {  
        return QueueResponse.builder()  
                .message("매칭 대기열 등록 실패")  
                .status("FAIL")  
                .build();  
    }  
}
```
1. 매칭 요청한 사용자 sessionID를 레디스 큐에 rightPush로 등록
2. 매칭 큐의 사이즈가 1 이상이면 매칭 로직 실행(rightPush 실행 전에 큐 사이즈를 조회하고 queueSize 변수에 할당하기 때문에 크기 1이 기준점이 된다.)
3. 매칭 결과를 반환

현재 매칭 로직은 이벤트 처리를 통해(Redis pub/sub 활용) 매칭여부를 확인하여 사용자에게 알려주는 방식이다.
따라서 매칭큐에 삽입되는 HttpSessionID를 WebSocketSession과 매핑하여 관리하기 때문에 WebSocketSession을 어떻게 관리하는지 정확히 알아야한다.
(Redis에는 WebSocketSession 형식으로 삽입이 불가능해서 HttpSessionID와 WebSocketSession을 매핑해서 관리)
**Spring Boot WebSocket 처리**
```java
// 1. HttpSessionHandshakeInterceptor
@Override
public boolean beforeHandshake(
    ServerHttpRequest request,
    ServerHttpResponse response,
    WebSocketHandler wsHandler,
    Map<String, Object> attributes
) {
    ServletServerHttpRequest servletRequest = 
        (ServletServerHttpRequest) request;
    
    // 쿠키에서 HTTP 세션 가져오기
    HttpSession httpSession = 
        servletRequest.getServletRequest().getSession(false);
    
    if (httpSession != null) {
        // WebSocket attributes에 HTTP 세션 ID 저장
        attributes.put("HTTP_SESSION_ID", httpSession.getId());
        log.info("HTTP 세션 전달 - sessionId: {}", httpSession.getId());
    } else {
        log.warn("HTTP 세션이 없습니다");
    }
    
    return true;
}

attributes.put()이 WebSocket에 HTTP 세션 ID를 저장하는데
이는 스프링 내부적으로 자동 동작하는 과정이며 webSocket에 attributes Map을 넣어준다.
ex)
WebSocketSession session = new WebSocketSession(); // attributes Map의 내용을 WebSocketSession에 복사
session.getAttributes().putAll(attributes);
```

```java
// ChatWebSocketHandler.java
@Override
public void afterConnectionEstablished(WebSocketSession session) { //위의 자동 동작하는 과정에서 생긴 WebSocketSession
    // 1. WebSocket 세션 ID
    String wsSessionId = session.getId();
    
    // 2. HTTP 세션 ID 가져오기
    String httpSessionId = (String) session.getAttributes()
        .get("HTTP_SESSION_ID"); // "0f7ee760-113a-..."
    
    if (httpSessionId != null) {
        // 3. 매칭 세션 맵에 저장
        sessionManager.addMatchingSession(httpSessionId, session);
        // matchingSessions.put(httpSessionId, WebSocketSession)
        
        log.info("✅ 매칭 세션 등록!");
        log.info("   HTTP 세션 ID: {}", httpSessionId);
        log.info("   WebSocket 세션 ID: {}", wsSessionId);
    }
}

// 메모리 상태 
matchingSessions = {
 "0f7ee760-113a-..." → WebSocketSession@bbf8b020, 
 "67fdffb2-b51f-..." → WebSocketSession@a1b2c3d4 
 }
 이런식으로 matchingSession 객체에 HttpSessionId와 WebSocketSession이 매핑되어 관리
```

#### 매칭 처리
```java
// MatchingServiceImpl.java
private void processMatchingAsync(String category, String queueKey) {
    CompletableFuture.runAsync(() -> {
        // 1. Redis List에서 2명 꺼내기 (FIFO)
        String user1Session = queueRedisTemplate.opsForList()
            .leftPop(queueKey); // "67fdffb2-b51f-..."
        String user2Session = queueRedisTemplate.opsForList()
            .leftPop(queueKey); // "0f7ee760-113a-..."
        
        if (user1Session != null && user2Session != null) {
            log.info("매칭 처리 시작: user1={}, user2={}", 
                user1Session, user2Session);
            
            // 2. 채팅방 생성
            String roomId = chatroomService.createChatRoom(
                user1Session, 
                user2Session, 
                category
            );
            
            // 3. Redis에 매칭 정보 저장 (백업용)
            redisTemplate.opsForValue().set(
                "matched:room:" + user1Session, 
                roomId, 
                60, 
                TimeUnit.SECONDS
            );
            redisTemplate.opsForValue().set(
                "matched:room:" + user2Session, 
                roomId, 
                60, 
                TimeUnit.SECONDS
            );
            
            // 4. Redis Pub/Sub 이벤트 발행
            matchingPublisher.publishMatchingSuccess(
                user1Session, 
                user2Session, 
                roomId, 
                category
            );
        }
    });
}
```
1. 매칭 큐에서 leftPop으로 2명 꺼내기
2. 채팅방 생성(roomId 생성)
3. Redis pub/sub 이벤트를 발행(매칭 이벤트)
```java
// RedisMatchingPublisher.java
public void publishMatchingSuccess(
    String user1SessionId, 
    String user2SessionId,
    String roomId, 
    String category
) {
    MatchingEvent event = MatchingEvent.builder()
        .type("MATCHING_SUCCESS")
        .user1SessionId(user1SessionId)
        .user2SessionId(user2SessionId)
        .roomId(roomId)
        .category(category)
        .timestamp(System.currentTimeMillis())
        .build();
    
    // Redis Pub/Sub 채널에 발행
    redisTemplate.convertAndSend("matching:events", event);
}

matching:events 채널에 builder로 생성한 MatchingEvent를 발행
```

#### 매칭 알림 전송
```java
// RedisMatchingSubscriber.java
@Override
public void onMessage(Message message, byte[] pattern) {
    // 1. JSON 파싱
    String messageBody = new String(message.getBody());
    MatchingEvent event = objectMapper.readValue(
        messageBody, 
        MatchingEvent.class
    );
    
    log.info(" 매칭 이벤트 수신");
    log.info("   type: {}", event.getType());
    log.info("   roomId: {}", event.getRoomId());
    log.info("   user1: {}", event.getUser1SessionId());
    log.info("   user2: {}", event.getUser2SessionId());
    
    // 2. 매칭 성공 처리
    if ("MATCHING_SUCCESS".equals(event.getType())) {
        handleMatchingSuccess(event);
    }
}

private void handleMatchingSuccess(MatchingEvent event) {
    // 3. 각 사용자에게 WebSocket 메시지 전송
    webSocketHandler.sendMatchingNotification(
        event.getUser1SessionId(),
        event.getRoomId()
    );
    
    webSocketHandler.sendMatchingNotification(
        event.getUser2SessionId(),
        event.getRoomId()
    );
}

onMessage()는 Redis의 특정 채널(토픽)에 메시지가 발행되면 자동으로 실행되는 콜백 메서드
따라서 matching:events 채널에 메시지가 발행이되면 RedisMatchingSubscriber 클래스의 onMessage() 메서드가 실행된다.

// ChatWebSocketHandler.java
public void sendMatchingNotification(String httpSessionId, String roomId) {
    // 1. matchingSessions에서 WebSocket 세션 찾기
    WebSocketSession session = 
        sessionManager.getMatchingSession(httpSessionId);
    
    if (session != null && session.isOpen()) {
        // 2. 메시지 생성
        ChatMessage notification = ChatMessage.builder()
            .type(ChatMessage.MessageType.MATCHING_SUCCESS)
            .roomId(roomId)
            .content("매칭이 완료되었습니다!")
            .timestamp(LocalDateTime.now())
            .build();
        
        // 3. JSON 직렬화
        String json = objectMapper.writeValueAsString(notification);
        
        // 4. WebSocket으로 전송
        session.sendMessage(new TextMessage(json));
        
        log.info("✅ 매칭 알림 전송 성공 - httpSessionId: {}, roomId: {}", 
            httpSessionId, roomId);
    }
}

onMessage() 메서드를 통해 전달받은 데이터를 활용해 notifacation 객체를 생성하고
이를 웹소켓으로 프론트에 전송하는 역할을 한다.
```

### 최종 정리
```
클라이언트
   ↓ ws://anonichat.world/queue 연결
HttpSessionHandshakeInterceptor
   ↓ HTTP 세션 ID 추출 → attributes에 저장
ChatWebSocketHandler.afterConnectionEstablished()
   ↓ attributes에서 HTTP 세션 ID 가져오기
matchingSessions Map에 저장
   { "HTTP세션ID123" → WebSocketSession객체 }
   ↓
컨트롤러
   ↓
MatchingService.enqueueUser()
Redis 큐 상태:
matching_queue:category = []

→ 사용자 A 등록
matching_queue:casual = ["세션ID_A"]
(큐 사이즈 0 → 매칭 대기)

→ 사용자 B 등록
matching_queue:casual = ["세션ID_A", "세션ID_B"]
(큐 사이즈 1 이상 → 매칭 시작)
   ↓
매칭 처리:
   ↓ leftPop() 2번 실행
user1 = "세션ID_A"
user2 = "세션ID_B"
   ↓ 채팅방 생성
roomId = "room_12345"
   ↓ Redis Pub/Sub 이벤트 발행
RedisMatchingPublisher
   ↓
matching:events 채널에 발행
{
  "type": "MATCHING_SUCCESS",
  "user1SessionId": "세션ID_A",
  "user2SessionId": "세션ID_B",
  "roomId": "room_12345"
}
   ↓
RedisMatchingSubscriber.onMessage()
   ↓ 이벤트 수신 
   ↓ handleMatchingSuccess()
   ↓
ChatWebSocketHandler.sendMatchingNotification()
   ↓ matchingSessions에서 WebSocket 세션 찾기
   ↓
matchingSessions.get("세션ID_A") → WebSocketSession 객체
matchingSessions.get("세션ID_B") → WebSocketSession 객체
   ↓
session.sendMessage() 실행
   ↓
클라이언트 A, B에게 알림 전송
{
  "type": "MATCHING_SUCCESS",
  "roomId": "room_12345",
  "content": "매칭이 완료되었습니다!"
}
```
## 3. 채팅방 관리
