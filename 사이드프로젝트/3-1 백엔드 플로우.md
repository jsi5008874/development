---
~
---
## 1. 세션 관리
### 세션 관련 설정
#### SessionConfig
```java
@Configuration  
public class SessionConfig {  
    @Value("${session.cookie.secure}")  
    private boolean secure;  
  
    @Value("${session.cookie.same-site}")  
    private String sameSite;  
  
    @Bean  
    public CookieSerializer cookieSerializer() {  
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();  
        serializer.setCookieName("JSESSIONID");  
        serializer.setUseHttpOnlyCookie(true);  
        serializer.setUseSecureCookie(secure);  
        serializer.setSameSite(sameSite);  
        serializer.setCookiePath("/");  
        return serializer;  
    }  
}
```
세션, 쿠키 설정
#### RedisConfig
```java
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 7200)
```
Redis를 이용한 세션 저장소 설정
해당 어노테이션이 자동으로 필터 등록 > 이 필터가 모든 HTTP 요청을 가로채서 세션을 처리

### 세션 발급 흐름
1. 클라이언트 첫 요청
	클라이언트(브라우저) > HTTP 요청(세션 없는 상태) > spring boot 서버
	anonichat은 메인 페이지 접속이 아닌 매칭 요청이 백엔드 서버에게 넘어오는 첫 요청이다.
	실제 서비스를 사용하는 시점부터 세션을 발급하여 불필요한 세션을 발급하지 않도록 하기 위함이다.
	**따라서 실제로 세션이 발급되는 순간은 메인 페이지 접속이 아닌 매칭 요청 시점이다.**

2. Spring Session Filter 동작
```
SessionRepositoryFilter > 요청에 세션 쿠키가 있는지 확인 > 없으면 새 세션 생성 필요 요청
> @EnableRedisHttpSession 어노테이션이 요청을 가로채서 처리

SessionRepositoryFilter 필터는 스프링이 자동으로 등록하는 필터 체인으로 개발자가 따로 설정하는 것은 없다.
```

3. Redis Session 생성
```
// Spring Session 내부 동작 (자동)

 RedisIndexedSessionRepository.createSession() 호출
   ↓
 새로운 RedisSession 객체 생성
   - Session ID 생성 (UUID 기반)
   - 생성 시간 기록
   - 만료 시간 설정 (7200초)
   ↓
 아직 Redis에 저장하지 않음 (메모리에만 존재)
```

4. Redis Session 저장
```java
public QueueResponse enqueueUser(QueueRequest request, String ip, HttpSession session) {  
    String category = request.getCategory();  
    String queueKey = "matching_queue:" + category;  
  
    session.setAttribute("category", request.getCategory());
```
session.setAttribute() 부분에서 redis에 세션을 저장

5. 응답에 session 정보 추가
	이후 프론트에 응답을 보낼 때 쿠키에 session 정보를 추가해서 응답을 보낸다.

### 최종 정리
```
프론트 > 백엔드 첫 요청(매칭 요청 시)
↓
SprigSessionFilter 동작
요청에 session 정보가 있는지 확인
↓
없다면 @EnableRedisHttpSession을 통해 Redis Session 생성
↓
controller 진입
@PostMapping("/queue")  
public ResponseEntity<QueueResponse> matchingStart(@RequestBody QueueRequest request, HttpServletRequest httpRequest, HttpSession session)

여기서 session 파라미터가 직전에 생성한 Redis Session
↓
Service 진입
public QueueResponse enqueueUser(QueueRequest request, String ip, HttpSession session) {  
    String category = request.getCategory();  
    String queueKey = "matching_queue:" + category;  
  
    session.setAttribute("category", request.getCategory());

session.setAttribute()에서 해당 세션을 Redis에 저장
↓
비즈니스 로직 처리 후 응답 시
응답 헤더에 JSESSION 데이터를 포함하여 응답
↓
이후 클라이언트 - 서버 통신은 해당 SESSION 정보를 통해 진행
```
## 2. 매칭


## 3. 채팅방 관리
