비즈니스 로직이 주인어야 할 메소드 안에 이름도 길고 무시무시하게 생긴 트랜잭션 코드가 더 많은 자리를 차지하고 있어
이상한 부분이 있다.
논리적으로 따져봐도 트랜잭션의 경계는 분명 비즈니스 로직 전후에 설정돼야 하는 것이 분명하니
UserService의 메소드에 두는 것을 거부할 명분이 없다.

## 메소드 분리

![[KakaoTalk_Photo_2025-06-29-21-15-58 002 1.jpeg]]
얼핏 보면 트랜잭션 경계설정 코드와 비즈니스 로직 코드가 얽혀있는 듯 보이지만
실제로는 뚜렷하게 두 가지의 종류가 구분되어 있음을 알 수 있다.
비즈니스 로직을 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있다.

또, 이 코드의 특징은 트랜잭션 경계설정 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다는 점이다.
비즈니스 로직 코드에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을
직접 참조할 필요가 없기 때문이다.
따라서 두 가지 코드는 성격이 다를 뿐 아니라 서로 주고받는 것도 없는 완벽하게 독립적인 코드다.

그렇다면 이 성격이 다른 코드를 두 개의 메소드로 분리할 수 있지 않을까?

![[KakaoTalk_Photo_2025-06-29-21-15-58 001.jpeg]]
레벨 업그레이드를 담당하는 비즈니스 로직 코드만 독립적인 메소드에 담겨 있으니 이해하기도 편하고
수정하기에도 부담이 없다.

## DI를 이용한 클래스의 분리
비즈니스 로직을 담당하는 코드를 분리해서 좋긴 하지만 여전히 트랜잭션을 담당하는 코드가 UserService 안에 있다.
간단하게 트랜잭션 코드를 클래스 밖으로 뽑아내면 된다.

### DI 적용을 이용한 트랜잭션 분리

![[KakaoTalk_Photo_2025-06-29-22-10-39 001.jpeg]]
지금 UserService는 UserServiceTest가 클라이언트가 되어서 사용하고 있다.
실전에서는 다른 클래스나 모듈이 사용하겠지만 현재는 Test에서만 사용중이기 때문이다.
그런데 UserService는 현재 클래스로 되어 있어 다른 코드에서 사용한다면 UserService를 직접 참조하게된다.
**그렇다면 트랜잭션 코드를 밖으로 빼냈을 때 UserService를 사용하는 입장에서는
트랜잭션의 기능이 없는 UserService를 사용하게된다.**
구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점이다.

![[KakaoTalk_Photo_2025-06-29-22-10-40 002.jpeg]]
그래서 인터페이스를 만들고 기존 코드는 UserServuce 인터페이스의 구현 클래스를 만들어 넣는다.
하지만 지금 만들고자 하는 것은 UserService와 트랜잭션 경계설정이 분리된 구조이다.
6-2처럼 한다면 인터페이스로 분리만 했지 실제로 UserService와 트랜잭션 코드가 분리된 것은 아니다.

![[KakaoTalk_Photo_2025-06-29-22-10-40 003.jpeg]]
그래서 6-3 처럼 구조를 만들었다.
UserService를 구현한 또 다른 구현 클래스를 만든다.
단지 트랜잭션의 경계설정을 책임지는 UserServiceTx 클래스를 만든 것이다.
이렇게 만들면 클라이언트 입장에서는 트랜잭션이 적용된 비즈니스 로직 구현이라는 기대하는 동작이 일어난다.

### UserService 인터페이스 도입
먼저 기존의 UserService 클래스를 UserServiceImpl로 변경
그리고 UserService는 인터페이스로 만든다.

```java
public interface UserService{
	void add(User user);
	void upgradeLevels();
}
```


![[KakaoTalk_Photo_2025-06-29-22-18-13 001.jpeg]]
UserServiceImpl은 기존 UserService의 내용 대부분을 유지하면 된다.
단, 트랜잭션과 코드를 분리시키기로 했으니 트랜잭션 관련 코드는 모두 제거한다.

이렇게 수정하고 보니 메일 발송 기능을 추가했던 것을 제외하면 트랜잭션을 고려하지 않고 단순하게 로직만을 구현했던
처음 모습으로 돌아왔다.
### 분리된 트랜잭션 기능
![[KakaoTalk_Photo_2025-06-29-22-18-13 002.jpeg]]
UserServiceTx는 기존적으로 UserService를 구현하게 만든다.
그리고 같은 인터페이스를 구현한 다른 오브젝트에게 고스란히 작업을 위임하게 만들면 된다.

UserServiceTx는 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.
이를 위해 UserService 오브젝트를 DI 받을 수 있도록 만든다.

UserServiceTx에 트랜잭션의 경계설정이라는 부가적인 작업을 부여해보자

![[KakaoTalk_Photo_2025-06-29-22-30-22.jpeg]]
upgradeLeves()는 UserService에서 트랜잭션 처리 메소드와 비즈니스 로직 메소드를 분리했을 때
트랜잭션을 담당한 메소드와 거의 한 메스드가 됐다.
추상화된 트랜잭션 구현 오브젝트를 DI 받을 수 있도록 PlatformTransactionManager 타입의 프로퍼티도 추가됐다.

### 트랜잭션 적용을 위한 DI 설정
클라이언트가 UserService를 사용할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용돼서 트랜잭션 작업을 먼저 진행하고
실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출돼서 비즈니스 로직에 관련된 작업을 수행하도록 만든다.

**Client > UserServiceTx > UserServiceImpl**

기존 UserService 빈이 의존하고 있던 transactionManager는 UserServiceTx의 빈이,
userDao와 mailSender는 UserServiceImpl 빈이 의존하도록 분리한다.

### 트랜잭션 경계설정 코드 분리의 장점
첫 째, 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은
기술적인 내용에는 전혀 신경 쓰지 않아도 된다.

두번 째, 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.
