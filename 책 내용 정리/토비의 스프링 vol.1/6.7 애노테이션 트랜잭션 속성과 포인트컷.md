포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄적으로 적용하는 방식은 복잡한 트랜잭션 속성이 요구되지 않는 한 대부분의 상황에 잘 들어맞는다. 그런데 가끔은 클래스나 메소드에 따라 제각각 속성이 다른 세밀하게 튜닝된 트랜잭션 속성을 적용해야 하는 경우도 있다. 이런 경우라면 메소드 이름 패턴을 이용해서 일괄적으로 트랜잭션 속성을 부여한 방식은 적합하지 않다.  기본 속성과 다른 경우가 있을 때마다 일일이 포인트컷과 어드바이스를 새로 추가해줘야 하기 때문이다.

이런 세밀한 트랜잭션 속성의 제어가 필요한 경우를 위해 스프링이 제공하는 다른 방법이 있다.
직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정하는 방법이다.

### 트랜잭션 애노테이션

**@Transactional**
![[KakaoTalk_Photo_2025-09-05-13-36-05 001.jpeg]]
![[KakaoTalk_Photo_2025-09-05-13-36-05 002.jpeg]]
@Transactional 애노테이션의 타깃은 메소드와 타입이다. 따라서 메소드, 클래스, 인터페이스에 사용할 수 있다. @Transactional 애노테이션을 트랜잭션 속성정보로 사용하도록 지정하면 스프링은 @Transactional이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식한다. 이때 사용되는 포인트컷은 TransactionAttributeSourcePointcut이다.

TransactionAttributeSourcePointcut은 스스로 표현식과 같은 선정기준을 갖고 있진 않다. 대신 @Transactional이 타입 레벨이든 메소드 레벨이든 상관없이 부여된 빈 오브젝트를 모두 찾아서 포인트컷의 선정 결과로 돌려준다.
@Transactional은 기본적으로 트랜잭션 속성을 정의하는 것이지만 동시에 포인트컷의 자동등록에도 사용된다.

**트랜잭션 속성을 이용하는 포인트컷**
![[KakaoTalk_Photo_2025-09-05-13-43-56 001.jpeg]]
@Transactional 애노테이션을 사용했을 때 어드바이저의 동작방식을 보여준다.
TransactionInterceptor는 메소드 이름 패턴을 통해 부여되는 일관적인 트랜잭션 속성정보 대신 @Transactional 애노테이션의 엘리먼트에서 트랜잭션 속성을 가져오는 AnnotationTransactionAttributeSource를 사용한다.
@Transactional은 메소드마다 다르게 설정할 수도 있으므로 매우 유연한 트랜잭션 속성 설정이 가능해진다.
동시에 포인트컷도 @Transactional을 통한 트랜잭션 속성정보를 참조하도록 만든다.

이 방식을 이용하면 포인트컷과 트랜잭션 속성을 애노테이션 하나로 지정할 수 있다.
트랜잭션 속성은 타입 레벨에 일괄적으로 부여할 수도 있지만 메소드 단위로 세분화해서 트랜잭션 속성을 다르게 지정할 수도 있기 때문에 매우 세밀한 트랜잭션 속성 제어가 가능해진다.

하지만 이렇게 하면 유연한 속성 제어는 가능하겠지만 코드가 지저분해지고 동일한 속성 정보를 가진 애노테이션을 반복적으로 메소드마다 부여해주는 바람직하지 못한 결과를 가져올 수 있다.

**대체 정책**
그래서 스프링은 @Transactional을 적용할 때 4단계의 대체(fallback) 정책을 이용하게 해준다.
메소드의 속성을 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입의 순서에 따라서 @Transactional이 적용됐는지 차례로 확인하고 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.

가장 먼저 타깃 메소드에 @Transactional이 있는지 확인한다. @Transactional이 부여되어 있다면 이를 속성으로 사용한다.
만약 없으면 다음 대체 후보인 타깃 클래스에 부여된 @Transactional 애노테이션을 찾는다. 타깃 클래스의 메소드 레벨에는 없었지만 클래스 레벨에 @Transactional이 존재한다면 이를 메소드의 트랜잭션 속성으로 사용한다.
이런 식으로 메소드가 선언된 타입까지 단계적으로 확인해서 @Transactional이 발견되면 적용하고 끝까지 발견되지 않으면 해당 메소드는 트랜잭션 적용 대상이 아니라고 판단한다.

![[KakaoTalk_Photo_2025-09-05-13-43-56 002.jpeg]]
사진과 같은 구조에서는 @Transactional을 부여할 수 있는 위치는 총 6개이다.(1~6)

스프링은 트랜잭션 기능이 부여될 위치인 타깃 오브젝트의 메소드부터 시작해서 @Transactional이 존재하는지 확인한다.
따라서 5, 6이 @Transactional이 위치할 수 있는 첫 번째 후보다. 여기서 애노테이션이 발견되면 바로 애노테이션의 속성을 가져다 해당 메소드의 트랜잭션 속성으로 사용한다.

메소드에서 발견하지 못했다면 다음은 타깃 클래스인 4에 @Transactional이 존재하는지 확인한다. 이를 통해서 @Transactional이 타입 레벨, 즉 클래스에 부여되면 해당 클래스의 모든 메소드의 공통적으로 적용되는 속성이 될 수 있다.
특정 메소드만 공통 속성을 따르지 않는다면 해당 메소드에만 추가로 @Transactional을 부여하면 된다. 대체 정책에서 지정한 순서에 따라 항상 메소드에 부여된 @Transactional이 가장 우선이기 때문이다.

타깃 클래스에서도 @Transactional을 발견하지 못하면 스프링은 메소드가 선언된 인터페이스로 넘어간다.
인터페이스에서도 메소드를 먼저 확인한다.(2, 3번)
여기에도 없다면 마지막 단계인 인터페이스 타입 1의 위치에 애노테이션을 확인한다.

@Transactional을 사용하면 대체 정책을 잘 활용해서 애노테이션 자체는 최소한으로 사용하면서도 세밀한 제어가 가능하다.

**트랜잭션 애노테이션 사용을 위한 설정**
@Transactional을 이용한 트랜잭션 속성을 사용하는 데 필요한 설정은 매우 간단하다.
스프링이 이 방법을 위한 모든 설정을 다음 태그 하나에 담아뒀기 때문이다. 이 태그 하나로 트랜잭션 애노테이션을 이용하는 데 필요한 어드바이저, 어드바이스, 포인트컷, 애노테이션을 이용하는 트랜잭션 속성정보가 등록된다.

```xml
<tx:annotation-driven />
```

### 트랜잭션 애노테이션 적용
@Transactional을 UserService에 적용해보자.

아직 세밀한 트랜잭션 속성 설정이 필요하지 않지만 @Transactional을 이용하면 직관적이고 간단해서 사용하는 경우도 많다.
단순하게 트랜잭션이 필요한 타입 또는 메소드에 직접 애노테이션을 부여하는 것이 훨씬 편리하고 코드를 이해하기도 좋다.

다만 트랜잭션 적용 대상을 손쉽게 파악할 수 없고 사용 정책을 잘 만들어두지 않으면 무분별하게 사용되거나 자칫 빼먹을 위험도 있다.
따라서 @Transactional을 사용할 때는 실수하지 않도록 주의하고 별도의 코드 리뷰를 거칠 필요가 있다.

tx 스키마의 <tx:atrributes> 태그를 이용해 설정했던 트랜잭션 속성을 그대로 애노테이션으로 바꿔보자.
![[KakaoTalk_Photo_2025-09-05-14-30-10 001.jpeg]]
애노테이션을 이용할 때는 이 두 가지 속성 중에서 많이 사용되는 한 가지를 타입 레벨에 공통 속성으로 지정해주고, 나머지 속성은 개별 메소드에 적용해야 한다. 메소드 레벨의 속성은 메소드마다 반복돼야 하므로 속성의 종류가 두 가지 이상이고 적용 대상 메소드의 비율이 비슷하다면 메소드에 많은 @Transactional 애노테이션이 반복될 수 있다.

![[KakaoTalk_Photo_2025-09-05-14-30-11 002.jpeg]]
@Transactional 애노테이션은 UserServiceImpl 클래스 대신 UserService 인터페이스에 적용하겠다.
그래야 UserServiceImpl과 TestUserService 양쪽에 트랜잭션이 적용될 수 있기 때문이다.

UserService에는 get으로 시작하지 않는 메소드가 더 많으므로 인터페이스 레벨에 디폴트 속성을 부여해주고 읽기 전용 속성을 지정할 get으로 시작하는 메소드에는 읽기전용 트랜잭션 속성을 반복해서 지정해야 한다.

애노테이션을 이용한 트랜잭션 속성 지정은 tx 스키마를 사용할 때와 마찬가지로 IDE 자동완성 기능을 사용할 수 있고 잘못 지정한 경우 컴파일 에러 발생으로 손쉽게 확인할 수 있다는 장점이 있다.