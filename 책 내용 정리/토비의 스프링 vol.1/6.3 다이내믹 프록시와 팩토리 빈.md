
### 프록시와 프록시 패턴, 데코레이션 패턴
트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리해낼 때 적용했던 기법을 다시 검토해보자

트랜잭션 기능에는 추상화 작업을 통해 이미 전략 패턴이 적용되어 있다.
하지만 전략 패턴으로는 트랜잭션 기능의 구현 내용을 분리했을 뿐 트랜잭션을 적용한다는 사실은 코드에 그대로 남아 있다.
구체적인 코드는 제거했을지라도 위임을 통해 기능을 사용하는 코드는 핵심 코드와 함께 남아 있다.![[KakaoTalk_Photo_2025-07-03-21-35-42.jpeg]]

트랜잭션이라는 기능은 사용자 관리 비즈니스 로직과는 성격이 다르기 때문에 아예 적용 사실 자체를 밖으로 분리할 수 있다.

![[KakaoTalk_Photo_2025-07-03-21-39-36 001.jpeg]]
이 방법을 이용해 UserServiceTx를 만들었고 userServiceImpl에는 트랜잭션 관련 코드가 하나도 남지 않게 됐다.

이렇게 분리된 부가기능 클래스는 중요한 특징이 있다.
부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다.
핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다. 따라서 부가기능이 핵심기능을 사용하는 구조가 된다.

문제는 이렇게 구성했더라도 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다.
그래서 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만든다.

부가기능 자신도 핵심기능과 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야한다.
그러면 클라이언트는 인터페이스만 보고 사용을 하기 때문에 자신은 핵심기능을 가진 클래스를 사용할 것으로 기대하지만
실제로는 부가기능을 통해 핵심기능을 이용하게 되는 것이다.
![[KakaoTalk_Photo_2025-07-03-21-39-36 002.jpeg]]

부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다.
비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바로 그런 경우이다.

이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 대신 받아주는
대리자, 대리인 역할을 한다고 해서 프록시라고 부른다.
그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.

![[KakaoTalk_Photo_2025-07-03-21-39-36 003.jpeg]]
프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.

프록시는 사용 목적에 따라 두 가지로 구분할 수 있다.
1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해
2. 타깃에 부가적인 기능을 부여해주기 위해


**데코레이터 패턴**
데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.

다이내믹하게 기능을 부여한다는 것은 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어
사용되는지 정해져 있지 않다는 뜻이다.

데코레이터 패턴에서는 프록시가 꼭 한 개로 제한되지 않는다. 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다.
프록시가 여러 개인 만큼 순서를 정해서 단계적으로 위임하는 구조로 만들면 된다.

예를 들어 소스 코드를 출력하는 기능을 가진 핵심 기능이 있다고 가정했을 때
소스코드에 라인넘버를 붙여주거나, 문법에 따라 색을 변경해주거나, 특정 폭으로 소스를 잘라서 표시해주는 부가기능을 프록시로 만들어
아래 그림처럼 런타임 시에 적절히 조합해서 사용하면 된다.

![[KakaoTalk_Photo_2025-07-03-21-39-36 004.jpeg]]
프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지
아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.
그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서
런타임 시에 주입받을 수 있도록 만들어야 한다.

인터페이스를 통한 데코레이터 정의와 런타임 시의 다이내믹한 구성 방법은 스프링의 DI를 이용하면 편리하다.
데코레이터 빈의 프로퍼티로 같은 인터페이스를 구현한 다른 데코레이터 또는 타깃 빈을 설정하면 된다.

UserServiceTx 클래스로 선언된 userService 빈은 데코레이터다.
UserServiceTx는 UserService 타입의 오브젝트를 DI 받아서 기능은 위임하지만, 그 과정에서 트랜잭션 경계설정을 부여해준다.
UserServiceImpl로 선언된 타깃 빈이 DI를 통해 데코레이터인 UserService 빈에 주입되도록 설정되어 있다.
다이내믹한 부가기능의 부여라는 데코레이터 패턴의 전형적인 적용 예다.
![[KakaoTalk_Photo_2025-07-03-22-29-50.jpeg]]
데코레이터 패턴은 인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에선 미리 알 수 없다.
구성하기에 따라서 여러 개으 데코레이터를 적용할 수도 있다.

UserServiceTx도 UserService라는 인터페이스를 통해 다음 오브젝트로 위임하도록 되어 있지
UserServiceImpl이라는 특정 클래스로 위임하도록 도어 있지 않다.

데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용하다.

**프록시 패턴**
일반적으로  사용하는 프록시라는 용어와 프록시 패턴을 구분할 필요가 있다.
전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭한다면
후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.

프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고 클라이언트가 타깃에 접근하는 방식을 변경해준다.

특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 프록시 패턴을 사용할 수 있다.
만약 수정 가능한 오브젝트가 있는데 특정 레이어로 넘어가면 읽기 전용으로만 동작하게 강제해야한다고 하자
이럴 때는 오브젝트의 프록시를 만들어서 사용할 수 있다.
프록시의 특정 메소드를 사용하려고 하면 접근이 불가능하다고 예외를 발생시키면 된다.

Collections의 unmodifiableCollection()을 통해 만들어지는 오브젝트가 전형적인 접근권한 제어용 프록시이다.
파라미터로 전달된 Collection 오브젝트의 프록시를 만들어서 add(), remove( ) 같이 정보를 수정하는 메소드를 호출할 경우
UnsupportedOperationException 예외가 발생하게 해준다.

이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.

앞으로는 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 기능의 부가 또는 접근 제어를 담당하는
오브젝트를 모두 프록시라고 부르겠다.

하지만 그때마다 사용 목적이 기능의 부가인지 접근 제어인지를 구분해보면 각가 어떤 목적으로 프록시가 사용됐는지
그에 따라 어떤 패턴이 적용됐는지 알 수 있을 것이다.

### 다이내믹 프록시
프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.
하지만 프록시를 만드는것은 번거롭다.
매번 새로운 클래스를 정의하고 인터페이스의 메소드들을 구현해줘야 한다.
단위 테스트를 위해 목이나 스텁을 일일이 클래스로 정의하고 모의 메소드를 구현하는 것과 비슷하다.
이런 불편한 점을 해결하기 위해 목 프레임워크를 사용해서 문제를 해결했었다.

이처럼 프록시도 java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스가 있다.

**프록시 클래스**
프록시를 적용할 간단한 타깃 클래스와 인터페이스를 정의해보자

Hello 인터페이스
```java
interface Hello {
	String sayHello(String name);
	String sayHi(String name);
	String sayThankYou(String name);
}
```

타깃 클래스
```java
public class HelloTarget implements Hello{
	public String sayHello(String name){
		return "Hello" + name;
	}

	public String sayHi(String name){
			return "Hi" + name;
		}
	
	public String sayThankYou(String name){
			return "ThankYou" + name;
		}
}
```

프록시 클래스
```java
public class HelloUppercase implements Hello{
	Hello hello; // 위임할 타깃 오브젝트, 여기서는 타깃 클래스의 오브젝트인 것은 알지만 다른 프록시를 추가할 수도 있으므로 인터페이스로 접근

	public HelloUppercase(Hello hello){
		this.hello = hello;
	}

	public String sayHello(String name){
		return hello.sayHello(name).toUpperCase(); //위임과 부가기능 적용
	}
	
	public String sayHi(String name){
		return hello.sayHi(name).toUpperCase(); //위임과 부가기능 적용
	}
	
	public String sayThankYou(String name){
		return hello.sayThankYou(name).toUpperCase(); //위임과 부가기능 적용
	}
}
```
데코레이터 패턴을 적용해서 타깃인 HelloTaret에 리턴하는 문자를 대문자로 변경해주는 부가기능을 추가했다.

HelloUppercase 프록시는 Hello 인터페이스를 구현하고 Hello 타입의 타깃 오브젝트를 받아서 저장해둔다.
Hello 인터페이스 구현 메소드에서는 타깃 오브젝트의 메소드를 호출한 뒤 결과를 대문자로 바꿔주는 부가기능을 적용하고  리턴한다.

이 프록시는 두 가지의 문제점이 있다.

1. 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야한다.
2. 부가기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복된다.

**다이내믹 프록시 적용**
![[KakaoTalk_Photo_2025-08-14-17-05-24 001.jpeg]]
다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트이다.

다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.
클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다. 이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서
클래스를 정의하는 수고를 덜 수 있다.
프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문이다.

다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야한다.
부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.
InvocationHandler 인터페이스는 메소드 한 개만 가진 간단한 인터페이스다.
```java
public Object invoke(Object proxy, Method method, Object[] args)
```

다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘기는 것이다.
타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.

남은 것은 각 메소드 요청을 어떻게 처리할지 결정하는 일이다.
리플렉션으로 메소드와 파라미터 정보를 모두 갖고 있으므로 타깃 오브젝트의 메소드를 호출하게 할 수도 있다.
InvacationHandler 구현 오브젝트가 타깃 오브젝트 레퍼런스를 갖고 있다면 리플렉션을 이용해 간단히 위임 코드를 만들 수 있다.

Hello 인터페이스를 제공하면서 프록시 팩토리에게 다이내믹 프록시를 만들어달라고 요청하면 Hello 인터페이스를 구현한 오브젝트를 제공해주면
다이내믹 프록시가 받는 모든 요청을 InvocationHandler의 invoke() 메소드로 보내준다.
Hello 인터페이스의 메소드가 아무리 많더라도 invoke() 메소드 하나로 처리할 수 있다.
![[KakaoTalk_Photo_2025-08-14-17-05-24 002.jpeg]]

InvocationHandler 구현 클래스
![[KakaoTalk_Photo_2025-08-14-18-07-22 001.jpeg]]
다이내믹 프록시로부터 요청을 전달받으려면 InvocationHandler를 구현해야 한다.
메소드는 invoke() 하나 뿐이다. 다니내믹 프록시가 클라이언트로부터 받는 모든 요청은 invoke() 메소드로 전달된다.
다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다.
타깃 오브젝트는 생성자를 통해 미리 전달받아 둔다. Hello 인터페이스의 모든 메소드는 결과가 String 타입이므로
메소드 호출의 결과를 String 타입으로 변환해도 안전하다.
타깃 오브젝트의 메소드 호풀이 끝났으면 프록시가 제공하려는 부가기능인 대문자로 바꾸는 작업을 수행하고 결과를 리턴한다.
리턴된 값은 다이내믹 프록시가 받아서 최종적으로 클라이언트에게 전달될 것 이다.

이제 이 InvocationHandler를 사용하고 Hello 인터페이스를 구현하는 프록시를 만들어보자
다이내믹 프록시 생성은 Proxy 클래스의 newProxyInstance() 스태틱 팩토리 메소드를 이용하면 된다.

![[KakaoTalk_Photo_2025-08-14-18-07-22 002.jpeg]]

첫 번째 파라미터는 클래스 로더를 제공해야 한다.
다이내믹 프록시가 정의되는 클래스 로더를 지정하는 것이다.

두 번째 파라미터는 다이내믹 프록시가 구현해야 할 인터페이스다.
다이내믹 프록시는 한 번에 하나 이상의 인터페이스를 구현할 수도 있다. 따라서 인터페이스의 배열을 사용한다.
여기서는 hello 인터페이스 한 가지만 구현했다.

세 번째는 부가기능과 위임 관련 코드를 담고 있는 InvocationHandler 구현 오브젝트를 제공해야한다.
Hello 타입의 타깃 오브젝트를 생성자로 받고 모든 메소드 호출의 리턴 값을 대문자로 바꿔주는 UppercaseHandler 오브젝트를 전달했다.

newProxyInstance()에 의해 만들어진 다이내믹 프록시 오브젝트는 Hello 인터페이스를 구현한 클래스의 오브젝트이므로 Hello 타입으로 캐스팅이 가능하다.

이렇게 완성을 했는데 딱히 기존보다 코드의 양이 줄어든것 같지도 않고 코드 작성은 오히려 더 까다로워진 것 같다.
과연 다이내믹 프록시를 적용했을 때 장점이 있긴 있는 것일까?

**다이내믹 프록시의 확장**
물론 다이내믹 프록시 방식이 직접 정의해서 만든 프록시보다 훨씬 유연하고 많은 장점이 있다.
Hello 인터페이스의 메소드가 3개에서 30개로 늘어나면?
직접 구현한 프록시는 모든 메소드를 추가해줘야한다. 하지만 다이내믹 프록시를 생성해서 사용하는 코드는 손댈 게 없다.
추가된 메소드들은 자동으로 포함될 것이고 부가기능은 invoke() 메소드에서 처리되기 때문이다.

UppercaseHandler는 모든 메소드의 리턴 타입을 스트링으로 가정했다.
그런데 스트링 외 다른 리턴 타입을 갖는 메소드가 추가된다면 런타임시에 오류가 발생할 것이다.
리플렉션은 매우 유연하고 막강한 기능을 가진 대신 주의 깊게 사용할 필요가 있다.

InvocationHandler 방식의 또 한 가지 장점은 타깃의 종류에 상관없이 적용이 가능하다는 점이다.
어떤 종류의 인터페이스를 구현한 타깃이든 상관없이 재사용할 수 있고 메소드의 리턴 타입이 스트링인 경우만 대문자로 결과를 바꿔주도록 수정한다.

![[KakaoTalk_Photo_2025-08-14-20-55-33 001.jpeg]]
InvocationHandler는 단일 메소드에서 모든 요청을 처리하기 때문에 어떤 메소드에 어떤 기능을 적용할지를
선택하는 과정이 필요할 수 있다.
호출하는 메소드의 이름, 파라미터의 개수와 타입, 리턴 타입 등의 정보를 가지고 부가적인 기능을 적용할 메소드를 선택할 수 있다.
리턴 타입뿐 아니라 메소드의 이름도 조건으로 걸 수 있다.

![[KakaoTalk_Photo_2025-08-14-20-55-33 002.jpeg]]
메소드의 이름이 say로 시작하는 경우에만 대문자로 바꾸는 기능을 적용한 방식

### 다이내믹 프록시를 이용한 트랜잭션 부가기능
UserServiceTx를 다이내믹 프록시 방식으로 변경해보자
UserServiceTx는 서비스 인터페이스의 모든 메소드를 구현해야하고 트랜잭션이 필요한 메소드마다
트랜잭션 처리코드가 중복돼서 나타나는 비효율적인 방법으로 만들어져 있다.

따라서 트랜잭션 부가기능을 제공하는 다이내믹 프록시를 만들어 적용하는 방법이 효율적이다.

**트랜잭션 InvocationHandler**
![[KakaoTalk_Photo_2025-08-14-21-20-55 001.jpeg]]
![[KakaoTalk_Photo_2025-08-14-21-20-55 002.jpeg]]
요청을 위임할 타깃을 DI로 제공받고 타깃을 저장할 변수는 Object로 선언했다.
따라서 userServiceImpl 외에 트랜잭션 적용이 필요한 어떤 타깃 오브젝트에도 적용할 수 있다.
트랜잭션 추상화 인터페이스인 PlatformTransactionManager를 DI 받고록했고 타깃 오브젝트의 모든 메소드에
무조건 트랜잭션이 적용되지 않도록 트랜잭션을 적용할 메소드 이름의 패턴을 DI 받는다.
간단히 메소드 이름의 시작 부분을 비교할 수 있게 만들었다. pattern을  "get"으로 주면 get으로 시작하는 모든 메소드에 트랜잭션이 적용된다.

트랜잭션을 적용하면서 타깃 오브젝트의 메소드를 호출하는 것은 UserServiceTx에서와 동일하다.
한 가지 차이점은 롤백을 적용하기 위한 예외는 RuntimeException 대신 InvocationTargetException을 잡도록 해야 한다는 점이다.
리플렉션 메소드인 Method.invoke()를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생한 예외가
InvocationTargetException으로 한 번 포장돼서 전달된다.
따라서 일단 InvocationTargetException으로 받은 후 getTargetException() 메소드로 중첩되어 있는 예외를 가져와야한다.

### 다이내믹 프록시를 위한 팩토리 빈
이제 TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들어야 할 차례다.
그런데 문제는 DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로 등록할 방법이 없다는 점이다.
스프링의 빈은 기본적으로 클래스 이름과 프로퍼티로 정의된다. 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클래스의 오브젝트를 만든다.

```java
Date now = (Date) Class.forName("java.util.Date").newInstance();
```
Class의 newInstance() 메소드는 해당 클래스의 파라미터가 없는 생성자를 호출하고 그 결과 생성된 오브젝트를 돌려주는 리플렉션 API이다.

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다.
문제는 다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다.
사실 다이내믹 프록시 오브젝트의 클래스가 어떤 것인지 알 수도 없다. 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용하기 때문이다.
따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 방법이 없다.
다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

**팩토리 빈**
사실 스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 잇는 여러 방법을 제공한다.
대표적으로 팩토리 빈을 이용한 생성 방법을 들 수 있다.
팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈을 말한다.

팩토리 빈을 만드는 가장 간단한 방법은 스프링의 FactoryBean이라는 인터페이스를 구현하는 것이다.
![[KakaoTalk_Photo_2025-08-14-22-24-42 003.jpeg]]
FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.

팩토리 빈의 동작원리를 확인할 수 있는 간단한 예시
먼저 스프링에서 빈 오브젝트로 만들어 사용하고 싶은 클래스 하나를 정의
Message 클래스는 생성자를 통해 오브젝트를 만들 수 없으며 반드시 스태틱 메소드를 사용해야한다.
![[KakaoTalk_Photo_2025-08-14-22-24-42 001.jpeg]]
Message 클래스의 오브젝트를 만들려면 newMessage()라는 스태틱 메소드를 사용해야 한다.
따라서 이 클래스를 직접 스프링 빈으로 등록해서 사용할 수 없다.
```xml
<bean id="m" class="spring.factorybean.Message"> # private 생성자를 가진 클래스의 직접 사용 금지
```
사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다.
리플렉션은 private로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문이다.
하지만 생성자를 private로 만들었다는 것은 스태틱 메소드를 통해 오브젝트가 만들어져야 하는 중요한 이유가 있기 때문이므로 이를 무시하고
오브젝트를 강제로 생성하면 위험하다.


![[KakaoTalk_Photo_2025-08-14-22-24-42 002.jpeg]]
팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트다.
스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고
이를 빈 오브젝트로 사용한다. 빈의 클래스로 등록된 팩토리 빈은 빈 오브젝트를 생성하는 과정에서만 사용된다.

**다이내믹 프록시를 만들어주는 팩토리 빈**
![[KakaoTalk_Photo_2025-08-14-22-56-56 001.jpeg]]
스프링 빈에는 팩토리 빈과 UserServiceImpl만 빈으로 등록한다.
팩토리 빈은 다이내믹 프록시가 위임 할 타깃 오브젝트인 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다.
다이내믹 프록시와 함께 생성할  TransactionHandler에게 타깃 오브젝트를 전달해줘야 하기 때문이다.

**트랜잭션 프록시 팩토리 빈**


![[KakaoTalk_Photo_2025-08-14-22-56-57 002.jpeg]]

![[KakaoTalk_Photo_2025-08-14-22-56-57 003.jpeg]]
팩토리 빈이 만드는 다이내믹 프록시는 구현 인터페이스나 타깃의 종류에 제한이 없다.
따라서 UserService 외에도 트랜잭션 부가기능이 필요한 오브젝트를 위한 프록시를 만들 때 재사용이 가능하다.
설정이 다른 여러 개의 TxProxyFactoryBean을 등록하면 된다.

![[KakaoTalk_Photo_2025-08-14-23-12-20.jpeg]]
target, transactionManager 프로퍼티는 다른 빈을 가르키는 것이므로 ref로 설정했고 pattern은 스트링 타입이라 value로 설정했다.
serviceInterface는 Class 타입도 value로 설정해주면 된다.

### 프록시 팩토리 빈 방식의 장점과 한계

**프록시 팩토리 빈 방식의 장점**
앞에서 데코레이터 패턴이 적용된 프록시를 사용하면서 생긴 두 가지의 문제점이 있다고 했다.
1.  프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야 하는 번거로움
2.  부가적인 기능이 여러 메소드에 반복적으로 나타나 코드의 중복이 발생

지금까지 살펴본 프록시 팩토리 빈은 이 두 가지 문제를 해결해준다.

다이내믹 프록시에 팩토리 빈을 이용한 DI까지 더해주면 번거로운 다이내믹 프록시 생성코드도 제거할 수 있다.
DO 설정만으로 다양한 타깃 오브젝트에 적용도 가능하다.
이처럼 앞서 고민했던 문제점들을 해결해주었다.

**프록시 팩토리 빈의 한계**
프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다.
하나의 클래스 안에 존재하는 여러 개의 메소드에 부가기능을 한 번에 제공하는 건 어렵지 않게 가능했다.
하지만 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 지금까지 살펴본 방법으로는 불가능하다.
하나의 타깃 오브젝트에만 부여되는 부가기능이라면 상관 없겠지만 트랜잭션과 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 있다면
거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.

하나의 타깃에 여러 개의 부가 기능을 적용하려고 할 때도 문제다.
같은 타깃 오브젝트에 트랜잭션 뿐만 아니라 보안, 기능검사 등 다른 부가기능을 적용하려고 한다면 서비스 빈의 설정이 길어지게 된다.
적용 대상인 서비스 클래스가 수백개가 된다면 수백개의 프록시 팩토리 빈 설정이 필요하고 설정 파일의 크기가 엄청 방대해진다.
코드 수정 없이 수백개의 메소드에 새로운 기능을 추가하는게 엄청난 것이긴 하지만 설정파일이 복잡해지는 것은 또 다른 문제를 야기한다.
