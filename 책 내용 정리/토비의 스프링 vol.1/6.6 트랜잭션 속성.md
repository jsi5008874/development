PlatformTransactionManager로 대표되는 스프링의 트랜잭션 추상화를 설명하면서 얼렁둥땅 넘어간게 한 가지 있다.
트랜잭션 매니저에서 트랜잭션을 가져올 때 사용한 DefaultTransactionDefinition 오브젝트다.

TransactionAdvice의 트랜잭션 경계설정 코드를 다시 살펴보자
![[KakaoTalk_Photo_2025-09-03-16-16-01.jpeg]]
트랜잭션의 경계는 트랜잭션 매니저에게 트랜잭션을 가져오는 것과 commit(), rollback() 중의 하나를 호출하는 것으로 설정된다.
트랜잭션을 가져올 때 파라미터로 트랜잭션 매니저에게 전달하는 DefaultTransactionDefinition의 용도가 무엇인지 알아보자.

### 트랜잭션의 정의
트랜잭션이라고 모두 같은 방식으로 동작하는 것은 아니다. 물론 트랜잭션의 기본 개념인 더 이상 쪼갤 수 없는 최소 단위의 작업이라는 개념은 항상 유효하다. 따라서 트랜잭션 경계 안에서 진행된 작업은 commit()을 통해 모두 성공하든지 아니면 rollback()을 통해 모두 취소돼야한다. 그런데 이 밖에도 트랜잭션의 동작방식을 제어할 수 있는 몇 가지 조건이 있다.
DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다.

**트랜잭션 전파**
트랜잭션 전파(transaction propagation)란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.
![[KakaoTalk_Photo_2025-09-03-16-31-06.jpeg]]
그림과 같이 A의 트랜잭션이 시작되고 끝나지 않은 시점에서 B를 호출하면 B의 코드는 어떤 트랜잭션 안에서 동작해야 할까?
여러 가지 시나리오를 생각해 볼 수 있다.

A에서 트랜잭션이 시작돼서 진행 중이라면 B의 코드는 새로운 트랜잭션을 만들지 않고 A에서 이미 시작한 트랜잭션에 참여할 수 있다.
이 경우 B를 호출한 작업까지 마치고 (2)의 코드에서 예외가 발생한다면 A, B 모두 롤백된다. A,B가 하나의 트랜잭션으로 묶여있기 때문이다.

반대로 B의 트랜잭션이 A와 무관하게 독립적인 트랜잭션으로 만들 수 있다.
이 경우 B의 트랜잭션 경계를 빠져나오는 순간 B의 트랜잭션은 독자적으로 커밋 또는 롤백될 것이고 A 트랜잭션은 거기에 영향을 받지 않고 진행될 것이다.

이렇게 B와 같이 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행중인 트랜잭션이 어떻게 영향을 미칠 수 있는가를 정의하는 것이 트랜잭션 전파 속성이다.

대표적으로 다음과 같은 트랜잭션 전파속성을 줄 수 있다.

1. Propagation_Required
	가장 많이 사용되는 트랜잭션 전파 속성이다. 진행 중인 트랜잭션이 없으면 새로 시작하고 이미 시작된 트랜잭션이 있으면 참여한다.
	이 전파속성을 갖는 코드는 다양한 방식으로 경합해서 하나의 트랜잭션으로 구성하기 쉽다.
	A와 B 모두 Propagation_Required로 선언되어 있다면 A,B, A > B, B > A와 같은 네 가지의 조합된 트랜잭션 모두 가능하다.
	DefaultTransactionDefinition의 트랜잭션 전파 속성은 바로 이 Propagation_Required다.

2. Propagation_Required_new
	항상 새로운 트랜잭션을 시작한다. 즉 앞에서 시작된 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어 독자적으로 동작한다. 독립적인 트랜잭션이 보장돼야 하는 코드에 적용할 수 있다.

3. Propagation_Not_Supported
	이 속성을 이용하면 트랜잭션 없이 동작하도록 만들 수도 있다. 진행 중인 트랜잭션이 있어도 무시한다.
	트랜잭션을 무시하는 속성을 두는 데는 이유가 있다. 트랜잭션 경계설정은 보통 AOP를 이용해 한 번에 많은 메소드에 동시에 적용하는 방법을 사용한다. 그런데 그 중에서 특별한 메소드만 트랜잭션 적용에서 제외하려면 어떻게 해야할까?
	모든 메소드에 트랜잭션 AOP가 적용되게 하고 특정 메소드의 트랜잭션 전파 속성만 Propagation_Not_Supported로 설정해서 트랜잭션 없이 동작하게 만든다.

트랜잭션 매니저를 통해 트랜잭션을 시작하려고 할 때 getTransaction()이라는 메소드를 사용하는 이유는 바로 이 트랜잭션 전파 속성이 있기 때문이다. 트랜잭션 매니저의 getTransaction() 메소드는 항상 트랜잭션을 새로 시작하는 것이 아니다.
트랜잭션 전파 속성과 현재 진행 중인 트랜잭션이 존재하는지 여부에 따라서 새로운 트랜잭션을 시작할 수도 있고 이미 진행중인 트랜잭션에 참여하기만 할 수도 있다. 진행 중인 트랜잭션에 참여하는 경우는 트랜잭션 경계의 끝에서 트랜잭션을 커밋하지도 않는다.
최초로 트랜잭션을 시작한 경계까지 정상적으로 진행돼야 비로소 커밋될 수 있다.

**격리수준**
모든 DB 트랜잭션은 격리수준을 갖고 있어야 한다.
가능하다면 모든 트랜잭션이 순차적으로 진행돼서 다른 트랜잭션의 작업에 독립적인 것이 좋겠지만 그러자면 성능이 크게 떨어진다.
따라서 적절한 격리수준을 조정해서 가능한 많은 트랜잭션을 동시에 진행시키면서 문제가 발생하지 않게 제어해야한다.
격리수준은 기본적으로 DB에 설정되어 있지만 JDBC 드라이버나 DataSoure 등에서 재설정할 수 있고 필요하다면 트랜잭션 단위로 격리수준을 조정할 수 있다.

DefaultTransactionDefinition에 설정된 격리수준은 ISOLATION_DEFAILT다.
이는 DataSoure에 설정되어 있는 디폴트 격리수준을 그대로 따른다는 뜻이다.
특별한 작업을 수행하는 메소드의 경우는 독자적인 격리수준을 지정할 필요가 있다.

**제한시간**
트랜잭션을 수행하는 제한시간(timeout)을 설정할 수 있다.
DefaultTransactionDefinition의 기본 설정은 제한시간이 없다.
제한시간은 트랜잭션을 직접 시작할 수 있는 Propagation_Required, Propagation_Required_New와 함께 사용해야 의미가 있다.

**읽기전용**
읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다. 또한 데이터 액세스 기술에 따라서 성능이 향상된다.

TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션의 동작방식을 제어할 수 있다.

트랜잭션 정의를 수정하려면 어떻게 해야 할까? TransactionDefinition 오브젝트를 생성하고 사용하는 코드는 트랜잭션 경계설정 기능을 가진 TransactionAdvice다. 트랜잭션 정의를 바꾸고 싶다면 디폴트 속성을 갖고 있는 DefaultTransactionDefinition을 사용하는 대신 외부에서 정의된 TransactionDefinition 오브젝트를 DI 받아서 사용하도록 만들면 된다.
TransactionDefinition 타입의 빈을 정의해두면 프로퍼티를 통해 원하는 속성을 지정해줄 수 있다.
하지만 이 방법으로 트랜잭션 속성을 변경하면 TransactionAdvice를 사용하는 모든 트랜잭션 속성이 한번에 바뀐다는 문제가 있다.
원하는 메소드만 독자적으로 트랜잭션 정의를 적용하는 방법은 없을까?

### 트랜잭션 인터셉터와 트랜잭션 속성
메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 한다.
마치 초기에 TransactionHandler에서 메소드 이름을 이용해 트랜잭션 적용 여부를 판단 했던 것과 비슷한 방식을 사용하면 된다.
메소드 이름 패턴에 따라 다른 트랜잭션 정의가 적용되도록 만드는 것이다.

**TransactionInterceptor**
이를 위해 기존에 만들었던 TransactionAdvice를 다시 설계할 필요는 없다. 이미 스프링에는 편리하게 트랜잭션 경계설정 어드바이스로 사용할 수 있도록 만들어진 TransactionInterceptor가 존재하기 때문이다.

TransactionInterceptor 어드바이스의 동작 방식은 기존과 다르지 않다.
다만 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공해줄 뿐이다.
TransactionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있다.
트랜잭션 매니저는 알지만 Properties 타입은 처음 본다.

Properties 타입인 두 번째 프로퍼티 이름은 transactionAttributes로 트랜잭션 속성을 정의한 프로퍼티다.
트랜잭션 속성은 TransactionDefinition의 네 가지 기본 항목에 rollbackOn() 이라는 메소드를 하나 더 가지고 있는 TransactionAttribute 인터페이스로 정의된다.
rollbackOn() 메소드는 어떤 예외가 발생하면 롤백을 할 것인가를 결정하는 메소드다. 이 TransactionAttribute를 이용하면 트랜잭션 부가기능의 동작방식을 모두 제어할 수 있다.

아래 사진을 보면 트랜잭션 경계설정 코드에서 트랜잭션 부가기능의 동작방식을 변경할 수 있는곳이 두 군데 있다는 사실을 알 수 있다.
![[KakaoTalk_Photo_2025-09-03-22-30-09 001.jpeg]]
TransactionAdvice는 RuntimeException이 발생하는 경우에만 롤백시킨다. 하지만 런타임 예외가 아닌 경우에는 트랜잭션이 제대로 처리되지 않고 메소드를 빠져나가게 되어 있다. 체크 예외를 던지는 타깃에 사용한다면 문제가 될 수 있다.
그렇다면 런타임 예외만이 아니라 모든 종류의 예외에 대해 트랜잭션을 롤백시키도록 해야 할까? 그래서는 안 된다.
비즈니스 로직상의 예외 경우를 나타내기 위해 타깃 오브젝트가 체크 예외를 던지는 경우에는 DB 트랜잭션은 커밋시켜야 하기 때문이다. 이전에 설명했듯이 일부 체크 예외는 정상적인 작업 흐름 안에서 사용될 수도 있다.

TransactionInterceptor에는 기본적으로 두 가지 종류의 예외 처리 방식이 있다. 런타임 예외가 발생하면 트랜잭션은 롤백된다.
반면에 타깃 메소드가 런타임 예외가 아닌 체크 예외를 던지는 경우에는 이것을 예외상황으로 해석하지 않고 일종의 비즈니스 로직에 따른 의미가 있는 리턴 방식의 한 가지로 인식해서 트랜잭션을 커밋해버린다.

그런데 TransactionInterceptor의 이러한 예외처리 기본 원칙을 따르지 않는 경우가 있을 수 있다. 그래서 TransactionAttribute는 rollbackOn()이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해준다. 이를 활용하면 특정 체크 예외의 경우는 트랜잭션을 롤백시키고 특정 런타임 예외에 대해서는 커밋시킬 수도 있다.

**메소드 이름 패턴을 이용한 트랜잭션 속성 지정**
Properties 타입의 transactionAttribute 프로퍼티는 메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다.
트랜잭션 속성은 다음과 같은 문자열로 정의할 수 있다.
![[KakaoTalk_Photo_2025-09-03-22-30-09 002.jpeg]]
이 중에서 트랜잭션 전파 항목만 필수이고 나머지는 생략 가능하다. 생략하면 디폴트 속성이 부여된다.
이렇게 속성을 하나의 문자열로 표현하게 만든 이유는 트랜잭션 속성을 메소드 패턴에 따라 여러 개를 지정해줘야 하는데 일일이 중첩된 태그와 프로퍼티로 설정하게 만들면 번거롭기 때문이다.

![[KakaoTalk_Photo_2025-09-03-22-30-09 003.jpeg]]
세 가지 메소드 이름 패턴에 대한 트랜잭션 속성이 정의 되어 있다.
첫 번째는 get으로 시작하는 모든 메소드에 대한 속성으로 PROPAGATION_REQUIRED이면서 읽기 전용이고 30초 시간제한이다.

두 번째는 upgrade로 시작하는 메소드는 항상 독립적인 트랜잭션을 가지도록 PROPAGATION_REQUIRED_NEW로 설정하고 다른 동시 작업에 영향을 받지 않도록 ISOLATION_SERIALIZABLE을 설정했다.

세 번째는 위 두가지 조건에 해당하지 않는 나머지 모든 메소드에 사용될 속성을 지정했다.

때로는 메소드 이름이 하나 이상의 패턴과 일치하는 경우가 있다. 이때는 메소드 이름 패턴 중에서 가장 정확히 일치하는 것이 적용된다.

**tx 네임스페이스를 이용한 설정 방법**
TransactionIntercertor 타입의 어드바이스 빈과 TransactionAttribute 타입의 속성 정보도 tx 스키마 전용 태그를 이용해 정의 할 수 있다. 트랜잭션 어드바이스도 포인트컷이나 어드바이저만큼 자주 사용되고 애플리케이션 컴포넌트가 아닌 컨테이너가 사용하는 기반기술 설정의 한 가지이기 때문이다.

TransactionInterceptor 빈으로 정의한 트랜잭션 어드바이스와 메소드 패턴에 따른 트랜잭션 속성 지정은 tx 스키마 태그를 이용해 간단하게 정의할 수 있다.
![[KakaoTalk_Photo_2025-09-03-22-58-57 001.jpeg]]
![[KakaoTalk_Photo_2025-09-03-22-58-57 002.jpeg]]

### 포인트컷과 트랜잭션 속성의 적용 전략
트랜잭션 부가기능을 적용할 후보 메소드를 선정하는 작업은 포인트컷에 의해 진행된다. 그리고 어드바이스의 트랜잭션 전파 속성에 따라서 메소드별로 트랜잭션 적용방식이 결정된다.
expression 애트리뷰트에 넣는 포인트컷 표현식과 tx:attribute로 정의하는 트랜잭션 속성만 결정하면 된다.

**트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다**
일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용후보가 되는 것이 바람직하다. 지금까지는 포인트컷의 메소드 선정기능을 살펴보기 위해 UserService의 upgradeLevels() 메소드 하나에만 트랜잭션이 적용되게 해왔다. 하지만 비즈니스 로직을 담고 있는 클래스라면 메소드 단위까지 세밀하게 포인트컷을 지정해줄 필요는 없다.

UserService의 add() 메소드도 트랜잭션 적용 대상이어야 한다.
add() 메소드 자체만 생각해보더라도 UserDao.add()를 호출해서 사용자 정보를 DB에 추가하는 것 외에도 DB의 정보를 다루는 작업이 추가될 가능성이 높다. 따라서 add() 메소드는 트랜잭션 안에서 동작하도록 정의하는게 바람직하다.

쓰기 작업이 없는 단순한 조회 작업만 하는 메소드에도 모두 트랜잭션을 적용하는게 좋다. 조회의 경우에는 읽기전용으로 트랜잭션 속성을 설정해두면 그만큼 성능의 향상을 가져올 수 있다. 또, 복잡한 조회의 경우 제한시간을 지정해줄 수도 있고 격리수준에 따라 조회도 반드시 트랜잭션 안에서 진행해야 할 필요가 발생하기도 한다.

따라서 트랜잭션용 포인트컷 표현식에는 메소드나 파라미터, 예외에 대한 패턴을 정의하지 않는게 바람직하다.
트랜잭션의 경계로 삼을 클래스들이 선정됐다면 그 클래스들이 모여 있는 패키지를 통째로 선택하거나 클래스 이름에서 일정한 패턴을 찾아서 표현식으로 만들면 된다.
가능하면 클래스보다는 인터페이스 타입을 기준으로 타입 패턴을 적용하는 것이 좋다. 인터페이스는 클래스에 비해 변경 빈도가 적고 일정한 패턴을 유지하기 쉽기 때문이다.

메소드의 시그니처를 이용한 execution() 방식의 포인트컷 표현식 대신 스프링 빈 이름을 이용하는 bean() 표현식을 사용하는 방법도 고려해볼 만하다. bean() 표현식은 빈 이름을 기준으로 선정하기 때문에 클래스나 인터페이스 이름에 일정한 규칙을 만들기가 어려운 경우에 유용하다. 빈의 아이디가 Service로 끝나는 모든 빈에 대해 트랜잭션을 적용하고 싶다면 포인트컷 표현식을
```
bean(*Service)
```
라고 지정하면 된다.

**공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다**
실제로 하나의 애플리케이션에서 사용할 트랜잭션 속성의 종류는 그다지 다양하지 않다.
너무 다양하게 트랜잭션 속성을 부여하면 관리만 힘들어질 뿐이다. 따라서 기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어두면 하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성을 지정할 수 있다.

그런데 가끔 트랜잭션 속성의 적용 패턴이 일반적인 경우와 크게 다른 오브젝트가 존재한다. 이런 예외적인 경우는 트랜잭션 어드바이스와 포인트컷을 새롭게 추가해줄 필요가 있다.

트랜잭션 적용 대상 클래스의 메소드는 일정한 명명 규칙을 따르게 해야한다.
일반화하기에는 적당하지 않은 특별한 트랜잭션 속성이 필요한 타깃 오브젝트에 대해서는 별도의 어드바이스와 포인트컷 표현식을 사용하는 편이 좋다.
![[KakaoTalk_Photo_2025-09-03-23-43-59 001.jpeg]]
두 개의 포인트컷과 어드바이스를 적용한 예다. 비즈니스 로직을 정의한 서비스 빈에는 기본적인 메소드 이름 패턴을 따르는 트랜잭션 속성을 지정해둔다.
반면에 트랜잭션의 성격이 많이 다른 배치 작업용 클래스를 위해서는 트랜잭션 어드바이스를 별도로 정의해서 독자적인 트랜잭션 속성을 지정해준다.

**프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다**
이건 전략이라기보다는 주의사항이다. 프록시 방식의 AOP에서는 프록시를 통한 부가기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다. 여기서 클라이언트는 인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트를 말한다.
반대로 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가기능의 적용이 일어나지 않는다.
![[KakaoTalk_Photo_2025-09-03-23-44-00 002.jpeg]]
그림에서 delete와 update 모두 트랜잭션 적용 대상인 메소드다. 따라서 1과 3처럼 클라이언트로부터 메소드가 호출되면 프록시를 통해 타깃 메소드로 호출이 전달되므로 트랜잭션 경계설정 부가기능이 부여될 것이다.

하지만 2의 경우는 일단 타깃 오브젝트 내로 들어와서 타깃 오브젝트의 다른 메소드를 호출하는 경우네는 프록시를 거치지 않고 직접 타깃 메소드가 호출된다.
따라서 2를 통해 호출된 update()는 지정된 트랜잭션 속성이 반영되지 않는다.

이렇게 같은 타깃 오브젝트 안에서 메소드 호출이 일어나는 경우에는 프록시 AOP를 통해 부여해준 부가기능이 적용되지 않는다.

### 트랜잭션 속성 적용
트랜잭션 속성과 그에 따른 트랜잭션 전략을 UserService에 적용해보자.
지금까지 살펴봤던 몇 가지 원칙과 전략에 따라 작업을 진행할 것이다.

**트랜잭션 경계설정의 일원화**
트랜잭션 경계설정의 부가기능을 여러 계층에서 중구난방으로 적용하는 건 좋지 않다.
일반적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다. 비즈니스 로직을 담고 있는 서비스 계층 오브젝트의 메소드가 트랜잭션 경계를 부여하기에 가장 적절한 대상이다.
서비스 계층을 트랜잭션 경계로 정했다면 테스트와 같은 특별한 이유가 아니고는 다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단해야한다. 가능하면 다른 모듈의 DAO에 접근할 때는 서비스 계층을 거치도록 하는게 바람직하다. 그래야 UserService의 add() 처럼 부가 로직을 적용할 수도 있고 트랜잭션 속성도 제어할 수 있기 때문이다.

UserDao 인터페이스에 정의된 6개의 메소드 중에서 이미 서비스 계층에 부가적인 로직을 담아서 추가한 add()를 제외한 나머지 5개가 UserService에 새로 추가할 후보메소드다. 이 중에서 단순히 레코드 개수를 리턴하는 getCount()를 제외하면 나머지는 독자적인 트랜잭션을 가지고 사용될 가능성이 높다. 따라서 이 4개의 메소드를 UserService에 추가한다.
![[KakaoTalk_Photo_2025-09-04-00-12-46 002.jpeg]]

그리고 UserServiceImpl에 추가된 메소드 구현 코드를 넣어준다.
![[KakaoTalk_Photo_2025-09-04-00-12-46 003.jpeg]]
이제 모든 User 관련 데이터 조작은 UserService라는 트랜잭션 경계를 통해 진행할 경우 모두 트랜잭션을 적용할 수 있다.

**서비스 빈에 적용되는 포인트컷 표현식 등록**
upgradeLevels()에만 트랜잭션이 적용되게 했던 기존 포인트컷 표현식을 모든 비즈니스 로직의 서비스 빈에 적용되도록 수정한다.
표현식은 가장 단순한 빈 이름 패턴을 이용해도 좋을 것 같다.
aop 스키마 태그를 이용해 포인트컷, 어드바이저 등의 설정을 만들어준다.
![[KakaoTalk_Photo_2025-09-04-00-14-20.jpeg]]
이제 Service로 끝나는 모든 빈에 transactionAdvisor 빈의 부가기능이 적용될 것이다.

**트랜잭션 속성을 가진 트랜잭션 어드바이스 등록**
TransactionAdvice 클래스로 정의했던 어드바이스 빈을 스프링의 TransactionInterceptor를 이용하도록 변경한다.
메소드 패턴과 트랜잭션 속성은 가장 보편적인 방법인 get으로 시작하는 메소드는 읽기전용 속성을 두고 나머지는 디폴트 트랜잭션 속성을 따르는 것으로 설정한다.
![[KakaoTalk_Photo_2025-09-04-00-12-46 005.jpeg]]

이미 aop 스키마의 태그를 적용했으니 어드바이스도 tx 스키마에 정의된 태그를 이용하도록 만들어준다.
![[KakaoTalk_Photo_2025-09-04-00-12-46 006.jpeg]]

**트랜잭션 속성 테스트**
학습테스트를 만들어보자.
<tx:attributes>로 지정한 트랜잭션 속성을 보면 get으로 시작하는 메소드에는 읽기전용 속성이 true로 되어 있다.
따라서 이 메소드를 경계로 시작되는 트랜잭션에는 쓰기 작업이 허용되지 않는다. 이를 테스트해보자.

예외적인 상황을 만들어야 하기 때문에 트랜잭션 롤백 테스트를 위해 만든 TestUserService를 활용해보겠다.
새로 추가한 getAll() 메소드를 오버라이드해서 강제로 DB에 쓰기 작업을 추가할 것이다. get으로 시작하기 때문에 읽기전용 트랜잭션 속성이 적용된 채로 동작해야 한다. 트랜잭션 안에서 쓰기 시도를 하면 그에 따른 예외가 발생할 것이다.
![[KakaoTalk_Photo_2025-09-04-00-12-46 001.jpeg]]

이제 조작된 getAll()을 호출하는 테스트를 만들어보자.
![[KakaoTalk_Photo_2025-09-04-00-12-46 007.jpeg]]
예외 발생을 확인하는게 목적이므로 테스트가 실패하면 성공이고 성공하면 실패한 것이다.

![[KakaoTalk_Photo_2025-09-04-00-26-48.jpeg]]
테스트를 돌려보면 위와 같은 에러메세지가 발생한다.
메세지를 보면 읽기전용으로 설정된 DB 커넥션에 대해 데이터를 조작하는 작업을 시도해서 발생한 에러임을 알 수 있다.

예외 타입은 TransientataAccessResourceException이다.
이를 expected에 추가해서 다시 돌려본다.
![[KakaoTalk_Photo_2025-09-04-00-12-46 008.jpeg]]
이렇게하면 테스트가 성공한다.
이제 트랜잭션 AOP가 바르게 동작하고 메소드에 따라 적절한 트랜잭션 속성이 부여되고 있음을 확인할 수 있다.

