
### ProxyFactoryBean
스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
기존에 만들었던 TxProxyFactoryBean과 달리 ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만 담당하고
프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.

ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
MethodInterceptor는 InvocationHandler와 비슷하지만 한 가지 다른 점이 있다.
InvocationHandler의 invoke() 메소드는 타깃 오브젝트에 대한 정보를 제공하지 않는다. 따라서 타깃은 InvocationHandler를 구현한 클래스가 직접 알고 있어야한다.
반면 MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다.
그 차이 덕분에 MethodIntercerptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고 싱글톤 빈으로 등록 가능하다.

![[KakaoTalk_Photo_2025-08-15-18-07-55 001.jpeg]]
![[KakaoTalk_Photo_2025-08-15-18-07-55 002.jpeg]]

**어드바이스: 타깃이 필요 없는 순수한 부가기능**
ProxyFactoryBean을 적용한 코드는 기존의 다이내믹 프록시 코드와 몇 가지 차이점이 있다.

InvocationHandler를 구현했을 때와 달리 MethodInterceptor를 구현한 UppercaseAdvice에는 타깃 오브젝트가 등장하지 않는다.
MethodInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 담긴 MethodInvocation 오브젝트가 전달된다.
MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에 MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있다.

MethodInvocation은 일종의 콜백 오브젝트로 proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다.
그렇다면 MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작하는 것이다.
바로 이 점이 JDK의 다이내믹 프록시를 직접 사용하는 코드와 스프링의 ProxyFactoryBean을 사용하는 코드의 가장 큰 차이점이자 장점이다.
마치 SQL의 파라미터 정보에 종속되지 않는 JdbcTemplate이기 때문에 수많은 DAO 메소드가 하나의 JdbcTemplate 오브젝트를 공유할 수 있는 것과 마찬가지다.

ProxyFactoryBean에 이 MethodInterceptor를 설정해줄 때는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신
AddAdvice()라는 메소드를 사용한다는 점도 눈여겨 봐야한다.
add라는 이름에서 알 수 있듯이 ProxyFactoryBean에는 여러 개의 MethodInterceptor를 추가할 수 있다.
ProxyFactoryBean 하나로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다는 뜻이다.

MethodInterceptor 오브젝트를 추가하는 메소드 이름은 addMethodInterceptor가 아니라 addAdvice이다.
MethodInterceptor는 Advice 인터페이스를 상속하고 있는 서브인터페이스이기 때문이다.
이름에서 알 수 있듯이 MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 스프링에서는 Advice라고 부른다.

마지막 차이점은 프록시가 구현해야 하는 Hello라는 인터페이스를 제공해주는 부분이 없다.
프록시를 직접 만들 때나 JDK 다이내믹 프록시를 만들 때 반드시 제공해줘야하는 정보가 Hello 인터페이스였다.
그래야만 프록시 오브젝트의 타입을 결정할 수 있기 때문이다.
그런데 스프링의 ProxyFactoryBean은 그렇지 않다.

ProxyFactoryBean에 잇는 인터페이스 자동 검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.
그리고 알아낸 인터페이스를 모두 구현하는 프록시를 만들어준다.
타깃 오브젝트가 구현하는 인터페이스 중에서 일부만 프록시에 적용하기를 원한다면 인터페이스 정보를 직접 제공해줘도 된다.

그 밖에도 ProxyFactoryBean은 프록시를 작성하고 빈으로 등록해서 사용하는데 필요한 다양한 기능을 제공하고 있다.

어드바이스는 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트라는 사실을 기억해둬야한다.

**포인트컷: 부가기능 적용 대상 메소드 선정 방법**
기존에 InvocationHandler를 직접 구현했을 때는 부가기능 적용 외에도 한 가지 작업이 더 있었다.
메소드의 이름을 가지고 부가기능을 적용 대상 메소드를 선정하는 것이었다.
pattern이라는 메소드 이름 비교용 스트링 값을 DI받아서 부가기능 적용여부를 판별했다.

ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까?
MethodInterceptor에서 부가기능을 제공하고 있으니 그 안에서 판별하면 될 것 같지만 실제로는 불가능하다.
MethodInterceptor 오브젝트는 여러 프록시가 공유해서 사용할 수 있다. 그러기 위해서 MethodInterceptor 오브젝트는 타깃 정보를 갖고 있지 않도록 만들었다.
그런데 여기에다 트랜잭션 적용 대상 메소드 이름 패턴을 넣어주는 것은 곤란하다.
트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 MethodInterceptor에 특정 프록시만 적용되는 패턴을 넣으면 문제가 된다.
이 문제를 해결하기 위해서는 함께 두기 곤란한 성격이 다른 코드들을 분리해주면 된다.

MethodInterceptor는 InvocationHandler와 다르게 프록시가 클라이언트로부터 받는 요청을 일일이 전달받을 필요는 없다.
MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남겨주는 것이다.
대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣자
![[KakaoTalk_Photo_2025-08-15-19-50-00 001.jpeg]]
문제는 부가기능을 가진 InvocationHandler가 타깃과 메소드 선정 알고리즘 코드에 의존하고 있다는 점이다.
만약 타깃이 다르고 메소드 선정 방식이 다르다면 InvocationHandler 오브젝트를 여러 프록시가 공유할 수 없다.
타깃과 메소드 선정 알고리즘은 DI를 통해 분리할 수는 있지만 한번 빈으로 구성된 InvocationHandler 오브젝트는
오브젝트 차원에서 특정 타깃을 위한 프록시에 제한된다는 뜻이다.
그래서 InvocationHandler는 굳이 빈으로 등록하는 대신 TxProxyFactoryBean 내부에서 매번 생성하도록 만든것이다.
따라서 타깃 변경과 메소드 선정 알고리즘 변경 같은 확장이 필요하면 팩토리 빈 내의 프록시 생성코드를 직접 변경해야한다.
결국 확장에는 유연하게 열려 있지 못하고 관련 없는 코드의 변경이 필요할 수 있는 OCP 원칙을 잘 지키지 못하는 구조이다.

![[KakaoTalk_Photo_2025-08-15-19-50-00 002.jpeg]]
반면 ProxyFactoryBean은 두 가지 확장 기능을 활용하는 유연한 구조를 제공한다.

스프링은 부가기능을 제공하는 오브젝트를 어드바이스라고 부르고 메소드 선정 알고리즘을 담은 오브젝트를 포인트컷이라고 부른다.
어드바이스와 포인트컷은 모두 프록시에 DI로 주입되어 사용된다. 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 싱글톤 빈으로 등록이 가능하다.

프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지를 확인해달라고 요청한다.
포인트컷은 Pointcut 인터페이스를 구현해서 만들면 된다.
프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으면 MethodInterceptor 타입의 어드바이스를 호출한다.
어드바이스가 부가기능을 부여하는 중에 타깃 메소드의 호출이 필요하면 프록시로부터 전달받은 MethodInvocation 타입 콜백 오브젝트의 proceed()를 호출해주면 된다.

실제 위임 대상인 타깃 오브젝트의 레퍼런스를 갖고 있고 이를 이용해 타깃 메소드를 직접 호출하는 것은 프록시가 메소드 호출에 따라 만드는 Invocation 콜백의 역할이다.
재사용 가능한 기능을 만들어두고 바뀌는 부분(콜백 오브젝트와 메소드 호출정보)만 외부에서 주입해 이를 작업 흐름(부가기능 부여)중에 사용하도록 하는
전형적인 템플릿/콜백 구조이다.
어드바이스가 일종의 템플릿이 되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜백이 되는 것이다.

이제 MethodInterceptor로 만들었던 어드바이스와 함께 이름 패턴을 이용해 메소드를 선정하는 포인트컷까지 적용되는 학습 테스트를 만들어보자
![[KakaoTalk_Photo_2025-08-15-21-19-28 001.jpeg]]
포인트컷을 함께 등록할 때는 어드바이스와 포인트 컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야한다.

어드바이저 = 포인트 컷(메소드 선정 알고리즘) + 어드바이스(부가기능)

pointcutAdvisor() 테스트에서 사용한 NameMatchPointcut은 mappedName 프로퍼티 값을 이용해 메소드의 이름을 비교하는 방식으로 대상을 선정한다.
sayH* 라고 하면 sayH로 시작하는 메소드에만 선택해준다. 따라서 마지막 sayThankYou()는 포인트 컷에 의해 부가기능을 부여받지 않는다.

### ProxyFactoryBean 적용

**TransactionAdvice**
![[KakaoTalk_Photo_2025-08-15-21-19-28 002.jpeg]]
JDK 다이내믹 프록시의 InvocationHandler를 이용해서 만들었들 때보다 더 간결해졌다.
리플렉션을 통한 타깃 메소드의 호출 작업의 번거로움은 MethodInvocation 타입의 콜백을 이용한 덕분에 대부분 제거할 수 있다.
타깃 메소드가 던지는 예외도 InvocationTargetException으로 포장돼서 오는 것이 아니기 때문에 그대로 처리하면 된다.

**스프링 XML 설정파일**

어드바이스 빈 설정
```xml
<bean id="transactionAdvice" class="user.service.TransactionAdvice">
	<property name="transactionManager" ref="transactionManager" />
</bean>
```

포인트 컷 빈 설정
```xml
<bean id="transactionPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut">
	<property name="mappedName" value="upgrade*" />
</bean>
```

어드바이저 빈 설정
```xml
<bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
	<property name="advice" ref="transactionAdvice" />
	<property name="pointcut" ref="transactionPointcut" />
</bean>
```

ProxyFactoryBean 설정
```xml
<bean id="userService" class="org.springframework.aop.support.ProxyFactoryBean">
	<property name="target" ref="userServiceImpl" />
	<property name="InterceptorNames">
		<list>
			<value>transactionAdvisor</value>
		</list>
	</property>
</bean>
```

어드바이저는 InterceptorNames라는 프로퍼티를 통해 넣는다.
프로퍼티 이름이 advisor가 아닌 이유는 어드바이스와 어드바이저를 혼합해서 설정할 수 있도록 하기 위해서다.
그래서 property 태그의 ref 대신 list와 value를 통해 여러 개의 값을 넣을 수 있도록 하고 있다.
만약 모든 메소드에 트랜잭션이 필요하다면 advisor 대신 advice로 교체해서 넣어도 된다.(모든 메소드가 적용대상이라면 메소드 선정 알고리즘이 필요없기 때문)

이렇게 ProxyFactoryBean으로 변환이 끝났다.
코드는 간결해졌고 설정만 조금 추가했다. 어드바이스와 포인트컷은 여러 ProxyFactoryBean에서 재사용이 가능하다.
객체지향 설계에 걸맞는 모습이 나온것 같다

**어드바이스와 포인트컷의 재사용**
ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.
그 덕분에 독립적이며 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다.
이제 UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있다.
메소드의 선정을 위한 포인트컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록해주면 된다.
![[KakaoTalk_Photo_2025-08-15-22-05-56.jpeg]]
ProxyFactoryBean을 이용해서 많은 수의 서비스 빈에게 트랜잭션 부가기능을 적용했을 때의 구조이다.

트랜잭션 부가기능을 담은 transactionAdvice는 하나만 만들어서 싱글톤 빈으로 등록해주면 DI설정을 통해 모든 서비스에 적용이 가능하다.
메소드 선정 방식이 달라지는 경우에만 pointcut 설정을 따로 등록하고 Advisor로 조합해서 적용해주면 된다.