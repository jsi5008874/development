지금까지 해왔던 작업의 목표는 비즈니스 로직에 반복적으로 등장하는 트랜잭션 코드를 깔끔하고 효과적으로 분리해내는 것이다.
이렇게 분리해낸 트랜잭션 코드는 투명한 부가기능 형태로 제공돼야 한다.
투명하다는 건 부가기능을 적용한 후에도 기존 설계와 코드에는 영향을 주지 않는다는 뜻이다.
다른 코드에서는 그 존재가 보이지 않지만 메소드가 호출되는 과정에서 다이내믹하게 참여해서 부가기능을 제공해준다.
투명하기 때문에 언제든지 자유롭게 추가하거나 제거할 수도 있고 기존 코드는 항상 원래의 상태를 유지할 수 잇다.

### 자동 프록시 생성
투명한 부가기능을 적용하는 것을 해결했지만 해결 과제가 남아 있다.
프록시 팩토리 빈 방식의 접근 방법의 한계라고 생각했던 두 가지 문제가 있었다.
그중에서 부가기능이 타깃 오브젝트마다 새로 만들어지는 문제는 스프링 ProxyFactoryBean의 어드바이스를 통해 해결됐다.
남은 것은 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해주는 부분이다.
새로운 타깃이 등장했다고 해서 코드를 손댈 필요는 없어졌지만 설정은 매번 복붙하고 target 프로퍼티의 내용을 수정해야한다.
단순하고 쉬운일이지만 그만큼 실수하기도 쉽다.
target 프로퍼티를 제외하면 빈 클래스의 종류, 어드바이스, 포인트컷 설정이 동일하다.
이런 류의 중복은 더이상 제거할 방법이 없는 것일까?

**중복 문제의 접근 방법**
지금까지 다뤄봤던 반복적이고 기계적인 코드에 대한 해결책을 생각해보자
반복적인 위임 코드가 필요한 프록시 클래스 코드이다.
타깃 오브젝트의 위임 코드와 부가기능 적용을 위한 코드가 프록시가 구현해야하는 인터페이스 메소드마다 반복적으로 필요했다.
이는 단순한 분리와 DI와는 다른 독특한 방법으로 해결했다.
다이내믹 프록시라는 런타임 코드 자동생성 기법을 이용한 것이다. JDK의 다이내믹 프록시는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 런타임 시 내부적으로 만들어준다.
그 덕분에 개발자가 일일이 인터페이스 메소드를 구현하는 프록시 클래스를 만들어서 위임과 부가기능 코드를 중복해서 만들지 않아도 된다.

변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단이라는 부분은 코드 생성 기법을 이용하는 다이내믹 프록시 기술에 맡기고
변하는 부가기능 코드는 별도로 만들어서 다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한 것이다.
의미 있는 부가기능 로직인 트랜잭션 경계설정은 코드로 만들게 하고 기계적인 코드인 타깃 인터페이스 구현과 위임, 부가기능 연동 부분은 자동생성하게 한 것이다.

반복적인 프록시의 메소드 구현을 코드 자동생성 기법을 이용해 해결했다면 반복적인 ProxyFactoryBean 설정 문제는 설정 자동등록 기법으로 해결할 수 없을까?
또는 실제로 빈 오브젝트가 되는것은 ProxyFactoryBean을 통해 생성되는 프록시 그 자체이므로 프록시가 자동으로 빈으로 생성되게 할 수 없을까?
마치 다이내믹 프록시가 인터페이스만 제공하면 모든 메소드에 대한 구현 클래스를 자동으로 만들듯이 일정한 타깃 빈의 목록을 제공하면 자동으로 각 타깃 빈에 대한 프록시를 만들어주는 방법이 있다면 ProxyFactoryBean 타입 빈 설정을 매번 추가하는 수고를 덜 수 있다.

**빈 후처리기를 이용한 자동 프록시 생성기**
스프링은 OCP의 가장 중요한 요소인 유연한 확장이라는 개념을 스프링 컨테이너 자신에게도 다양한 방법으로 적용하고 있다.
스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분외에는 대부분 확장할 수 있도록 확장 포인트를 제공한다.
그중에서 관심을 가질 만한 부분이 BeanPostProcessor 인터페이스를 구현해서 만든 빈 후처리기다.
빈 후처리기는 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에 빈 오브젝트를 다시 가공할 수 있게 해준다.

스프링이 제공하는 빈 후처리기 중 하나인 DefaultAdvicorAutoProxyCreateor를 살펴보겠다.
이름에서 알 수 잇듯이 어드바이저를 이용한 자동 프록시 생성기이다.
빈 후처리기를 스프링에 적용하는 방법은 간단하다. 빈 후처리기 자체를 빈으로 등록하는 것이다.
스프링은 빈 후처리기가 빈으로 등록되어 있다면 빈 오브젝트가 생성될 때마다 빈 후처리기로 보내서 후처리 작업을 요청한다.
빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다.
심지어는 만들어진 빈 오브젝트 자체를 바꿔치기할 수도 있다.
따라서 스프링이 설정을 참고해서 만든 오브젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 것이 가능하다.
이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고 프록시를 빈으로 대신 등록할 수도 있다.
![[KakaoTalk_Photo_2025-08-26-16-39-06.jpeg]]

DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.
DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용대상인지 확인한다. 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게하고 만들어진 프록시에 어드바이저를 연결해준다.
빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다.
컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 시용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다.

**확장된 포인트 컷**
지금까지 포인트 컷이란 타깃 오브젝트의 메소드 중 어떤 메소드에 부가기능을 적용할지 선정해주는 역할이었다.
그런데 여기서는 포인트컷이 등록된 빈 중에서 어떤 빈에 프록시를 적용할지를 선택하고 있다.
포인트컷은 오브젝트 내의 메소드를 선택하는 것이 아니고 빈 오브젝트 자체를 선택하는 기능을 가졌다는 뜻일까?

사실 포인트컷은 두 가지 기능을 모두 갖고 있다.
```java
public interface Pointcut{
	Classfilter getClassFilter(); //프록시를 적용할 클래스인지 확인
	MethodMatcher getMethodMatcher(); //어드바이스를 적용할 메소드인지 확인
}
```
Pointcut 인터페이스를 살펴보면 클래스 필터와 메소드 매처 두 가지를 돌려주는 메소드를 갖고 있다.
실제 포인트컷의 선별 로직은 두 가지 타입의 오브젝트에 담겨 있다.

여태까지 ProxyFactoryBean에서 포인트컷을 사용할 때는 이미 타깃이 정해져 있기 때문에 포인트컷은 메소드만 선별하면 그만이었다.
만약 포인트컷 선정 기능을 모두 적용한다면 먼저 프록시를 적용할 클래스인지 판단하고 나서 적용 대상 클래스인 경우에는 어드바이스를 적용할 메소드인지 확인하는 식으로 동작한다.

ProxyFactoryBean에서는 굳이 클래스 레벨의 필터는 필요 없었지만 모든 빈에 대해 프록시 자동 적용 대상을 선별해야 하는 빈 후처리기인 DefaultAdvisorAutoProxyCreator는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트컷이 필요하다.

**포인트컷 테스트**
포인트컷의 기능을 간단한 학습 테스트로 확인해보자
앞에서 사용한 NameMatchPointcut은 클래스 필터 기능이 아예 없다고 했다. 사실 모든 클래스에 대해 OK 해버리는 있으나 마나 한 필터가 들어 있다. 이번엔 이 클래스를 확장해서 클래스도 고를 수 있도록 한다.
그리고 프록시 적용 후보 클래스를 여러 개 만들어두고 이 포인트컷을 적용한 ProxyFactoryBean으로 프록시를 만들도록 해서 과연 어드바이스가 적용되는지 아닌지를 확인한다.

![[KakaoTalk_Photo_2025-08-26-17-02-15.jpeg]]
포인트컷은 NameMatchMethodPointcut을 내부 익명 클래스 방식으로 확장해서 만들었다.
원래 모든 클래스를 다 받아주는 클래스 필터를 리턴하던 getClassFilter()를 오버라이드해서 이름이 HelloT로 시작하는 클래스만을 선정해주는 필터로 만들었다. 메소드 이름 선정기준은 기존에 사용한 것을 그대로 유지했다.

테스트는 세 가지 클래스에 대해 진행한다. 모두 기존에 있던 HelloTarget 클래스를 그대로 상속한거라 메소드는 동일하다.
이 세개의 클래스에 동일한 포인트컷을 적용했다. 메소드 선정 기준으로만 보자면 두 개의 메소드에는 어드바이스를 적용하고 마지막 것은 적용되지 않으면 된다.
하지만 두 번째 HelloWorld라는 클래스는 클래스 필터에서 이미 탈락해버리기 때문에 메소드 이름과 무관하게 모든 메소드가 어드바이스 적용에서 제외된다.
세개의 클래스를 포인트컷을 적용할 타깃 오브젝트로 각각 등록하고 각 메소드에 대해 어드바이스 적용 여부를 확인한다.
클래스 필터를 통과하지 못하는 HelloWorld 클래스로 만든 타깃 오브젝트는 모든 메소드에 어드바이스가 적용되지 않는다.

포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용해도 부가기능은 적용되지 않는다.

### DefaultAdvisorAutoProxyCreator의 적용

**클래스 필터를 적용한 포인트컷 작성**
메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 만들 것이다.
![[KakaoTalk_Photo_2025-08-27-12-52-58.jpeg]]

**어드바이저를 이용하는 자동 프록시 생성기 등록**
적용할 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다.
그리고 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다.
빈 클래스가 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기 한다.
원래 빈 오브젝트는 프록시 뒤에 연결돼서 프록시를 통해서만 접근 가능하게 바뀌는 것이다.
따라서 타깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 될 것이다.

DefaultAdvisorAutoProxyCreator 등록
```xml
<bean class= "org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" />
```
이 빈 정의에는 특이하게 id 애트리뷰트가 없고 class만 존재한다. 다른 빈에서 참조되거나 코드에서 빈 이름으로 조회될 필요가 없는 빈이라면 아이디를 등록하지 않아도 무방하다.

**포인트컷 등록**
```xml
<bean id="transactionPointcut"
	class="springbook.service.NameMatchClassMethodPointcut">
	<property name="mappedClassName" value="*ServiceImol" /> #클래스 이름 패턴
	<property name="mappedName" value="uprade*" />
</bean>
```
기존 포인트컷 설정을 삭제하고 새로 만든 클래스 필터 지원 포인트컷을 빈으로 등록

**어드바이스와 어드바이저**
어드바이스인 transactionAdvice 빈의 설정은 수정할 게 없다. 어드바이저인 transactionAdvisor 빈도 수정할 필요는 없다.
하지만 어드바이저로서 사용되는 방법이 바뀌었다는 사실은 기억해두자.
이제는 ProxyFactoryBean으로 등록한 빈에서처럼 transactionAdvisor를 명시적으로 DI 하는 빈은 존재하지 않는다.
대신 어드바이저를 이용하는 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator에 의해 자동수집되고 프록시 대상 선정 과정에 참여하며 자동 생성된 프록시에 다이내믹하게 DI 돼서 동작하는 어드바이저가 된다.

**ProxyFactoryBean 제거와 서비스 빈의 원상복구**
프록시를 도입했던 때부터 아이디를 바꾸고 프록시에 DI 돼서 간접적으로 사용돼야 했던 userServiceImpl 빈의 아이디를 이제는
userService로 되돌려 놓을 수 있다. 더 이상 명시적인 프록시 팩토리 빈을 등록하지 않기 때문이다.
마지막으로 남았던 ProxyFactoryBean 타입의 빈은 삭제해버려도 좋다.

프록시 팩토리 빈을 제거한 후 빈 설정
```xml
<bean id="userService" class="springbook.service.UserServiceImpl">
	<property name="userDao" ref="userDao" />
	<property name="mailSender" ref="mailSender" />
</bean>
```


### 포인트컷 표현식을 이용한 포인트컷
지금까지 사용했던 포인트컷은 메소드의 이름과 클래스의 이름 패턴을 클래스 필터, 메소드 매처로 비교해서 선정했다.
일일이 클래스 필터와 메소드 매처를 구현하거나 스프링이 제공하는 필터, 매처 클래스를 가져와 프로퍼티를 설정하는 방식이었다.
지금까지는 단순한 이름을 비교하는 일이 전부 였지만 이보다 더 복잡하고 세밀한 기준을 이용해 클래스나 메소드를 선정하려면 어떻게 해야할까?

스프링은 아주 간단하고 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공한다.
정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법이다.
이것을 포인트컷 표현식(pointcut expression)이라 부른다.

**포인트컷 표현식**
포인트컷 표현식을 지원하는 포인트컷을 적용하려면 AspextJExpressionPointcut 클래스를 사용하면 된다.
AspextJExpressionPointcut은 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다.
포인트컷 표현식은 자바의 RegEx 클래스가 지원하는 정규식처럼 간단한 문자열로 복잡한 선정조건을 쉽게 만들 수 있다.
스프링이 사용하는 포인트컷 표현식은 AspectJ라는 유명한 프레임워크에서 제공하는 것을 가져와 일부 문법을 확장해서 사용한다.

학습테스트를 만들어 표현식 사용법을 알아보자

![[KakaoTalk_Photo_2025-08-27-14-23-22 001.jpeg]]
포인트컷의 선정 후보가 될 여러 개의 메소드를 가진 클래스
target 클래스는 5개의 메소드를 갖고 있다. 이 중 처음 4개는 TargetInterface 인터페이스에 정의된 메소드를 구현한 것이고 마지막 메소드는 Target 클래스에서 정의한 것이다. 포인트컷 표현식을 이용해서 원하는 메소ㅓ드만 선정하는 방법을 알아볼 것이다.

![[KakaoTalk_Photo_2025-08-27-14-23-22 002.jpeg]]
이제 두 개의 클래스와 총 6개의 메소드를 대상으로 포인트컷 표현식을 적용해보자

**포인트컷 표현식 문법**
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다. 
포인트컷 지시자 중에서 가장 대표적으로 사용되는 것은 execution()이다.
![[KakaoTalk_Photo_2025-08-27-14-23-22 003.jpeg]]
execution()  지시자를 사용한 포인트컷 표현식의 문법구조는 기본적으로 위 사진과 같다.
[] 대괄호는 옵션항목이기 때문에 생략이 가능하다는 의미이며, ||는 or 조건을 뜻한다.
메소드의 풀 시그니처를 문자열로 비교하는 개념이라고 생각하면 편하다.
리플렉션으로 Target 클래스의 minus() 메소드의 풀 시그니처를 가져와 비교해보면 이해하기 쉽다.

```java
system.out.println(Target.class.getMethod("minus", int.class, int.class));

//출력 내용
public int springbook.learningtest.spring.pointcut.Target.minus(int,int) throws java.lang.RuntimeException
```
출력 된 내용을 하나씩 살펴보자

public
접근 제한자로 포인트컷 표현식에서는 생략할 수 잇다.

int
리턴 값의 타입을 나타내는 패턴, 리턴 값의 타입 패턴은 필수항목이다. 생략 불가

springbook.learningtest.spring.ponintcut.Target
패키지와 타입 이름을 포함한 클래스의 타입 패턴으로 생략 가능하다.

minus
메소드 이름 패턴으로 필수 항목이다.

(int, int)
메소드 파라미터의 타입 패턴 파라미터가 없는 메소드를 지정하고 싶다면 ()로 적는다.
필수 항목

throws java.lang.RuntimeException
예외 이름에 대한 타입 패턴, 생략 가능하다.

이렇게 메소드 오브젝트를 출력했을 때 나오는 메소드 시그니처와 동일한 구조를 가지고 비교하는 것이기 때문에 이해가 어렵지 않다.
Target 클래스의 minus()메소드만 선정해주는 포인트컷 표현식을 만들고 이를 검증해보는 테스트를 작성해보자.
![[KakaoTalk_Photo_2025-08-27-14-52-13 001.jpeg]]
![[KakaoTalk_Photo_2025-08-27-14-52-13 002.jpeg]]

포인트컷 표현식은 메소드 시그니처를 execution() 안에 넣어서 작성한다. execution()은 메소드를 실행에 대한 포인트컷이라는 의미다.

먼저 Target 클래스의 minus() 메소드에 대해 테스트를 해본다. 포인트컷의 선정 방식은 클래스 필터와 메소드 매처를 각각 비교해보는 것이다. 두 가지 조건을 모두 만족시키면 해당 메소드는 포인트컷의 선정 대상이 된다.

Tartget 클래스의 다른 메소드를 비교해본다. 클래스, 파라미터 등은 모두 통과하겠지만 메소드 이름과 예외 패턴이 포인트컷 표현식과 일치하지 않기 때문에 결과는 false다.

Bean.class의 메소드에 대해 테스트해보면 당연히 클래스부터 맞지 않으니 포인트컷 적용결과는 false다.

**포인트컷 표현식 테스트**
필수가 아닌 항목인 접근제한자, 클래스 타입, 예외 패턴은 생략할 수 있다.
```java
execution(int minus(int, int))
```
옵션 항목을 제거하니 간결해졌다. 단, 생략한 부분은 모든 경우를 다 허용하도록 되어 있기 떄문에 이 포인트컷 표현식은 어떤 접근제한자를 가졌든 어떤 클래스에 정의 됐든 어떤 예외를 던졌든 상관없이 정수 값을 리턴하고 두 개의 정수형 파라미터를 갖는 minus 라는 이름의 모든 메소드를 선정하는 좀 더 느슨한 포인트컷이 됐다.

리턴 값의 타입에 대한 제한을 없애고 어떤 리턴 타입일 가졌든 상관없이 선정하도록 하려면 * 와일드카드를 사용하면 된다.
```java
execution(* minus(int, int))
```

또 파라미터의 개수와 타입을 무시하려면 ()안에 ..을 넣어준다.
```java
execution(* minus(..))
```

만약 모든 선정조건을 다 없애고 모든 메소드를 허용하는 포인트컷이 필요하다면 메소드 이름도 와일드 카드로 바꾼다.
```java
execution(* *(..))
```

**포인트컷 표현식을 이용하는 포인트컷 적용**
AspectJ 포인트컷 표현식은 메소드를 선정하는데 편리하게 쓸 수 있는 강력한 표현식 언어이다.
포인트컷 표현식은 메소드의 시그니처를 비교하는 방식인 execution() 외에도 몇 가지 표현식 스타일이 있다.
대표적으로 빈의 이름으로 비교하는 bean()이 있다.
```java
bean(* Service)
```
이렇게 쓰면 아이다가 service로 끝나는 모든 빈을 선택한다.
또 특정 애노테이션 타입, 메소드, 파라미터에 적용되어 있는 것을 보고 메소드를 선정하는 포인트컷을 만들 수 있다.

이제 포인트컷 표현식을 적용해보자
기존 포인트컷 빈의 프로퍼티 선언에 담긴 포인트컷 선정조건을 다시 살펴보자
```xml
<property name="mappedClassName" value="*ServiceImpl" />
<property name="mappedName" value="upgrade*" />
```
클래스 이름과 메소드 이름에 대한 패턴으로 이루어져 있다.
이걸 포인트컷 표현식으로 만들어보자

```xml
<bean id="transactionPointcut" class="org.springframework.aop.AspectJExpressionPointcut">
	<property name="expression" value="execution(* *..*ServiceInpl.upgrade*(..))" />
</bean>
```
AspectJExpressionPointcut 빈을 등록하고 expression 푸로퍼티에 넣어주면 된다.
클래스 이름은 ServiceImpl로 끝나고 메소드 이름은 upgrade로 시작하는 모든 클래스에 적용되도록 하는 표현식이다.

**타입 패턴과 클래스 이름 패턴**
앞에서 사용했던 단순한 클래스 이름 패턴과 포인트컷 표현식에선 사용하는 타입 패턴은 중요한 차이점이 있다.

포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴이라는 점이다.
TestUserService의 클래스 이름은 TestUserService일 뿐이지만 타입을 따져보면 TestUserService 클래스이자 슈퍼 클래스인 UserServiceImpl, 구현 인터페이스인 UserService 세 가지가 모두 적용된다.
즉 TestUSerService 클래스로 정의된 빈은 UserServiceImpl 타입이기도 하고 그로인해 ServiceImpl로 끝나는 타입 패턴을 충족시키는 것이다.

포인트컷 표현식의 타입 패턴 항목을
```java
*..UserService
```
이렇게 직접 인터페이스 이름을 명시해도 두 개의 빈이 모두 선정된다.
두 클래스 모두 UserService 인터페이스를 구현하고 있기 때문이다.

### AOP란 무엇인가?
비즈니스 로직을 담은 UserService에 트랜잭션을 적용해온 과정을 정리해보자

**트랜잭션 서비스 추상화**
트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 생긴 첫 번째 문제는 특정 트랜잭션 기술에 종속되는 코드가 돼버린다는 것이었다. JDBC의 로컬 트랜잭션 방식을 적용한 코드를 JTA를 이용한 글로벌/분산 트랜잭션 방식으로 바꾸려면 모든 트랜잭션 적용 코드를 수정해야한다는 심각한 문제점이 발견됐다.
그래서 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법을 적용했다. 이 덕분에 비즈니스 로직 코드는 트랜잭션을 어떻게 처리해야 한다는 구체적인 방법과 서버환경에서 종속되지 않는다. 구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이내믹하게 연결해준다는 DI를 활용한 전형적인 접근 방법이었다.
트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지는 남기고 그것을 어떻게 하는지를 분리한 것이다.

**프록시와 데코레이터 패턴**
트랜잭션을 어떻게 다룰 것인가는 추상화를 통해 코드에서 제거했지만 여전히 비즈니스 로직 코드에는 트랜잭션을 적용하고 있다.
트랜잭션이라는 부가기능을 어디에 적용할 것인가는 여전히 코드에 노출시켜야 했다. 문제는 트랜잭션은 거의 대부분 비즈니스 로직을 담은 메소드에 필요하다는 점이다. 게다가 트랜잭션의 경계설정을 담당하는 코드의 특성 때문에 단순한 추상화와 메소드 추출 방법으로는 더 이상 제거할 방법이 없었다.

그래서 도입한 것이 바로 DI를 이용해 데코레이터 패턴을 적용하는 방법이었다.
클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고 데코레이터 패턴을 적용해서 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만들었다.
트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨서 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었다.
그래서 클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 됐다.
결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고 독립적으로 로직을 검증하는 고립된 단위 테스트를 만들 수도 있게 됐다.

**다이내믹 프록시와 프록시 팩토리 빈**
프록시를 이용해서 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거할 수 있었지만 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업이 오히려 큰 짐이 됐다. 트랜잭션 기능을 부여하지 않아도 되는 메소드 조차 프록시로서 위임 기능이 필요하기 때문에 일일이 모두 구현해줘야 했다.

그래서 프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용했다.
그 덕분에 프록시 클래스 작성 부담도 덜고 부가기능 부여 코드가 중복되는 문제도 일부 해결 할 수 있었다. 일부 메소드에만 트랜잭션을 적용해야 하는 경우 메소드를 선정하는 패턴 등을 이용할 수도 있었다. 하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제를 해결하지 못했다.

JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI를 도입했다. 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용할 수 있게 됐다.

**자동 프록시 생성 방법과 포인트컷**
트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담이 남아 있었다.
이를 해결하기 위해서 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다. 프록시를 적용할 대상을 일일이 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다. 결국 트랜잭션 부가기능을 어디에 적용하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다. 처음에는 클래스와 메소드 선정 로직을 담은 코드를 직접 만들어서 포인트컷으로 사용했지만 최종적으로는 포인트컷 표현식이라는 좀 더 편리하고 깔끔한 방법을 활용해서 간단한 설정만으로 적용 대상을 손쉽게 선택할 수 있게 됐다.

**부가기능 모듈화**
관심사가 같은 코드를 분리해 한데 모으는 것은 소프트웨어 개발의 가장 기본 원칙이다.
코드를 분리하고 한데 모으고 인터페이를 도입하고 DI를 통해서 런타임 시에 의존 관계를 만들어줌으로써 대부분의 문제를 해결할 수 있었다. 하지만 트랜잭션 적용 코드는 기존에 써왔던 방법으로 완벽하게 모듈화 할 수 없다.
왜냐하면 트랜잭션 경계설정 기능은 다른 모듈의 코드에 부가적으로 부여되는 기능이라는 특징이 있기 때문이다. 그래서 트랜잭션 코드는 한데 모을 수 없고 애플리케이션 전반에 여기저기 흩어져 있다. 따라서 트랜잭션 기능을 모듈화하려면 특별한 기법이 필요하다.
다이내믹 프록시, 빈 후처리 기술과 같은 기술말이다.

트랜잭션 같은 부가기능들은 독립적인 방식으로 존재할 수 없기 때문에 핵심기능과 같은 방식으로는 모듈화하기 힘들다.
트랜잭션 부가기능이란 트랜잭션 기능을 추가해줄 다른 대상, 즉 타깃이 존재해야만 의미가 있다. 따라서 각 기능을 부가할 대상인 각 타깃의 코드 안에 침투하거나 긴밀하게 연결되어 있어야한다.
그래서 독립적으로 존재하기 어렵다는 것이다.

그래서 많은 개발자들은 이런 부가기능을 어떻게 독립적인 모듈로 만들 수 있을까 고민했다. 지금까지 본 DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리 등등 여러 기법들이 그 해결방안이다.
이로인해 부가기능도 모듈화가 가능해진것이다.

**AOP: 애스펙트 지향 프로그래밍**
부가기능 모듈화 작업은 기존의 객체지향 설계 패러다임과는 구분되는 특징이 있다.
그래서 이런 부가기능 모듈을 객체지향 기술에서 주로 사용하는 오브젝트와는 다르게 특별한 이름으로 부르기 시작했다.
그것이 바로 애스펙트(aspect)다. 애스펙트란 그 자체로 애플리케이션의 핵심 기능을 담고 있지는 않지만 애플리케이션을 구성하는 중요한 한 가지 요소이고 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가르킨다.
애스펙트는 부가될 기능을 정의한 코드인 어드바이스와 어드바이스를 어디에 적용할지를 결정하는 포인트컷을 가지고 있다.

![[KakaoTalk_Photo_2025-09-01-14-55-37.jpeg]]
왼쪽은 애스펙트로 부가기능을 분리하기 전의 상태다. 핵심기능은 깔끔하게 모듈화되어 있지만 부가기능이 핵심기능의 모듈에 침투해 들어가면서 설계와 코드가 모두 지저분해졌다. 트랜잭션 경계설정 코드를 처음 사용자 관리 서비스 클래스에 추가했을 때를 생각해보자.
핵심기능을 담은 코드는 부가기능인 트랜잭션 코드와 함께 섞여 있어서 핵심기능인 사용자 관리 로직을 파악하고 수정하고 테스트하기 불편했다. 트랜잭션 외에도 다양한 부가기능을 모두 넣으면 아마도 핵심기능은 부가기능 코드에 가려서 보이지 않을지도 모른다.

오른쪽 그림은 이렇게 핵심기능 코드 사이에 침투한 부가기능을 독립적인 모듈인 애스펙트로 구분해낸 것이다. 2차원적인 평면 구조에서는 어떤 설계 기법을 동원해도 해결할 수 없었던 것을 3차원의 다면체 구조로 가져가면서 각각 성격이 다른 부가기능은 다른 면에 존재하도록 만들었다. 이렇게 독립된 측면에 존재하는 애스펙트로 분리한 덕에 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 된 것이다.

런타임 시에는 왼쪽의 그림처럼 부가기능 애스펙트는 자기가 필요한 위치에 다이내믹하게 참여할 것이다. 하지만 설계와 개발은 오른쪽 그림처럼 다른 특성을 띤 애스펙드들을 독립적인 관점으로 작성하게 할 수 있다.

이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍(Aspect Oriented Programming) 또는 약자로 AOP라고 부른다.
AOP는 OOP를 돕는 보조적인 기술이지 완전히 대체하는 새로운 개념은 아니다.
AOP는 애스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것이다.

### AOP 적용기술

**프록시를 이용한 AOP**
스프링은 IOC/DI 컨테이너, 다이내믹 프록시 등 다양한 기술을 조합해 AOP를 지원하고 있다.
그중 가장 핵심은 프록시를 이용했다는 것이다.

프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주도록 만들었다.
따라서 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않는다.

프록시 방식을 사용했기 때문에 메소드 호출 과정에 참여해서 부가기능을 제공해주게 되어 있다. 어드바이스가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시로부터 메소드 요청정보를 전달받아서 타깃 오브젝트의 메소드를 호출한다. 타깃의 메소드를 호출하는 전후에 다양한 부가기능을 제공할 수 있다.

독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고 있는게 바로 프록시다. 그래서 스프링 AOP는 프록시 방식의 AOP라고 할 수 있다.

**바이트코드 생성과 조작을 통한 AOP**
프록시 방식이 아닌 AOP도 있는데 AOP 기술의 원조이자 가장 강력한 AOP 프레임워크인 AspectJ이다.
AspectJ는 프록시처럼 간접적인 방법이 아니라 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방식을 이용한다.
부가기능을 넣는다고 타깃 오브젝트의 소스코드를 수정할 수는 없으니 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.

그렇다면 AspectJ는 프록시 같은 방법이 있음에도 컴파일된 클래스 파일 수정이나 바이트코드 조작 같은 복잡한 방법을 사용할까?

첫 번째는 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문이다. 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 AOP 적용이 가능하다.

두 번째는 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문이다. 프록시를 AOP의 핵심 매커니즘으로 사용하면 부가기능을 부여할 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한된다. 하지만 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다.
타깃 오브젝트가 생성되는 순간 부가기능을 부여해주고 싶을 수도 있다. 하지만 프록시 방식에서는 이런 작업이 불가능하다.
private 메소드의 호출, 스태틱 메소드 호출이나 초기화 등에 부가기능을 부여하려고 하면 클래스 바이트코드를 직접 조작해서 타깃 오브젝트나 호출 클라이언트의 내용을 수정하는 것밖에는 방법이 없다.

대부분 AOP를 적용하는데 프록시 방식의 스프링 AOP로도 충분하지만 특별한 AOP 요구사항이 생겨서 스프링의 프록시 AOP 수준을 넘어서는 기능이 필요하다면 AspectJ를 사용하면 된다.

### AOP의 용어

**타깃**
타깃은 부가기능을 부여할 대상
핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.

**어드바이스**
어드바이스는 타깃에게 제공할 부가기능을 담은 모듈
어드바이스는 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다.

**조인포인트**
조인 포인트(join point)란 어드바이스가 적용될 수 있는 위치를 말한다. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐이다. 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 된다.

**포인트컷**
포인트컷이란 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다.
스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있다.

**프록시**
프록시는 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트다.
DI를 통해 타깃 대신 클라이언트에게 주입되며 클라이언트의 메소드 호출을 대신 받아서 타깃에게 위임해주고 그 과정에서 부가기능을 부여한다. 스프링은 프록시를 이용해 AOP를 지원한다.

**어드바이저**
어드바이저는 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다. 어드바이저는 어떤 부가기능을 어디에 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈이다. 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보로 활용한다. 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고 일반적인 AOP에서는 사용되지 않는다.

**애스펙트**
OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈이다. 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.


### AOP 네임스페이스

스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 애플리케이션 로직을 담은 UserService, UserDao 빈과는 성격이 다르다.
비즈니스 로직이나 DAO처럼 애플리케이션의 일부 기능을 담고 있는 것도 아니고 DataSoure 빈처럼 DI를 통해 애플리케이션 빈에서 사용되는 것도 아니다.
이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
스프링의 프록시 방식 AOP를 적용하려면 최소 네 가지 빈을 등록해야 한다.

1. 자동 프록시 생성기
	 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을 DI 하지 않고 자신도 DI 되지 않으며
	 독립적으로 존재한다. 따라서 id도 굳이 필요하지 않다.
	 애플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에 빈 후처리기로 참여한다.
	빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.

2. 어드바이스
	부가기능을 구현한 클래스를 빈으로 등록한다. TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용

3. 포인트컷
	스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다.

4. 어드바이저
	스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록해서 사용한다. 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능이 없다. 자동 프록시 생성기에 의해 자동 검색되어 사용된다.

이 중에서 부가기능을 담은 코드로 만든 어드바이스를 제외한 나머지 세 가지는 모두 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것이다.

**AOP 네임스페이스**
스프링에서는 이렇게 AOP를 위해 기계적으로 적용하는 빈들을 간편한 방법으로 등록할 수 있다.
스프링은 AOP와 관련된 태그를 정의해둔 aop 스키마를 제공한다. aop 스키마에 정의된 태그는 별도의 네임스페이스를 지정해서 디폴트 네임스페이스의 bean 태그와 구분해서 사용할 수 있다.

![[KakaoTalk_Photo_2025-09-03-15-42-25 001.jpeg]]
이렇게 설정파일에 aop 네임스페이스를 선언한다.

![[KakaoTalk_Photo_2025-09-03-15-42-25 002.jpeg]]
```
<aop:config>, <aop:pointcut>, <aop:advisor>
```
세 가지 태그를 정의해두면 그에 따라 세 개의 빈이 자동으로 등록된다.
포인트컷, 어드바이저, 자동 포인트컷 생성기 같은 특별한 기능을 가진 빈들은 별도의 스키마에 정의된 전용 태그를 사용해 정의해주면 편리하다. 애플리케이션을 구성하는 컴포넌트 빈과 컨테이너에 의해 사용되는 기반 기능을 지원하는 빈은 구분이 되는 것이 좋다.

bean 태그를 사용했을 때와 비교해보면 이해하기도 쉬울뿐더러 코드의 양도 대폭 줄었다.

**어드바이저 내장 포인트컷**
AspectJ 포인트컷 표현식을 활용하는 포인트컷은 스트링으로 된 표현식을 담은 expression 프로퍼티 하나만 설정해주면 사용할 수 있다. 또 포인트컷은 어드바이저에 참조돼야만 사용된다. 그래서 aop 스키마 전용 태그를 사용하는 경우에는 굳이 포인트컷을 독립적인 태그로 두고 어드바이저 태그에서 참조하는 대신 어드바이저 태그와 결합하는 방법도 가능하다.

```xml
<aop:config>
	<aop:advisor advice-ref="transactionAdvice"
		pointcut="execution(* *..*Serviceimpl.upgrade*(..))" />
 </aop:config>
```
태그가 하나 줄어서 더욱 간결해졌다.
하지만 하나의 포인트컷을 여러 개의 어드바이저에서 공유하려는 경우에는 포인트컷을 독립적인 태그로 등록해야한다.