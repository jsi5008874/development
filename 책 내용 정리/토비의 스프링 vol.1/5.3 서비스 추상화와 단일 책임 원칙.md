
### 수직, 수평 계층구조와 의존관계
UserDao와 UserService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고,
서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만들었다.
같은 계층에서 수평적인 분리라고 볼 수 있다.

트랜잭션 추상화는 이와는 좀 다르다.
애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리

![[KakaoTalk_Photo_2025-06-26-20-17-03.jpeg]]
지금까지 만들어진 사용자 관리 모듈의 의존관계

UserDao와 UserService는 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮아졌다.
데이터 액세스 로직이 바뀌거나, 데이터 액세스 기술이 바뀐다해도 UserService에게는 영향이 없다.
서로 독립적으로 확장 될 수 있다는 뜻이다.
(수평적 분리)

또 UserDaosms DB 연결을 생성하는 방법에 대해 독립적이다.
DataSource 인터페이스와 DI를 통해 추상화된 방식으로 로우레벨의 DB 연결 기술을 사용하기 때문이다.
JDBC를 사용하든 JTA를 사용하든 UserDao의 코드는 조금도 변하지 않는다.
(수직적 분리)

이는 UserService도 마찬가지이다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며
서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는데는 스프링의 DI가 중요한 역할을 했다.
**DI의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는데 있다.**

### 단일 책임 원칙
하나의 모듈은 한 가지 책임을 가져야 한다는 의미
하나의 모듈이 바뀌는 이유는 한 가지여야한다고 설명할 수도 있다.

UserService에 JDBC Connection의 메소드를 직접 사용하는 트랜잭션 코드가 들어 있었을 때를 생각해보자
UserService는 사용자 레벨을 어떻게 관리할 것인가, 어떻게 트랜잭션을 관리할 것인가 두 가지 책임을 갖고 있었다.
그렇다는건 UserService가 수정되는 이유가 두 가지라는 뜻이다.

사용자 레벨 업그레이드 정책과 같은 사용자 관리 로직이 바뀐다면 당연히 UserService 코드도 바뀌어야하지만
서버환경이 바뀌어서 트랜잭션 기술을 JDBC에서 JTA로 변경해야한다면?
이 때도 UserService의 코드는 변경될 것이다.
그 이유가 단일 책임 원칙을 지키지 못했기 때문이다.

하지만 트랜잭션 서비스 추상화를 도입한 후에는 사용자 관리 로직이 바뀌지 않는한 UserService의 코드 수정은 없다.

### 단일 책임 원칙의 장점
어떤 변경이 필요할 때 수정 대상이 명확해진다.
기술이 바뀌면 기술 계층과의 연동을 담당하는 추상화 계층의 설정만 바꿔주면 된다.
데이터 액세스 로직이 바뀌면 UserDao만 변경하면 된다.

지금은 모듈이 하나라서 큰 이점이 아닌것 같지만 DAO가 수백개가 되고 Service 클래스도 그만큼 많다면?
수백번 수정해야할 것을 한 번만 수정하면 된다.

단지 수정하는 작업량만의 문제가 아니다.
많은 코드를 수정하는 과정에선 그만큼 실수가 일어날 확률이 높다.
개발 중이 아니라 운영 중인 코드에 이런 수정이 필요하다면 엄청난 부담이 될 것이다.

그래서 적절하게 책임과 관심이 다른 코드를 분리하고 기술/환경을 분리하는 등의 작업은
갈수록 복잡해지는 엔터프라이즈 애플리케이션에서 반드시 필요하다.

