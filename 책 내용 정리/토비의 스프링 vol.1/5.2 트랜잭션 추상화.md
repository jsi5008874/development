
## 트랜잭션 경계 설정

애플리케이션 내에서 트랜잭션이 시작되고 끝나는 이치를 트랜잭션의 경계라고 부른다.
복잡한 로직의 흐름 사이에서 정확하게 트랜잭션 경계를 설정하는 일은 매우 중요하다.

### JDBC 트랜잭션의 트랜잭션 경계설정

예제
```java
connection c = dataSource.getConnection();

c.setAutoCommit(false); // 트랜잭션 시작
try{
	PreparedStatement st1 = c.prepareStatement("Update users ....");
	st1.executeUpdate();

	PreparedStatement st2 = c.prepareStatement("Delete users ....");
	st2.executeUpdate();

	c.commit(); // 트랜잭션 커밋
}
catch(Exception e){
	c.rollback()l //트랜잭션 롤백
}
c.close();
```

JDBC 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서 일어난다.
트랜잭션 시작과 종료는 Connection 오브젝트를 통해 이뤄지기 때문이다.

setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로
트랜잭션을 종료하는 작업을 트랜잭션 경계설정이라 한다.

### UserService와 UserDao의 트랜잭션 문제
![[KakaoTalk_Photo_2025-06-22-21-57-14.jpeg]]
upgradeLevels()에서 세 번에 걸쳐 UserDao의 update()를 호출했다고 가정

UserDao는 jdbcTemplate을 통해 매번 새로운 DB 커넥션과 트랜잭션을 만들어 사용한다.
첫 번째 작업이 성공했다면 그 결과는 이미 트랜잭션이 종료되면서 커밋됐기 때문에 두 번째 update()를 호출하는 시점에서
오류가 발생해 중단된다 해도 첫 번째 트랜잭션의 결과는 DB에 그대로 남는다.
(서로 다른 트랜잭션이기 때문에)

DAO 메소드에서 DB 커넥션을 매번 만들기 때문에 위에서 말한 여러 작업을 한 트랜잭션에 묶는일이 불가능한 상황이다.

### 비즈니스 로직 내의 트랜잭션 경계설정
이를 해결하기 위해서 UserService쪽으로 트랜잭션 경계설정 작업을 가져와야한다.
프로그램의 흐름을 볼 때 upgradeLevels() 메소드의 시작과 함께 트랜잭션이 시작하고
메소드를 빠져나올 때 트랜잭션이 종료돼야 하기 때문이다.

트랜잭션 경계를 upgradeLevels() 메소드 안에 두려면 DB 커넥션도 이 메소드 안에서 만들고 종료시킬 필요가 있다.

![[KakaoTalk_Photo_2025-06-22-22-31-53 001.jpeg]]
여기서 생성된 Connection 오브젝트를 가지고 데이터 액세스 작업을 진행하는 코드는 UserDao의 update() 메소드 안에 있어야한다.

트랜잭션 때문에 DB 커넥션과 트랜잭션 관련 코드는 Service로 가져왔지만 순수한 데이터 액세스 로직은
UserDao에 둬야 하기 때문이다.

UserDao의 update()는 반드시 upgradeLevels() 메소드의 커넥션을 사용해야한다.
그래야만 같은 트랜잭션 안에서 동작하기 때문이다.

그래서 UserService에서 만든 Connection 오브젝트를 UserDao에 파라미터로 전달해준다.

**Connection 오브젝트를 전달받는 UserDao 메소드**
```java
public interface UserDao{
	public void add(Connection c, User user);
	public void update(Connection c, User user1);
	.....
}
```


그리고 UserService의 upgradeLevels()는 UserDao의 update()를 직접 호출하지 않는다.
UserDao를 사용하는 것은 사용자별로 업그레이드를 해주는 upgradeLevel() 메소드이다.
아래의 사진 처럼 UserService 메소드 사이에도 같은 Connection 오브젝트를 사용하도록 파라미터로 전달
![[KakaoTalk_Photo_2025-06-22-22-31-53 002.jpeg]]

### UserService 트랜잭션 경계설정의 문제점

첫 번째는 DB 커넥션을 비록한 리소스의 깔끔한 처리를 가능하게 했던 JDBCTemplate을 더 이상 활용하지 못한다.
결국 JDBC API를 직접 사용하는 초기 방식으로 돌아왔다.

두 번째는 DAO의 메소드와 비즈니스 로직을 담은 Service의 메소드에 커넥션 파라미터가 추가된다는 점이다.
upgradeLevels()에서 사용하는 메소드의 어딘가에서 DAO를 필요로 한다면 그 사이 모든 메소드에 걸쳐서
커넥션 파라미터가 추가되어야 한다.

세 번째는 Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면 
UserDao는 더 이상 데이터 액세서 기술에 독립적일 수 없다.
JPA나 하이버네이트로 변경하면 Connection 대신 EntityManager나 Session 오브젝트를 UserDao 메소드가
전달 받도록 변경해야하는데 기껏 인터페이스로 분리해 DI 했던 수고가 물거품이 된다.

