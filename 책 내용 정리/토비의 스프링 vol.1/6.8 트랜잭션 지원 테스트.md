
### 선언적 트랜잭션과 트랜잭션 전파 속성
트랜잭션을 정의할 때 지정할 수 있는 트랜잭션 전파 속성은 매우 유용한 개념이다.
예를 들어 REQUIRED로 전파 속성을 지정해줄 경우 앞에서 진행 중인 트랜잭션이 있으면 참여하고 없으면 새로운 트랜잭션을 시작해준다. REQUIRED 전파 속성을 가진 메소드를 결합해서 다양한 크기의 트랜잭션 작업을 만들 수 있다. 트랜잭션 적용 때문에 불필요하게 코드를 중복하는 것도 피할 수 있으며 애플리케이션을 작은 기능 단위로 쪼개서 개발할 수가 있다.

예를 들어 사용자 등록 로직을 담당하는 UserService의 add() 메소드를 생각해보자.
add() 메소드는 트랜잭션 속성이 디폴트로 지정되어 있으므로 트랜잭션 전파 방식은 REQUIRED다. 만약 add() 메소드가 처음 호출되는 서비스 계층의 메소드라면 한 명의 사용자를 등록하는 것이 하나의 비즈니스 작업 단위가 된다. 이때는 add() 메소드가 실행되기 전에 트랜잭션이 시작되고 add() 메소드를 빠져나오면 트랜잭션이 종료되는 것이 맞다. DB 트랜잭션은 단위 업무와 일치해야 하기 때문이다.

그런데 작업 단위가 다른 비즈니스 로직이 있을 수 있다.
예를 들어 그날의 이벤트의 신청 내역을 모아서 한 번에 처리하는 기능이 있다고 해보자.
처리되지 않은 이벤트 신청정보를 모두 가져와 DB에 등록하고 그에 따른 정보를 조작해주는 기능이다.
그런데 신청정보의 회원가입 항목이 체크되어 있는 경우에는 이번트 참가자를 자동으로 사용자로 등록해줘야한다. 하루치 이벤트 신청 내역을 처리하는 기능은 반드시 하나의 작업 단위로 처리돼야 한다.

이 기능을 EventService 클래스의 processailyEventRegistration() 메소드로 구현했다고 한다면 이 메소드가 비즈니스 트랜잭션의 경계가 된다. 그런데 이 메소드 작업 중간에 사용자 등록을 할 필요가 있다. 직접 UserDao의 add() 메소드를 사용할 수도 있지만 그보다는 UserService의 add() 메소드를 이용해서 사용자 등록 중 처리해야 할, 디폴트 레벨 설정돠 같은 로직을 적용하는 것이 바람직하다.

이 때 UserService의 add() 메소드는 독자적인 트랜잭션을 시작하는 대신 processDailyEventRegistration() 메소드에서 시작된 트랜잭션의 일부로 참여하게 된다. 만약 add() 메소드 호출 뒤에 processDailyEventRegistration() 메소드를 종료하지 못하고 예외가 발생한 경우에는 트랜잭션이 롤백되면서 UserService의 add() 메소드에서 등록한 사용자 정보도 취소된다.

트랜잭션 전파라는 기법을 사용했기 때문에 add() 메소드는 독자적인 트랜잭션 단위가 될 수 있고 다른 트랜잭션의 일부로 참여할 수도 있다. 트랜잭션 전파 방식을 이용할 수 없었다면 어떻게 될까? 그렇다면 add() 메소드는 매번 트랜잭션을 시작하도록 만들어졌을 것이고 이 때문에 processDailyEventRegistration() 등의 메소드에서 호출해서 사용할 수 없었을 것이다.
processDailyEventRegistration()에서 사용자 등록 기능이 필요하긴 하지만 사용자 등록 작업도 같은 트랜잭션에 넣어야 하는데 add()메소드는 독자적인 트랜잭션을 만들어버리기 때문이다.
그래서 어쩔 수 없이 processDailyEventRegistration() 안에 add() 메소드의 코드를 그대로 복사해서 사용하게 된다.
이런 식의 중복이 일어나기 시작하면 중복된 코드를 함께 관리하는 불편이 따르게 된다.
사용자 등록 중 처리해야할 작업이 추가 될 때마다 add() 메소드의 코드를 복사해간 다른 메소드를 모두 찾아서 일일이 수정해야한다.

다행히 스프링은 트랜잭션 전파 속성을 선언적으로 적용할 수 있는 기능을 제공하기 때문에 이런 고민을 해결할 수 있다.
![[KakaoTalk_Photo_2025-09-05-15-29-30.jpeg]]
그림처럼 add() 메소드에 REQUIRED 방식의 트랜잭션 전파 속성을 지정했을 때 트랜잭션이 시작되고 종료되는 경계를 보여준다.
add() 메소드도 스스로 트랜잭션 경계를 설정할 수 있지만 때로는 다른 메소드에서 만들어진 트랜잭션의 경계 안에 포함된다.
이 덕분에 사용자 등록 기능이 다양한 비즈니스 트랜잭션에서 사용되더라도 add() 메소드는 하나만 존재하면 되고 불필요한 코드 중복이 일어나지 않는다.

AOP를 이용해 코드 외부에서 트랜잭션 기능을 부여해주고 속성을 지정할 수 있게 하는 방법을 선언적 트랜잭션이라고 한다.
반대로 TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법은 프로그램에 의한 트랜잭션이라고 한다. 스프링은 두 가지 기능을 모두 지원한다.

### 트랜잭션 동기화와 테스트
이렇게 트랜잭션의 자유로운 전파와 그로 인한 유연한 개발이 가능할 수 있었던 기술적인 배경에는 AOP가 있다.
AOP 덕분에 프록시를 이용한 트랜잭션 부가기능을 간단하게 애플리케이션 전반에 적용할 수 있었다. 또 한가지 중요한 기술적 이유는 바로 스프링의 트랜잭션 추상화다. 데이터 액세스 기술에 상관없이, 트랜잭션 기술에 상관 없이 DAO에서 일어나는 작업들을 하나의 트랜잭션으로 묶어서 추상 레벨에서 관리하게 해주는 트랜잭션 추상화가 없었다면 AOP를 통한 선언적 트랜잭션이나 트랜잭션 전파 등은 불가능 했을 것이다.

**트랜잭션 매니저와 트랜잭션 동기화**
트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어가 가능했다. 또한 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유할 수 있었다.

트랜잭션 동기화 기술은 트랜잭션 전파를 위해서도 중요한 역할을 한다. 진행 중인 트랜잭션이 있는지 확인하고 트랜잭션 전파 속성에 따라서 이에 참여할 수 있도록 만들어주는 것도 트랜잭션 동기화 기술 덕분이다.

지금은 모든 트랜잭션을 선언적으로 AOP로 적용하고 있지만 필요하다면 프로그램에 의한 트랜잭션 방식을 함께 사용할 수도 있다.
물론 틀별한 이유가 없다면 트랜잭션 매니저를 직접 이용하는 코드를 작성할 필요는 없다. 선언적 트랜잭션이 훨씬 편리하다.

그런데 특별한 이유가 있다면 트랜잭션 매니저를 이용해 트랜잭션에 참여하거나 트랜잭션을 제어하는 방법을 사용할 수도 있다.

스프링의 테스트 컨텍스트를 이용한 테스트에서는 @Autowired를 이용해 애플리케이션 컨텍스트에 등록된 빈을 가져와 테스트 목적으로 활용할 수 있었다. 그렇다면 당연히 트랜잭션 매니저 빈도 가져올 수 있다.

![[KakaoTalk_Photo_2025-09-05-15-53-58 001.jpeg]]
![[KakaoTalk_Photo_2025-09-05-15-53-58 002.jpeg]]
@Autowired를 사용해 테스트에서 사용할 수 있다.

![[KakaoTalk_Photo_2025-09-05-15-53-58 003.jpeg]]
transactionSync() 테스트 메소드가 실행되는 동안에 몇 개의 트랜잭션이 만들어졌을까?
UserService의 모든 메소드에는 트랜잭션을 적용했으니 당연히 3개다. 각 메소드가 모두 독립적인 트랜잭션 안에서 실행된다.
테스트에서 각 메소드를 실행시킬 때는 기존에 진행 중인 트랜잭션이 없고 트랜잭션 전파 속성은 REQUIRED이니 새로운 트랜잭션이 시작된다. 그리고 그 메소드를 정상적으로 종료하는 순간 트랜잭션은 커밋되면서 종료될 것이다.

메소드마다 각각의 트랜잭션이 생성되고 종료되는 것이다.

**트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어**
그렇다면 이 테스트 메소드에서 만들어지는 세 개의 트랜잭션을 하나로 통합할 수는 없을까?
세 개의 메소드 모두 트랜잭션 전파 속성이 REQUIRED이니 이 메소드들이 호출되기 전에 트랜잭션이 시작되게만 한다면 가능하다.
UserService에 새로운 메소드를 만들고 그 안에서 deleteAll()과 add()를 호출하면 가능하다. UserService의 모든 메소드는 트랜잭션 경계가 되니 새로 만든 메소드에서 시작한 트랜잭션이 deleteAll()과 add()를 묶어서 하나의 트랜잭션 안에서 동작하게 할 것이다.

그런데 메소드를 추가하지 않고 테스트 코드만으로 세 메소드의 트랜잭션을 통합하는 방법이 있다.
테스트에서 트랜잭션 매니저를 이용해 트랜잭션을 시작시키고 이를 동기화해주면 된다. 테스트도 트랜잭션 동기화에 참여하는 것이다.

트랜잭션을 시작하기 위해서는 먼저 트랜잭션 정의를 담은 오브젝트를 만들고 이를 트랜잭션 매니저에 제공하면서 새로운 트랜잭션을 요청하면 된다. 트랜잭션 매니저는 이미 @Autowired를 테스트 코드로 주입해놨다. 이를 이용해서 트랜잭션을 시작하는 코드를 넣은 테스트 메소드로 만든다.
![[KakaoTalk_Photo_2025-09-05-15-59-31 001.jpeg]]
이렇게 하면 테스트 코드에서 트랜잭션 매니저를 이용해서 트랜잭션을 만들고 그 후에 실행되는 UserService의 메소드들이 같은 트랜잭션에 참여하게 만들 수 있다.

**트랜잭션 동기화 검증**
정말 이 세 개의 메소드가 테스트 코드 내에서 시작된 트랜잭션에 참여하고 있는지는 알 수 없다. 그래서 트랜잭션의 속성을 변경해서 이를 증명해보자.

트랜잭션 속성 중에서 읽기전용과 제한시간 등은 처음 트랜잭션이 시작할 때만 적용되고 그 이후에 참여하는 메소드의 속성은 무시된다. 즉 deleteAll()의 트랜잭션 속성은 쓰기 가능으로 되어 있지만 앞에서 시작된 트랜잭션이 읽기전용이라고 하면 deleteAll()의 모든 작업도 읽기전용 트랜잭션이 적용된 상태에서 진행된다는 말이다.
이번에 트랜잭션 속성을 강제로 읽기전용으로 만들고 다시 테스트 해보자.
![[KakaoTalk_Photo_2025-09-05-15-59-31 002.jpeg]]
태스트를 실행해보면 예외 발생으로 인한 실패이다.
메시지는 Connection is read-only라고 나올 것이다. 읽기 전용 트랜잭션에 대해 쓰기 작업을 했을 때 발생하는 예외이다.
예외가 발생한 위치를 확인해보면 deleteAll() 메소드이다. 이를 통해 테스트 코드 내에서 시작한 트랜잭션에 deleteAll() 메소드가 참여하고 있다는 확신을 얻을 수 있다.

테스트를 통해 확인할 수 있듯이 스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있다. 이를 잘 이용하면 DB 작업이 포함되는 테스트를 원하는 대로 제어하면서 효과적인 테스트를 만들 수 있다.

이런 방법은 선언적 트랜잭션이 적용된 서비스 메소드에만 적용되는 것이 아니다. JDBCTemplate과 같이 스프링이 제공하는 데이터 액세스 추상화를 적용한 DAO에도 동일한 영향을 미친다. JdbcTemplate은 트랜잭션이 시작된 것이 있으면 그 트랜잭션에 자동으로 참여하고 없으면 트랜잭션 없이 자동커밋 모드로 JDBC 작업을 수행한다. 개념은 조금 다르지만 JdbcTemplate의 메소드 단위로 마치 REQUIRED인 것처럼 동작한다고 볼 수 있다.
따라서 아래와 같이 DAO를 직접 호출해도 동일한 결과를 얻을 수 있다.
![[KakaoTalk_Photo_2025-09-05-16-18-39 001.jpeg]]

트랜잭션이라면 당연히 롤백도 가능해야한다.
![[KakaoTalk_Photo_2025-09-05-16-18-40 002.jpeg]]
UserService의 add() 작업이 테스트에서 시작한 트랜잭션에 참여하고 있으므로 테스트에서 만든 트랜잭션을 롤백하면 당연히 add() 작업도 롤백돼야 한다. 테스트를 돌려보면 성공할 것이다.

**롤백 테스트**
테스트 코드로 트랜잭션을 제어해서 적용할 수 있는 테스트 기법이 있다. 바로 롤백 테스트다.
롤백 테스트는 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게하고 테스트가 끝나면 무조건 롤백하는 테스트를 말한다.
![[KakaoTalk_Photo_2025-09-05-16-18-40 003.jpeg]]
롤백 테스트는 DB 작업이 포함된 테스트가 수행돼도 DB에 영향을 주지 않기 때문에 장점이 많다.
DB를 사용하는 코드를 테스트하는 건 여러 가지 이유로 작성하기 힘들다. 간단한 CRUD 테스트야 별 문제가 안되겠지만 복잡한 데이터를 바탕으로 동작하는 기능을 테스트하려면 테스트가 실행될 때의 DB 데이터와 상태가 매우 중요하다. 문제는 테스트에서 DB에 쓰기 작업을 하는 기능을 실행하면서 테스트를 수행하고 나면 DB의 데이터가 바뀐다는 점이다. 따라서 테스트를 실행하기 전에 적절한 DB 상태를 만들어놓더라도 테스트가 끝나고 나면 데이터와 상태가 바뀐다. 테스트는 어떤 순서로 어떻게 진행될지 보장할 수 없고 성공했을 때와 실패햇을 때 DB에 다른 방식으로 영향을 줄 수 있다. 그래서 테스트용 데이터를 DB에 잘 준비해놓더라도 앞에서 실행된 테스트에서 DB의 데이터를 바꿔버리면 이후에 실행되는 테스트에 영향을 미칠 수 있다.

결국 DB를 엑세스하는 테스트를 위해서는 테스트를 할 때마다 테스트 데이터를 초기화하는 번거로운 작업이 필요해진다.

바로 이런 이유때문에 롤백 테스트는 매우 유용하다. 롤백 테스트는 테스트를 진행하는 동안에 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전 상태로 만들어주기 때문이다. 
예외가 발생해도 괜찮다. 전체 테스트를 수행하기 전에 여러 테스트에서 공통적으로 필요한 사용자 정보를 테스트 데이터로 DB에 넣어뒀다면 롤백 테스트 덕분에 매 테스트마다 처음과 동일한 User 테이블의 테스트 데이터로 테스트를 수행할 수 있다.

이처럼 테스트에서 트랜잭션을 제어할 수 있기 때문에 얻을 수 있는 가장 큰 유익이 있다면 바로 롤백 테스트다. DB에 따라서 성공적인 작업이라도 트랜잭션을 롤백하며 커밋할 때보다 성능이 더 향상되기도 한다.

### 테스트를 위한 트랜잭션 애노테이션
@Transactional 애노테이션을 타깃 클래스 또는 인터페이스에 부여하는 것만으로 트랜잭션을 적용해주는 건 매우 편리한 기술이다.
이 편리한 방법을 테스트 클래스와 메소드에도 적용할 수 있다.

스프링의 컨텍스트 테스트 프레임워크는 애노테이션을 이용해 테스트를 편리하게 만들 수 있는 여러 가지 기능을 추가해준다.
@ContextConfiguration을 클래스에 부여하면 테스트를 실행하기 전에 스프링 컨테이너를 초기화하고 @Autowired 애노테이션이 붙은 필드를 통해 테스트에 필요한 빈에 자유롭게 접근할 수 있다.
그 외에도 스프링 컨텍스트 테스트에서 쓸 수 있는 유용한 애노테이션이 여러 개 있다.

**@Transactional**
테스트에도 @Transactional을 적용할 수 있다.
일반 클래스와 메소드에서 적용된것과 마찬가지로 @Transactional 부여해주면 트랜잭션 경계가 자동으로 설정된다.
이를 이용하면 테스트 내에서 진행하는 모든 트랜잭션 관련 작업을 하나로 묶어줄 수 있다.

물론 테스트에서 사용하는 @Transactional은 AOP를 위한 것은 아니다. 단지 컨텍스트 테스트 프레임워크에 의해 트랜잭션을 부여해주는 용도로 쓰일 뿐이다. 하지만 기본적인 동작방식과 속성은 UserService 등에 적용한 @Transactional과 동일하므로 이해하기 쉽고 사용하기 편리하다.

![[KakaoTalk_Photo_2025-09-05-16-47-49 001.jpeg]]
UserService의 메소드에 적용했을 때와 마찬가지로 테스트 메소드 실행 전에 새로운 트랜잭션을 만들어주고 메소드가 종료되면 트랜잭션을 종료해준다. 당연히 세 개의 메소드는 한 개의 트랜잭션으로 실행된다.

![[KakaoTalk_Photo_2025-09-05-16-47-50 002.jpeg]]
트랜잭션 적용 여부를 확인해보고 싶다면 앞에서 했던 것처럼 읽기전용으로 바꾼 후 테스트를 실행해 예외가 발생하는지 확인해본다.

@Transactional은 테스트 클래스 레벨에 부여할 수도 있다. 그러면 테스트 클래스 내의 모든 메소드에 트랜잭션이 적용된다.

**@Rollback**
테스트 메소드나 클래스에 사용하는 @Transactional은 애플리케이션의 클래스에 적용 할 때와 디폴트 속성은 동일하다. 하지만 중요한 차이점이 있는데 테스트용 트랜잭션은 테스트가 끝나면 자동으로 롤백된다는 것이다. 테스트에 적용된 @Transactional은 기본적으로 트랜잭션을 강제적으로 롤백시키도록 설정되어 있다. @Transactional을 지정해주면 롤백 테스트가 되는 것이다.

그런데 테스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶기는 하지만 진행한 작업을 그대로 DB에 반영하고 싶다면 어떻게 해야 할까?
이때는 @Rollback이라는 애노테이션을 사용하면 된다. @Transactional은 기본적으로 테스트에서 사용할 용도로 만든 게 아니기 때문에 롤백 테스트에 관한 설정을 담을 수 없다. 따라서 롤백 기능을 제거하려면 별도의 애노테이션을 사용해야 한다.
@Rollback은 롤백 여부를 지정하는 값을 갖고 있다. @Rollback의 기본 값은 true이다. 따라서 트랜잭션은 적용되지만 롤백은 원치 않는다면 @Rollback(false)라고 해줘야 한다.
![[KakaoTalk_Photo_2025-09-05-16-58-54 001.jpeg]]
이렇게 false로 설정해주면 트랜잭션은 커밋된다.

**@TransactionConfiguration**
@Transactional은 테스트 클래스에 넣어서 모든 테스트 메소드에 일괄 적용할 수 있지만 @Rollback은 메소드 레벨에만 적용할 수 있다.
테스트 클래스의 모든 메소드에 트랜잭션을 적용하면서 모든 트랜잭션이 롤백되지 않고 커밋되게 하려면 어떻게 해야 할까?
이 때는 @TransactionConfiguration을 적용하면 된다.
![[KakaoTalk_Photo_2025-09-05-16-58-54 002.jpeg]]
이렇게 @TransactionConfiguration을 적용하면 롤백에 대한 공통 속성을 지정할 수 있다. 디폴트 롤백 속성은 false로 해두고 테스트 메소드 중에서 일부만 롤백을 적용하고 싶으면 메소드에 @Rollback을 적용해주면 된다.

**NotTransactional과 Propagation.Never**
테스트 클래스 안에서 일부 메소드에만 트랜잭션이 필요하다면 메소드 레벨의 @Transactional을 적용하면 된다. 반면에 대부분의 메소드에서 트랜잭션이 필요하다면 테스트 클래스에 @Transactional을 지정하는 것이 편리하다.
이런 경우 굳이 트랜잭션이 필요 없는 메소드는 어떻게 해야 할까?

@NotTransactional을 테스트 메소드에 부여하면 클래스 레벨의 @Transactional 설정을 무시하고 트랜잭션을 시작하지 않은 채로 테스트를 진행한다. 물론 테스트 안에서 호출되는 메소드에서 트랜잭션을 사용하는 데는 영향을 주지 않는다.

또는 @Transactional의 트랜잭션 전파 속성을 사용하는 방법이 있다.
@Transactional(propagation=Propagation.NEVER)로 지정하면 트랜잭션이 시작되지 않는다.

**효과적인 DB 테스트**
테스트 내에서 트랜잭션을 제어할 수 있는 네 가지 애노테이션을 잘 활용하면 DB가 사용되는 통합테스트를 만들 때 매우 유용하다.
일반적으로 의존, 협력 오브젝트를 사용하지 않고 고립된 상태에서 테스트를 진행하는 단위 테스트와 DB같은 외부의 리소스나 여러 계층의 클래스가 참여하는 통합 테스트는 아예 클래스를 구분해서 따로 만드는 게 좋다.

DB가 사용되는 통합 테스트를 별도의 클래스로 만들어둔다면 기본적으로 클래스 레벨에 @Transactional을 부여해준다. DB가 사용되는 통합 테스트는 가능한 한 롤백 테스트로 만드는게 좋다. 애플리케이션의 모든 테스트를 한꺼번에 실행하는 빌드 스크립트 등에서 테스트에서 공통적으로 이용할 수 잇는 테스트 DB를 셋업해주고 각 테스트는 자신이 필요한 테스트 데이터를 보충해서 테스트를 진행하게 만든다.

테스트는 어떤 경우에도 서로 의존하면 안 된다. 테스트가 진행되는 순서나 앞의 테스트의 성공 여부에 따라 다음 테스트의 결과가 달라지는 테스트를 만들면 안 된다.
코드가 바뀌지 않는 한 어떤 순서로 진행되더라도 테스트는 일정한 결과를 내야 한다.
트랜잭션을 지원하는 롤백 테스트는 매우 유용한 도구가 돼줄 것이다.

