
## 레디스 클러스터와 확장성

### 스케일 업 vs 스케일 아웃
확장성은 시스템에서 증가하는 트래픽에 유연하게 대응할 수 있는 능력

트래픽이 많아져야 할 때 용량 및 성능을 늘리기 위해 시스템의 확장이 필요한데 리소스를 투입하는 방식에 따라 스케일 업과 스케일 아웃으로 구분한다.
![[KakaoTalk_Photo_2025-10-14-14-08-49 001.jpeg|675]]
**스케일 업**
서버의 하드웨어를 높은 사양으로 업그레이드하는 것(수직 확장)
ex) 디스크 추가, cpu 또는 메모리 업그레이드 등

**스케일 아웃**
장비를 추가해 시스템을 확장시키는 방식(수평 확장)
ex) 비슷한 사양의 서버를 추가로 연결, 서버의 대수를 증가하는 방식

스케일 업이 더  간단하고 비용도 적게 들지만 하드웨어 허용 범위 내에서만 확장이 가능해 업그레이드에 한계가 있으며
스케일 아웃은 장비를 추가하는 만큼 성능이 증가하지만 분산 처리에 대한 로직이 추가되어야 한다.

### 레디스에서의 확장성
레디스를 운영하는 도중 키의 이빅션(eviction)이 자주 발생한다면 서버의 메모리를 증가시키는 스케일 업을 고려할 수 있다.
이빅션은 레디스 인스턴스의 maxmemory만큼 데이터가 차 있을 때 기존 데이터를 자동으로 삭제하는 정책으로
이빅션이 자주 발생한다면 레디스 인스턴스의 메모리가 부족하다는 뜻이므로 스케일 업을 고려해본다.

레디스의 처리량을 늘릴 때는 스케일 업보다는 스케일 아웃을 고려해야한다.
레디스는 싱글 스레드로 동작하기 때문에 서버에 CPU를 추가해서 CPU 코어가 추가된다 해도 추가된 만큼 성능 향상을 기대할 수 없다.
따라서 스케일 아웃으로 여러 인스턴스를 운영하여 처리량을 선형적으로 증가시킬 수 있다.

### 레디스 클러스터의 기능
레디스 클러스터를 사용하면 애플리케이션 아키텍처 변경 없이 여러 레디스 인스턴스 간 수평 확장이 가능해진다.
데이터 분산 처리, 복제, 자동 페일오버 기능도 사용할 수 있다.

#### 데이터 샤딩
![[KakaoTalk_Photo_2025-10-14-14-08-50 002.jpeg|675]]
데이터 저장소를 수평 확장하며 여러 서버 간에 데이터를 분할하는 데이터베이스 아키텍처 패턴을 샤딩이라 한다.

클러스터에서 데이터는 키를 이용해 샤딩되며 하나의 키는 항상 하나의 마스터 노드에 매핑된다.
클러스터의 모든 노드는 키가 저장돼야 할 노드를 알고 있기 때문에 클라이언트가 다른 노드에 데이터를 쓰거나 읽으려 할 때 
키가 할당 된 마스터 노드로 연결을 리디렉션한다.

데이터를 분할 저장할 때 애플리케이션의 소스 코드 로직이 변경될 필요가 없어 샤딩 처리에 들어가는 번거로움을 줄일 수 있다.

클러스터에서 노드가 추가/변경되지 않는 이상 하나의 키는 특정 마스터에 매핑된다.
매번 레디스에 키를 저장할 노드를 질의하지 않게 하기 위해 클라이언트에서는 클러스터 내에서 특정 키가 어떤 마스터에 저장돼 있는지 캐싱할 수 있다.

레디스에서 클러스터 기능을 사용하면 마스터를 최대 1,000개 까지 확장시킬 수 있다.
데이터의 샤딩 관련된 모든 기능은 레디스 자체적으로 관리되며 이를 위한 프록시 서버 등의 추가 아키텍처는 필요하지 않다.

#### 고가용성
클러스터는 최소 3대의 마스터, 복제본 노드를 갖도록 구성하는것이 일반적이며 하나의 클러스터 구성에 속한 각 노드는 서로를 모니터링한다.
장애 발생시 자동 페일오버를 실행해서 사용자의 개입 없이 가용성을 증가 시키고
마스터에 연결된 복제본의 개수를 파악해 잉여 복제본을 필요한 노드에 연결시키는 복제본 마이그레이션도 수행한다.

![[KakaoTalk_Photo_2025-10-14-14-54-20.jpeg|600]]
클러스터 내의 노드들은 클러스터 버스라는 독립적인 통신을 이용한다.
모든 레디스 클러스터 노드는 다른 레디스 클러스터 노드에서 들어오는 연결을 수신하기 위한 추가 TCP 포트가 열려 있다.
클라이언트로부터 커맨드를 받는 TCP 포트와 독립적으로 동작하며 구성 파일에서 CLUSTER_BUS_PORT 값을 정의하지 않는다면
일반적으로 일반 포트에 10000을 더한 값으로 자동 설정된다.

클러스터는 모든 노드가 TCP 연결을 사용해 연결돼 있는 풀 메쉬 토폴로지 형태다.
클러스터가 N개의 노드로 이뤄져 있을 때 모든 노드는 N-1개의 다른 노드와 송수신 TCP 연결을 하며 계속 유지된다.

풀 메쉬 토폴로지 형태로 구성된 레디스 클러스터에서 노드 간 너무 많은 메시지를 교환하는 오버헤드는 걱정하지 않아도 된다.
가십 프로토콜과 구성 업데이트 메커니즘을 이용해 클러스터가 정상적인 상태에서는 노드간 너무 많은 메세지를 교환하지 않는다.
노드가 증가하더라도 메시지가 기하급수적으로 늘어나지 않도록 설계 됐다.
```
가십 프로토콜(Gossip Protocol) : 소문을 퍼트리듯 전파하는 방식
노드 A: "나 살아있어!" → 노드 B에게만 전달
노드 B: "A가 살아있대!" → 노드 C에게만 전달
노드 C: "A가 살아있대!" → 노드 D에게만 전달
...점진적으로 모든 노드에게 전파됨

랜덤하게 몇 개 노드에게만 메시지를 전송하면 결국 모든 노드가 정보를 알게됨
주기적으로 정보를 교환하며(Redis는 1초마다 전송) 모든 노드에게 한 번에 보내지 않아서 효율적


구성 업데이트 메커니즘 : 클러스터 구성정보를(누가 어떤 데이터를 담당하는지) 동기화하는 방법
ex)
초기 상태: Epoch 1
  노드A: 슬롯 0-5000
  노드B: 슬롯 5001-10000
  
노드A 장애 발생 → 복제본이 승격
  
새로운 상태: Epoch 2 (번호 증가!)
  노드A': 슬롯 0-5000 (새 마스터)
  노드B: 슬롯 5001-10000
  
버전 번호(epoch)로 최신정보를 확인, 더 높은 번호를 받으면 내 정보 업데이트
가십으로 전파해서 모든 노드가 동기화
```

## 레디스 클러스터 동작 방법

### 해시슬롯을 이용한 데이터 샤딩
클러스터 구조에서 모든 데이터는 해시슬롯에 저장된다.
레디스는 16,384개의 해시슬롯을 가지며 마스터 노드는 해시슬롯을 나눠 갖는다.
```
3대의 마스터 노드로 클러스터를 구성했을 때
마스터 1 : 0~5460 해시슬롯
마스터 2 : 5461~10922 해시슬롯
마스터 3 : 10923~16383 해시슬롯

레디스에 입력되는 모든 키는 하나의 해시슬롯에 매핑되며 이때 해시함수는 다음과 같다.
HASH_SLOT = CRC16(key) mod 16384
>> 키를 CRC16으로 먼저 암호화 한 후 16384라는 값으로 나눈 나머지 값을 이용해 해시슬롯이 결정
```
데이터를 저장할 때 뿐만 아니라 데이터를 읽어올 때도 해시함수를 통해 적절한 마스터 노드를 찾아간다.
![[KakaoTalk_Photo_2025-10-14-15-47-34 001.jpeg|650]]
ID:0817이라는 키를 가져올 때 알고리즘에 의해 키는 5459라는 해시슬롯에 저장돼 있으므로 마스터 1번에서 가져온다.
ID:87345라는 키를 저장할 때 키가 저장될 해시슬롯을 먼저 구한 후 5462 슬롯을 가지고 있는 마스터 2번에 저장한다.

![[KakaoTalk_Photo_2025-10-14-15-47-35 002.jpeg|650]]
해시슬롯은 마스터 노드 내에서 자유롭게 옮겨질 수 있으며 옮겨지는 중에도 정상적으로 데이터에 접근할 수 있다.
이로 인해 하나의 클러스터 내에서 마스터 노드의 추가, 삭제는 굉장히 간단하게 처리된다.

그림과 같이 신규 레디스 노드를 마스터로 추가한 뒤 기존 노드가 가지고 있던 해시슬롯의 일부를 신규 마스터 노드로 이동시켜주면 된다.

### 해시태그
클러스터를 사용할 때에는 MGET과 같은 다중 키 커맨드를 사용할 수 없다.
(서로 다른 해시슬롯에 속한 키에 대해 다중 키 커맨드를 사용하면 에러 발생)

해시태그 라는 기능을 사용하면 이런 문제를 해결할 수 있다.
키에 대괄호를 사용하면 전체 키가 아닌 대괄호 사이에 있는 값을 이용해 해시될 수 있다.
```
user:{123}:profile
user:{123}:account
>> 키 전체가 아닌 123이 해시됨, 즉 같은 해시슬롯에 저장되는 것
```
![[KakaoTalk_Photo_2025-10-14-16-05-36.jpeg|675]]
1. 대괄호 안의 user1000이 해싱
2. 대괄호 사이에 아무것도 없기 때문에 전체가 해싱
3. 첫 번째 {와 첫번째 } 사이의 값인 {name이 해싱
4. 첫 번째 대괄호 사이의 값인 name이 해싱

```
MGET {user}1:name {user}2:name
클러스터 구조에서 다중 키 커맨드를 사용하고 싶다면 위와 같이 해시 태그 기능을 사용하면 된다.
단, 저장도 해당 해시태그로 저장이 되어 있어야한다.
```

너무 많은 키가 같은 해시태그를 갖고 있다면 하나의 해시슬롯에 데이터가 몰리는 현상이 발생할 수 있기 때문에 모니터링이 필요할 수 있다.

### 자동 재구성
클러스터 구조에서도 복제와 자동 페일오버를 이용해 고가용성을 확보할 수 있다.
클러스터 구조에서는 센티널과 다르게 별도의 인스턴스를 추가로 띄울 필요가 없으며 일반 레디스 노드가 서로 감시하는 구조이다.
모든 노드는 클러스터 버스를 통해 통신하며 인스턴스에 문제가 생겼을 때 자동으로 클러스터 구조를 재구성한다.

레디스 클러스터에서 사용하는 재구성은 총 두 가지이다.

#### 자동 페일오버
![[KakaoTalk_Photo_2025-10-14-16-19-56 001.jpeg|575]]
1. 6001번 마스터에 장애가 발생하면 6005번이 다른 마스터 노드들에게 페일오버를 시도해도 될지 투표를 요청
2. 다른 마스터 노드는 6001번 마스터가 정상이 아니라고 판단할 경우 복제본에게 투표
3. 과반수 이상의 마스터 노드에게 투표를 받은 6005번이 마스터로 승격

6005번 노드에도 장애가 발생하면 마스터 1개는 사용이 불가능한 상황이된다.
이때 클러스터 구조에서는 클러스터 내의 마스터가 하나라도 정상 상태가 아닐 경우 전체 클러스터를 사용할 수 없게된다.
```
cluster-requre-full-coverage yes
>> 해당 옵션은 레디스 클러스터에서 일부 해시슬롯을 사용하지 못하게되면 데이터의 정합성을 위해 클러스터의 전체 상태가 fail이 돼
>> 문제가 생긴 해시슬롯을 포함 전체 해시슬롯에 대한 데이터 조작도 실패하게 된다.
```

#### 자동 복제본 마이그레이션
![[KakaoTalk_Photo_2025-10-14-16-19-57 002.jpeg|575]]
세 개의 마스터 노드는 각각 1개, 1개, 2개의 복제본을 가지고 있는 상황이다.
여기서 6001, 마스터로 승격된 6005번까지 장애가 생긴다면 6005번은 더이상 복제본이 없는 상태이다.

이 상황에서 레디스 클러스터는 각 마스터에 연결된 복제본 노드의 불균형을 파악해 6003에 연결돼있던 2개의 복제본 중 하나의 복제본을
6005의 복제본이 되도록 이동시키는데 이를 복제본 마이그레이션이라 한다.
복제본 마이그레이션은 모든 마스터가 적어도 1개 이상의 복제본을 가지도록 하며 클러스터 전체의 안정성을 향상시킨다.

아무 복제본이나 마이그레이션이 되는것은 아니고 가장 많은 복제본이 연결된 마스터의 복제본 중 하나가 옮겨지며
FAIL 상태가 아닌 복제본 중 노드 ID가 가장 작은 복제본이 이동될 노드로 선택된다.

```
cluster-allow-replica-migration yes
>> 해당 옵션이 yes일 때 마이그레이션이 동작하며 기본값은 yes
cluster-migration-barrier 1
>> 복제본을 마이그레이션 하기 전에 마스터가 가지고 있어야 할 최소 복제본의 수를 의미
>> 예를 들어 값이 2로 설정됐을 경우 6003번의 복제본은 2개를 초과하지 않기 때문에 복제본 마이그레이션이 발생하지 않는다.
```

