## 클러스터 실행하기
보통 클러스터 모드로 실행할 때는 마스터 3개, 복제본 3개 총 6개의 노드로 클러스터를 구성하는 것이 일반적이다.

예제에서는 192.168.0.11 ~ 192.168.0.66 서버에 클러스터를 구성한다.

### 클러스터 초기화
```
cluster-enabled yes
>> redis.conf에서 레디스를 클러스터 모드로 변경하고 6대의 서버에서 레디스를 실행

redis-cli -cluster create [host:port] --cluster-replicas 1
>> -cluster create 옵션을 이용해 새로운 클러스터를 생성, 클러스터에 추가할 레디스의 ip, port 쌍을 나열
>> cluster-replicas는 각 마스터마다 복제본을 몇 개 추가할 것인지 명시

ex)
src/redis-cli --cluster create 192.168.0.11:6379 192.168.0.22:6379 ... 192.168.0.66:6379 --cluster-replicas 1
>> ip, port 쌍을 모두 넣어주면 6개의 레디스 인스턴스가 클러스터로 구성된다.
```

cluster create 명령어를 실행하면 입력한 순서대로 3개의 노드는 마스터, 나머지 노드는 복제본이 되도록 구성될 것이라는 정보를 확인할 수 있다.
각 마스터 별로 어떤 해시슬롯을 할당 받는지, 어떤 복제본이 복제되는지 등의 정보를 알 수 있다.
![[KakaoTalk_Photo_2025-10-14-21-07-45.jpeg|850]]
클러스터는 그림과 같이 구성된다.

해시슬롯은 마스터에만 할당되며 복제본 노드에게는 할당되지 않고 복제본 노드는 마스터와 동일한 데이터를 저장하기 때문에
해시슬롯 내부의 데이터를 동일하게 저장하긴 하지만 해시슬롯을 할당받진 않는다.

### 클러스터 상태 확인하기
cluster nodes 커맨드로 클러스터 상태를 확인할 수 있다.
```
cluster nodes 커맨드는 랜덤으로 클러스터 내의 노드들을 순서 없이 출력하며 출력되는 라인은 다음과 같은 필드를 가진다.

<id> <ip:port@cport> <flags> <master> <ping-sent> <pong-recv> <config-epoch> <link-state> <slot> <slot> ... <slot>
```
1. id : 노드가 생성될 때 자동으로 만들어지는 클러스터 ID 값
2. ip:port@cport : 노드가 실행되는 ip와 port 그리고 클러스터 버스 포트 값
3. flags : 노드의 상태를 나타낸다.
	myself : redis-cli를 이용해 접근한 노드
	master : 마스터 노드
	slave : 복제본 노드
	fail? : 노드가 PFAIL 상태임을 의미(노드에 정상 접근할 수 없어서 다른 노드에 확인을 하기 시작하는 상태)
	handshake : 새로운 노드를 인지하고 핸드셰이킹을 하는 단계
	nofailover : 복제본 노드가 페일오버를 시도하지 않을 것임을 의미
	noaddr : 해당 노드의 주소를 모른다는 것을 의미
	noflags
4. master : 복제본 노드일 경우 마스터 노드의 ID, 마스터 노드일 경우 - 문자가 표시
5. ping-sent : 보류 중인 ping이 없다면 0, 있다면 마지막 ping이 전송된 유닉스 타임을 표시
6. pong-sent : 마지막 pong이 수신된 유닉스 타임을 표시
7. config-epoch : 현재 노드의 구성 에포크, 구성 충돌이 있을 때 에포크가 높은 노드의 구성으로 변경
8. link-state : 클러스터 버스에 사용되는 링크의 상태를 의미
9. slot : 노드가 갖고 있는 해시슬롯의 범위를 표시

### redis-cli를 이용해 클러스터 접근하기와 리디렉션
레디스 클러스터에 접속하기 위해서는 클러스터 모드를 지원하는 레디스 클라이언트가 필요하다.
클러스터 모드를 지원하는 클라이언트만이 리디렉션 등의 기능을 제공하고 이 기능을 이용해야 클러스터를 제대로 사용할 수 있다.

```
일반적인 클라이언트 사용 시
redis-cli
127.0.0.1:6379> set user:1 true
(error) Moved 10778 192.168.0.22:6379
>> 11번 ip로 데이터를 넣으려고 했으나 해당 키는 10778 해시슬롯에 들어가야하며 10778은 22번 ip에 저장되어야한다.
>> 일반적인 클라이언트를 이용해 데이터를 넣을 때에는 데이터가 저장될 수 있는 노드가 정해져 있어서 해당 노드에 대한 커맨드만 수행가능

클러스터 지원 클라이언트 사용 시
redis-cli -c
127.0.0.1:6379> set user:1 true
Redirected to slot [10778] located at 192.168.0.22:6379
OK
>> -c를 쓰면 클러스터 모드로 활용가능하다.

이외에도 jedis, redisson 등의 클라이언트가 클러스터 모드를 제공한다.
(jedis, redisson은 자바에서 redis 서버로 명령을 보내는 클라이언트 라이브러리)
```

대부분의 레디스 클라이언트는 리디렉션한 정보를 캐싱해 맵을 생성하게 되는데 다음에 같은 키에 대해 커맨드를 수행할 경우 캐싱된 노드로 바로 커맨드를 보낸다.
이로 인해 클러스터의 성능을 향상시킬 수 있게 된다.
클러스터에 저장된 맵은 마스터 노드가 추가, 삭제되거나 페일오버가 발생하는 등 클러스터 구조가 변경되면 리프레시된다.

### 페일오버 테스트
클러스터 구성 작업이 완료됐다면 페일오버가 정상 작동하는지 확인해야한다.

#### 커맨드를 이용한 페일오버 발생(수동 페일오버)
페일오버를 시킬 복제본 노드에서 cluster failover 커맨드를 실행하면 페일오버를 발생할 수 있다.
11번 마스터와 연결된 55번 복제본에 페일오버를 발생시켜보자
```
192.168.0.55:6379> cluster failver
OK

192.168.0.55:6379> INFO REPLICATION
role : master
connected_slaves:1
....
```
수동 페일오버가 진행되는 동안 기존 마스터에 연결된 클라이언트는 잠시 블랙된다.
페일오버를 시작하기 전 복제 딜레이를 기다린 뒤 마스터의 복제 오프셋을 복제본이 따라잡는 작업이 완료되면 페일오버를 시작한다.
페일오버가 완료되면 클러스터의 정보를 변경하고 모든 작업이 완료되면 클라이언트는 새로운 마스터로 리디렉션된다.

#### 마스터 동작을 중지시켜 페일오버 발생(자동 페일오버)
```
redis-cli -h <master-host> -p <master-port> shutdown
>> 마스터 노드를 직접 shutdown
```
클러스터 구조에서 복제본은 redis.conf에서 지정한 cluster-node-timeout 시간동안 응답이 오지 않으면 마스터가 비정상이라고 판단해 페일오버를 트리거한다.

그럼 자동으로 복제본이 마스터로 승격된다.

## 레디스 클러스터 운영하기

### 클러스터 리샤딩
마스터 노드가 가지고 있는 해시슬롯 중 일부를 다른 마스터로 이동하는 것을 리샤딩이라 한다.
redis-cli에서 cluster reshard를 통해 수행할 수 있다.
![[KakaoTalk_Photo_2025-10-14-21-56-24 001 1.jpeg|650]]
클러스터에 속한 여러 노드 중 하나의 노드를 지정하면 해당 노드가 속한 클러스터의 구조를 파악한 뒤 연결된 다른 노드의 정보를 찾아와 보여준다.
(여기서는 11~66 6개의 노드 정보를 보여줌)
마스터 뿐만 아니라 복제본 노드 중 하나를 지정해도 리샤딩 동작은 동일하게 수행된다.

```
How Many slots do you want to move(from 1 to 16384)? 100
What is the receiving node ID? 옮기고 싶은 노드의 ID
>> 입력한 노드에 슬롯 100개가 추가되는 것
```
이후에 타입을 all로 입력하면 모든 마스터 노드에서 조금씩 이동하는 것이고
done으로 입력하면 해시슬롯을 가져올 마스터 ID를 지정해 해당 노드에서만 가져온다.

![[KakaoTalk_Photo_2025-10-14-21-56-24 002 1.jpeg|875]]
all을 이용해 33번 마스터 노드에 100개를 옮기면 11번과 22번에서 각출해 슬롯을 옮겨오게 된다.

리샤딩이 끝난 후 cluster check 커맨드를 이용해 클러스터 정보를 자세히 확인할 수 있다.
clster node 커맨드보다 조금 더 자세한 구성을 확인할 수 있는 커맨드이다.

### 클러스터 리샤딩 간단 버전
앞선 방법과 달리 사용자와의 인터렉션 없이 바로 슬롯을 이동시키는 방법도 존재한다.
```
redis-cli --cluster reshard <host>:<port> --cluster-from <node-id>
--cluster-to <node-id> --cluster-slots <number of slots> --cluster-yes
>> 한번에 어느 노드에서 어느 노드로 몇 개의 슬롯을 옮길지 정해서 커맨드로 수행
```
--cluster-yes는 모든 프롬프트에 자동으로 yes를 입력하겠다는 의미
해당 커맨드를 실행하면 자동으로 클러스터 리샤딩 작업이 진행된다.

### 클러스터 확장-신규 노드 추가
신규 노드를 추가할 때는 추가하고자 하는 레디스에 데이터가 저장되지 않은 상태여야 한다.
그렇지 않으면 에러가 반환되어 추가되지 않는다.

또한 추가하고자 하는 노드는 설정 파일에 cluster-enabled yes로 설정되어 있어야하며 레디스가 실행중이어야 한다.

77서버를 기존 클러스터에 추가 시켜보자

#### 마스터로 추가하기
--cluster add-node 커맨드를 사용하면 클러스터에 신규 마스터 노드를 추가할 수 있으며 첫 번째 인수는 새로 추가하고자하는 레디스 노드,
두 번째 인수는 기존 클러스터에 속한 노드 중 1개의 노드를 지정해야 한다.
```
redis-cli --cluster add-node <추가할 노드 IP:PORT> <기존 노드 IP:PORT>
```

이렇게 추가해도 슬롯이 바로 할당되진 않아서 데이터를 저장하려면 리샤딩을 사용해 해시슬롯을 할당하는 과정을 거쳐야한다.

#### 복제본으로 추가하기
마스터로 추가하는 것과 동일하지만 --cluster-slave 옵션을 추가해야 한다.
```
redis-cli --cluster add-node <추가할 노드 IP:PORT> <기존 노드 IP:PORT> --cluster-slave [--cluster-master-id <기존 마스터ID>]
>> cluster-master-id 옵션을 통해 노드를 추가할 때 복제본의 마스터를 지정해준다.
>> 만약 해당 옵션 없이 실행한다면 임의의 마스터의 복제본으로 추가된다.
```

### 노드 제거하기
클러스터에서 노드를 제거하기 위해서는 del-node 커맨드를 사용한다.
```
redis-cli --cluster del-node <기존 노드 IP:PORT> <삭제한 노드 ID>
```

삭제는 마스터, 복제본 상관 없이 같은 방식으로 제거할 수 있지만 마스터의 경우 데이터가 없어야 삭제가 가능하다.
할당된 해시슬롯이 하나도 없도록 리샤딩이 선행되어야 한다.
또는 수동 페일오버를 통해 복제본으로 변경 후 클러스터에서 제거할 수 있다.

해당 커맨드를 수행하면 클러스터에 cluster forget을 제거된 노드에 cluster reset soft를 수행했다는 내용이 나온다.

#### cluster forget
클러스터에서 노드를 제거할 때 제거할 노드에서 클러스터 구성 데이터를 지우는 것 뿐만 아니라
다른 노드들에게도 해당 노드를 지우라는 커맨드를 함께 보내야 한다.
그렇지 않다면 클러스터 내부의 다른 노드는 계속 해당 노드의 ID와 주소를 기억하고 있게 된다.

cluster forget node-id 커맨드를 수신한 노드는 노드 테이블에서 제거할 노드의 정보를 지운 뒤
60초 동안은 이 노드 ID를 가지고 있는 노드와 신규로 연결되지 않도록 설정된다.

클러스터 구성에서 노드들은 가십 프로토콜을 이용해 통신하기 때문에 신규 클러스터 노드를 자동으로 감지해 새로운 노드를 추가할 수 있다.
따라서 60초 동안 제거한 노드의 ID가 다시 추가되는 것을 차단하지 않으면 다른 노드에 의해 제거된 노드를 다시 클러스터에 추가할 가능성이 있다.

#### cluster reset
클러스터 리셋 커맨드는 제거될 노드에서 수행
```
cluster reset [soft/hard]
>> 기본값은 soft이다.
```

cluster reset의 과정
1. 클러스터 구성에서 복제본 역할을 했다면 노드는 마스터로 전환되고 노드가 가지고 있던 모든 데이터셋은 삭제, 노드가 마스터이고 저장된 키가 있다면 리셋 중단
2. 노드가 해시슬롯을 가지고 있었다면 모든 슬롯이 해제, 페일오버가 진행되는 과정이었다면 페일오버 진행 상태도 초기화
3. 클러스터 구성 내의 다른 노드 데이터가 초기화, 기존 클러스터 버스를 통해 연결됐던 노드를 더 이상 인식할 수 없음
4. currentEpoch, configEpoch, lastVoteEpoch 값이 0으로 초기화
5. 노드의 ID가 새로운 임의 ID로 변경

hard라면 1~5 모두 수행, soft라면 1~3만 실행

cluster reset은 앞선 예제처럼 cluster del-node 수행 중에 자동으로 실행될 수 있지만
사용자가 특정 클러스터 노드를 다른 역할로 재사용하고자 할 때 노드에 직접 커맨드를 수행할 수도 있다.
### 레디스 클러스터로의 데이터 마이그레이션
싱글 혹은 센티널 구성으로 사용 중 클러스터 구성의 레디스로 마이그레이션을 할 때
레디스 커맨드라인 클라이언트를 이용해 손쉽게 데이터의 마이그레이션이 가능하다.

기존 애플리케이션에서 다중 키 커맨드를 사용하지 않았을 경우에는 커넥션 변경 이외의 데이터 저장 로직은 문제가 없지만
사용했을 경우에는 해시태그를 사용하도록 애플리케이션 로직을 일부 수정해야 한다.

![[KakaoTalk_Photo_2025-10-14-23-12-45.jpeg|800]]
클러스터 노드에서 소스 노드로 데이터 import를 요청한다.
데이터가 저장될 클러스터 노드는 해시슬롯 16,384개가 정상적으로 할당된 정상 상태여야 하며 클러스터 내의 마스터 노드에 모두 접근 가능한 상태로 준비돼야 한다.
데이터의 소스 노드 또한 접근이 가능한 온라인 상태여야 한다.

운영 중인 레디스의 데이터를 마이그레이션할 때에는 소스 레디스에 연결된 클라이언트를 모두 중단시키는 것이 좋다.
마이그레이션 도중 원본 레디스 노드에서 변경되거나 추가된 데이터는 클러스터에 반영되지 않기 때문에 중단시키고 해야한다.

```
마이그레이션 커맨드
redis-cli --cluster import 192.168.0.11:6379 --cluster-from 192.168.0.88:6379 --cluster-copy
```

### 복제본을 이용한 읽기 성능 향상
레디스 클라이언트는 기본적으로 키를 요청하면 키를 갖고 있는 마스터 노드로 연결을 리디렉션한다.
마스터에 연결된 복제본 노드는 같은 데이터를 갖고 있기 때문에 키를 읽을 수 있지만 이 경우에도 우선 마스터로 연결이 변경된다.
![[KakaoTalk_Photo_2025-10-14-23-18-00.jpeg|750]]
11번 마스터 노드에 HELLO라는 키를 저장하고 55번 마스터 노드에서 읽어오면 에러가 발생한다.
만약 클러스터를 지원하는 클라이언트를 사용할 경우에는 마스터로 리디렉션 된다.

경우에 따라 애플리케이션 읽기 성능 향상을 위해 복제본 노드를 읽기 전용으로 사용하고 싶을 수 있다.
마스터에 데이터를 읽어가는 부하가 집중되면 데이터를 쓰는 커넥션은 마스터에 읽기는 복제본에서 수행할 수 있도록 커넥션을 분배시켜 성능을 향상시킨다.

복제본으로 맺어지는 커넥션을 READONLY 모드로 변경해 클라이언트가 복제본 노드에 있는 데이터를 직접 읽을 수 있게 할 수 있다.
```
redis-cli -h 192.168.0.55 -c
192.168.0.55:6379> readonly
OK
```

## 레디스 클러스터 동작 방법

### 하트비트 패킷
레디스 클러스터 노드들은 지속적으로 서로의 상태를 확인하기 위해 PING, PONG 패킷을 주고 받는다.
이 두 패킷을 묶어서 하트비트 패킷이라 하며 일반적으로 클러스터가 주고받는 유형의 패킷에 가십 섹션이 추가된 형태를 띈다.
![[KakaoTalk_Photo_2025-10-14-23-47-07.jpeg|550]]
- 현재 에포크/구성 에포크 : 분산 환경에서 일관성을 유지하기 위한 정보
- 노드 플래그 : 노드가 마스터인지 복제본인지 등의 노드 정보
- 비트맵 : 마스터가 제공하는 해시슬롯의 비트맵 정보, 복제본인 경우 마스터의 정보
- TCP 포트 : 발신 노드의 TCP 포트
- 클러스터 포트 : 발신 노드의 노드 간 커뮤니케이션을 위한 포트
- 클러스터 상태 : 발신 노드 관점에서 봤을 때의 클러스터 상태(down/ok)
- 마스터 노드 ID : 복제본 노드인 경우 마스터의 ID

하트비트 패킷의 경우 위의 패킷 헤더에 가십 섹셕은 추가로 포함하고 있다.
이 섹션은 패킷을 발신하는 노드가 알고 있는 클러스터 내의 다른 노드 정보를 나타낸다.
발신자 노드는 자신이 알고 있는 노드 중 랜덤한 몇 개의 노드만 가십 섹션에 포함한다.
하트비트 패킷을 받은 노드는 다른 노드에 대한 정보를 얻을 수 있으며 알지 못했던 다른 노드를 받아들일 수 있으며 장애도 감지할 수 있게 된다.

노드 간 구성의 정합성을 유지하기 위해 레디스 클러스터는 에포크 개념을 사용한다.
에포크는 클러스터에서 여러 이벤트의 순서를 나타내는 값으로 0부터 시작해 1씩 증분하며 레디스 클러스터의 논리적 클락이라고 볼 수 있다.
이 값이 클수록 최신 구성을 갖고 있는 노드라는 것을 의미한다.

다른 노드들과 통신을 하며 패킷에 들어 있는 어포크 값을 확인하게 되는데 이때 수신받은 패킷의 에포크 값이 로컬 노드의 값보다 크다면 에포크를 변경한다.
모든 노드는 끊임없이 PING/PONG을 주고 받기 때문에 결국 모든 노드는 가장 큰 에포크 값으로 통일 된다.

### 해시슬롯 구성이 전파되는 방법
클러스터에서 해시슬롯의 구성은 두 가지 방법으로 전파된다.
1. 하트비트 패킷 : 마스터 노드가 PING,PONG의 패킷을 보낼 때 항상 자기가 갖고 있는 해시슬롯을 패킷 데이터에 추가
2. 업데이트 메시지 : 하트비트 패킷에는 발신하는 노드의 구성 에포크 값이 포함돼 있으며 패킷을 보낸 노드의 에포크 값이 오래됐다면 해당 패킷을 받은 노드는 신규 에포크의 구성 정보를 포함한 업데이트 메시지를 노드에 보내 하트비트 패킷을 보낸 노드의 해시슬롯 구성을 업데이트

해시슬롯 구성의 변경은 페일오버와 리샤딩 중에만 발생한다.
페일오버와 리샤딩하는 작업 모두 에포크가 증가하는 작업이기 때문에 작업 이후 변경 사항을 클러스터 전체에 전파시킨다.
클러스터의 모든 노드는 가장 큰 구성 에포크 값을 가진 노드에 동의하기 때문에 클러스터 내의 모든 노드 값을 업데이트 시킬 수 있다.

### 노드 핸드셰이크
한 노드가 클러스터에 합류하기 위해서는 cluster meet 커맨드를 다른 노드에 보낸다.
해당 커맨드를 수신한 노드는 자신이 알고 있는 다른 노드들에게 전파하고 이 정보를 수신한 노드가 신규 합류한 노드를 모르는 상태라면
해당 노드와 cluster meet을 통해 신규 연결을 맺게 된다.
이와 같은 방식으로 클러스터 내부의 모든 노드들은 풀메쉬 연결을 하게 된다.
cluster meet은 방향성이 없기 때문에 A가 B에게 보내 연결됐다면 B가 A에게 같은 커맨드를 보낼 필요는 없다.

이러한 과정을 거쳐 노드끼리는 완전히 연결될 수 있으며 이미 알고 있는 노드들끼리만 통신을 주고 받기 때문에 
클러스터 외부의 다른 클러스터와 우연히 연결되는것을 방지할 수 있다.

### 클러스터 라이브 재구성
클러스터에 노드를 추가하고 삭제하는 작업은 동일한 작업으로 여겨질 수 있다.
- 추가 : 빈 노드를 클러스터에 추가한 뒤 일부 해시슬롯을 기존 마스터에서 신규 노드로 옮긴다.
- 제거 : 해당 노드를 빈 노드로 만들기 위해 갖고 있던 해시슬롯을 다른 노드로 보낸다.

두 작업 모두 결국 하나의 노드 내에서 해시슬롯을 다른 노드로 옮기는 작업이 동반된다.

A가 갖고 있던 해시슬롯 8을 B로 옮기고 싶다면 각 노드에서 다음과 같은 커맨드가 수행된다.
```
A에게 : cluster setslot 8 migrating B
B에게 : cluster setslot 8 importing A
```
만약 위 커맨드가 실행 중 노드 A가 해시슬롯 8에 대한 읽기 쿼리를 받는다면 A가 수행하고 쓰기 쿼리라면 B 노드로 리디렉션 한다.

또한 레디스는 해시슬롯 8에 속한 키를 A에서 B로 마이그레이션 한다.
```
cluster getkeyinslot slot count
>> 지정한 해시슬롯이 가지고 있는 키를 반환하며 반환된 모든 키에 대해 노드 A에 MIGRATE 커맨드를 전송한다.
```
다음 커맨드는 키를 원자적으로 A에서 B로 마이그레이션한다.
2개의 인스턴스는 모두 락이 걸리며 이로 인한 경쟁 상황은 발생하지 않는다.

```
MIGRATE target-host target-port key target-database id timeout
```
MIGRATE는 대상 인스턴스에 연결해서 키를 전송하고 OK 코드를 받으면 기존 데이터셋에서 키를 삭제한다.
마이그레이션 프로세스가 완료되면 두 노드에게 모두 setslot slot NODE node-id 커맨드를 전송한다.
이 커맨드는 다른 모든 노드에게 전파된다.

### 리디렉션
레디스 클러스터가 반환하는 리디렉션에는 MOVED 리디렉션과 ASK 두 가지 종류가 있다.
MOVED 리디렉션은 클라이언트에게 '요청하는 해시슬롯이 저 노드에 있으니 앞으로 이 키에 대한 요청은 저 노드로 보내' 라는 것을 의미한다.
ASK 리디렉션은 '지금 요청한 이 쿼리는 저 노드에서 수행해 하지만 다음 쿼리는 다시 나한테 보내' 라는 의미이다.

#### MOVE 리디렉션
레디스 노드는 클라이언트가 보낸 커맨드가 단일 키 커맨드인지 다중 키 인지 확인하고 다중 키인 경우 언급된 모든 키가 동일한 슬롯에 있는지 파악한 뒤
키가 속한 해시슬롯을 포함한 마스터 노드를 찾는다.

만약 해당 키를 받은 노드가 그 해시슬롯을 포함하고 있다면 데이터를 바로 반환하고
아니라면 해시슬롯 맵을 확인한 후 MOVED 에러로 클라이언트에 응답한다.
```
GET x
-MOVED 2345 192.168.0.22:6379
```
이 때 MOVED 에러는 키의 해시슬롯과 해당 슬롯을 가지고 있는 마스터 노드를 반환한다.
클라이언트는 반환받은 노드의 IP와 포트로 다시 커맨드를 수행해 조회한다.

이때 클라이언트는 해시슬롯 2345가 22번 노드에 존재한다는 것을 기억하고 이후 애플리케이션이 이 키를 다시 조회하려고 하면 바로 올바른 마스터 노드로 조회한다.
클러스터가 안정적일 때 모든 클라이언트는 해시슬롯, 노드의 맵을 갖고 있으며 이때 올바른 노드를 직접 찾아갈 수 있어 SPOF가 없는 효율적인 서비스로 사용할 수 있다.

#### ASK 리디렉션
ASK 리디렉션은 해시슬롯이 이동되는 과정에서만 발생한다.
이 리디렉션을 받은 클라이언트는 다음과 같이 동작한다.
- 리디렉션 오류가 반환한 노드 정보로 쿼리를 재전송하지만 이후에 같은 키에 대한 쿼리가 들어오면 기존에 전송한 노드에 다시 보낸다.
- 리디렉션을 받은 값으로 클라이언트의 해시슬롯 맵을 업데이트하지 않는다.
![[KakaoTalk_Photo_2025-10-15-00-38-34.jpeg|700]]
그림은 해시슬롯 8을 B로 옮기는 과정을 나타낸다.
해시슬롯을 옮기는 도중 해시슬롯 8에 있는 user:1을 조회하는 요청이 B에게 왔다.
B는 ASK 리디렉션을 보내는데 이때는 MOVED가 아닌 ASK를 보낸다.
마이그레이션이 완료되면 8번 해시슬롯은 B로 이동되므로 그 후의 요청은 B로 전송되어야 한다.
따라서 '지금 요청한 이 쿼리는 저 노드에서 수행해 하지만 다음 쿼리는 다시 나한테 보내'의 뜻이 해당 그림으로 설명이 된다.

### 장애 감지와 페일 오버
레디스 클러스터에서는 대부분의 노드가 특정 노드에 접근할 수 없다는 것을 인지하면 해당 노드의 상태를 변경한다.
장애 감지에 사용되는 플래그는 PFAIL과 FAIL 두 가지 플래그이며 PFAIL은 일부 노드에서 접근할 수 없는 확실하지 않은 실패이고
FAIL은 대부분의 노드에서 해당 노드에 장애가 발생했음을 동의한 상태이다.

#### PFAIL 플래그
특정 노드에 NODE_TIMEOUT 시간 이상 도달할 수 없는 경우 해당 노드에 PFAIL 플래그로 표시한다.
마스터, 복제본 관계 없이 클러스터 내의 모든 노드들은 다른 노드를 PFAIL로 표시할 수 있다.

노드에 도달할 수 없다는 것은 해당 노드에 PING 패킷을 보냈지만 NODE_TIMEOUT 시간보다 더 오랫동안 PONG을 받지 못한 상태를 의미한다.
따라서 노드 간 왕복시간(RTT, Rount Trip Time)보다 NODE_TIMEOUT이 더 커야 한다.
PING을 보낸 뒤 NODE_TIMEOUT의 절반 시간 동안 PONG을 받지 못했을 때 해당 노드에게 다시 PING을 보내는 방식으로 안정성을 향상시킨다.
#### FAIL 플래그
FAIL 상태일때 실제로 페일오버를 트리거한다.
A노드가 노드 B를 PFAIL 상태로 플래깅했다면 이후 클러스터 내의 다른 노드가 보낸 하트비트 패킷에서 B의 상태에 대한 정보를 듣는다.
다른 노드에서 B에 대한 PFAIL 또는 FAIL 알람을 받으면 이 노드를 FAIL이라 플래깅한다.

### 복제본 선출
다음과 같은 조건에서 복제본은 페일오버를 직접 시도한다
- 마스터가 FAIL 상태
- 마스터는 1개 이상의 해시슬롯을 갖고 있다.
- 마스터와 복제가 끊어진 지 오래다.

위 조건을 모두 만족했을 때 복제본은 마스터로 선출되기 위해 자신의 현제 에포크 값을 1 증가 시키고 마스터 인스턴스에 투표를 요청한다.

1. 우선 복제본은 클러스터의 모든 마스터 노드에 FAILOVER_AUTH_REQUEST 패킷을 보내 투표를 요청
2. 요청을 받은 마스터는 FAILOVER_AUTH_ACK 패킷으로 긍정적인 응답을 보내 투표에 동의함을 알린다.
3. 마스터는 동시에 다른 복제본을 승격시키는 것을 방지하기 위해 NODE_TIMEOUT X 2의 시간 동안은 같은 마스터로 승격되고자 하는 다른 복제본에게 투표할 수 없다.
4. 응답을 받은 복제본은 현재 에포크 값보다 작은 에포크로 온 AUTH_ACK에 대한 응답은 무시하기 때문에 이전 버전의 투표에 대한 응답은 거를 수 있다.
5. 다수의 마스터로부터 ACK를 받은 복제본이 마스터 후보로 선출되며 NODE_TIMEOUT X 2의 시간 동안 과반수 이상의 마스터에게 ACK가 오지 않는다면 페일오버는 중단된다.
6. 이후 NODE_TIMEOUT X 4의 시간 만큼 지연 후에 다시 새로운 투표를 시도할 수 있다.

마스터가 FAIL 상태가 된 이후 복제본은 다음과 같이 계산된 짧은 딜레이를 가진 뒤 투표를 시작한다.
```
DELAY = 500ms + 랜덤 지연 시간(0~500ms) + SLAVE_RANK * 1000ms
```
랜덤한 지연 시간을 이용해 같은 마스터에 연결된 여러 복제본에서 동시에 투표를 시작하는 것을 방지할 수 있다.
SLAVE_RANK는 마스터에서 처리한 복제 데이터의 양과 관련된 복제본의 우선순위이다.
마스터가 FAIL이 된 상태가 되면 복제본끼리 메시지를 교환하는데 가장 최근의 오프셋을 가진 복제본이 0순위, 두 번재는 1순위 같은 방식으로 우선순위를 부여한다.
