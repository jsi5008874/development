
## sorted set을 이용한 실시간 리더 보드
리더보드란 경쟁자들의 순위와 점수를 보여주는 순위표를 의미

### 리더보드의 유형

**절대적 리더보드**
서비스의 모든 유저를 정렬시켜 상위권의 목록만 표시

**상대적 리더보드**
사용자마다 다른 데이터를 표시
ex) 사용자가 속한 그룹 내에서 또는 특정 경쟁자와의 스코어 대결에서 상대적인 순위를 제공

### 리더보드의 특징
1. 실시간으로 데이터가 반영 필요
	사용자의 스코어 변경이 발생하면 사용자가 변경된 순위를 바로 확인해야한다.
	실시간으로 수학적 계산을 빠르게 수행하고 변경된 내용으로 최신화가 필요하다.
2. 높은 읽기 빈도
	많은 사용자들이 리더보드를 조회하고 쓰기보다는 읽기 요청이 상대적으로 훨씬 많다.
3. 데이터가 증가할 수록 처리해야 하는 데이터 크기가 기하급수적으로 늘어난다.
```
1. 순위 재계산 연쇄 효과
1명의 점수 변화가 여러 데이터에 영향을 줄 수 있다.
ex)
사용자가 10명일 때 1명의 순위가 바뀌면 최대 9개의 데이터 순위에 변동이 생기지만
사용자가 1000명이라면 1명의 순위가 바뀌면서 수백명의 데이터 순위에 변동이 생길 수 있음

2. 정렬 알고리즘의 복잡도
단순 정렬의 경우
- 10명 정렬: 약 33번의 비교
- 100명 정렬: 약 664번의 비교
- 1000명 정렬: 약 9965번의 비교
  
데이터가 10배 늘면 처리량은 10배보다 더 큰 폭으로 증가
```


### 리더보드에서 sorted set을 활용하는 이유
결국 리더보드는 정렬되어 있는 데이터를 사용자에게 보여주는 기능이다.
레디스의 sorted set은 데이터가 저장될 때 부터 정렬돼 들어가기 때문에 리더보드에서 데이터를 읽어올 때 매번 정렬할 필요가 없다.

정렬 작업은 큰 처리량을 요구하는 작업으로 RDB에서도 병목 현상의 요인으로 자주 발견되는 부분이기도 하다.
리더보드에서는 sorted set을 이용해 따로 정렬 작업을 하지 않아도 바로 정렬된 데이터를 얻을 수 있어 성능상 이점때문에 활용한다.

**예시**
daily-score:<날짜>를 이용해 sorted set을 만들어서 활용
```
1. ZADD 커맨드를 통해 플레이어와 스코어를 sorted set에 저장
ZADD daily-score:220817 28 player:286

ZADD daily-score:220817 400 player:234

ZADD daily-score:220817 45 player:101

2. ZRANGE 커맨드를 통해 데이터 출력
ZRANGE daily-score:220817 0 -1 withscores
>> ZRANGE는 스코어가 낮은 순서부터 출력을 하기 때문에 상위권 점수를 보고싶다면
ZREVRANGE 커맨드를 사용하면 된다.

ZREVRANGE daily-score:220817 0 2 withscores
>> 내림차순으로 1~3위의 3개 데이터가 출력
```

### 데이터 업데이트
sorted set은 중복으로 저장되지 않으며 같은 아이템을 저장하면 기존 데이터를 새로운 데이터로 업데이트한다.

```
ZADD daily-score:220817 200 player:286
>> 286번 플레이어의 스코어를 28에서 200으로 변경
```
![[KakaoTalk_Photo_2025-09-14-16-30-35.jpeg|700]]
그림처럼 286번 플레이어의 스코어가 200으로 업데이트 되면서 순위도 변화됨

ZADD 외에 ZINCRBY 커맨드로 변경 가능
```
ZINCRBY daily-score:220817 100 player:24
>> 현재 스코어에서 100 증가 > 357점에서 457로 증가
```


### 랭킹 합산

**ZUNIONSTORE**
지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드

예시
![[KakaoTalk_Photo_2025-09-14-17-03-06.jpeg|925]]

```
주간 누적 랭킹을 구하는 경우
>> 일일 단위로 저장된 키들을 합쳐주는 작업이 필요

ZUNIONSTORE <생성할 키 이름> <합산할 키 개수> <합산할 키> ...

ex)
ZUNIONSTORE weekly-score:2208-3(생성할 키) 3(합산할 키 개수) daily-score:220815 daily-score:220816 
daily-score:220817
>> 22년 8월 3째주라는 키를 생성하는데 15, 16, 17 3일치의 키를 합산해서 생성
```

관계형 데이터베이스에서는 이런 주간 누적 랭킹을 구현하려면 아주 복잡한 절차를 거쳐야 하지만
레디스 sorted set을 활용하면 간단하게 구현할 수 있다.

**WEIGHTS 옵션**
ZUNIONSTORE 커멘드에서 데이터를 합칠 때 특정 키에 가중치를 줄 수도 있다.
```
8월 16일에 두 배 이벤트가 있었다면
ZUNIONSTORE weekly-score:2208-3(생성할 키) 3(합산할 키 개수) daily-score:220815 daily-score:220816 
daily-score:220817 weights 1 2 1
>> 각 키 별로 비율을 설정하여 가중치를 줄 수 있음
```

예시처럼 weights 옵션을 추가하면 220816 키의 스코어들은 두 배로 계산되어 합산된다.

## sorted set을 이용한 최근 검색 기록

### 예시
요구사항
1. 유저별로 다른 키워드 노출
2. 검색 내역은 중복 제거
3. 가장 최근 검색한 5개의 키워드만 사용자에게 노출

id가 123인 사용자의 검색 기록을 search-keyword:123이라는 키에 sorted set으로 저장
```
ZADD search-keyword:123 20221106143501 코듀로이
>> 검색 시간과 검색어를 저장

ZREVRANGE 커맨드를 이용해 가장 최근에 검색한 순서대로 데이터를 가져올 수 있음
>> 시간 순서대로 저장을 했기 때문에 검색한지 오래된 데이터일 수록 head쪽에 위치해 있어 REV를 사용해야 최신 검색어가 나온다.
```

**sorted set 크기 유지**
해당 예시에서는 5개의 키워드만 제공하므로 sorted set의 크기를 5개로 유지해야한다.
```
음수 인덱스를 활용하여 크기를 유지
음수 인덱스는 -1이 제일 마지막 값이므로 5개의 크기를 유지하려면 -6번 인덱스를 삭제해줘야한다.

ZADD search-keyword 20221106165302 버킷햇

ZREMRANGEBYRANK search-keyword -6 -6
>> 이렇게 ZADD로 데이터가 저장될 때 마다 -6번째 인덱스를 삭제해서 크기를 유지한다.
```

## sorted set을 이용한 태그 기능

태그 기능은 특정 게시물이 어떤 태그와 연관돼 있는지 확인하는 것 뿐만 아니라
특정한 태그를 포함한 게시물들을 확인하기 위한 기능도 있다.
### 예시
![[KakaoTalk_Photo_2025-09-14-17-53-04 001.jpeg|700]]
게시물-태그 구조

![[KakaoTalk_Photo_2025-09-14-17-53-04 002.jpeg|700]]
태그-게시물 구조

```
성격이 다른 두 개의 구조에 집합 연산 커멘드를 사용하면 효율적인 검색을 할 수 있다.

SINTER(교집합) tag:IT:posts tag:DataStore:posts
1) "47"
2) "53"
>> IT, DataStore 태그를 포함하는 게시글을 검색하는 커멘드
```
이처럼 sorted set을 사용하면 간단하게 태그 관리도 가능하며 더 효율적인 검색 성능을 가져올 수 있다.

## 랜덤 데이터 추출

### RANDOM 커맨드

**RANDOMKEY : 레디스에 저장된 전체 키 중 하나를 무작위로 반환** 
하나의 레디스 인스턴스에 저장된 전체 키 중 한개를 무작위로 반환하는 기능이라 별 의미가 없고 거의 사용되지 않음

**HRANDFIELD : hash에 저장된 아이템 중 무작위로 반환**
```
user:hash라는 키의 hash 자료 구조에 저장했다고 가정

HRANDFIELD user:hash
"ID:4615"
>> 지정된 hash 내에서 임의로 선택된 아이템을 추출


COUNT를 이용하면 원하는 개수만큼 랜덤 아이템이 반환
ex)
HRANDFIELD user:hash 2
1) "ID:4615"
2) "ID:134"
>> 키 뒤에 숫자를 넣으면 해당 숫자만큼 아이템을 반환해줌
COUNT에 음수를 사용하면 중복해서 반활될 수 있음


WITHVALUE 옵션을 사용하면 필드에 연결된 값도 함께 반환
ex)
HRANDFIELD user:hash 1 WITHVALUE
1) "ID:4615"
2) "jinnji"
```

 SRANDMEMBER(set), ZRANMEMBER(sorted set) 커맨드도 있으며 마찬가지로 COUNT 옵션과 WITHSCORE 옵션을 사용할 수 있다.

## 레디스에서의 다양한 카운팅 방법

### 좋아요 처리하기
트래픽이 많은 서비스에서 좋아요 기능은 1초에 많은 양이 발생할 수 있으며
좋아요를 누를 때마다 RDB 테이블의 특정 행에서 좋아요 개수 데이터를 증가시키는 일은 DB에 직접적인 영향을 끼칠 수 있다.

또한 하나의 유저가 한 게시물에 한 번식만 누를 수 있게 구현해야하므로 단순히 좋아요의 개수를 파악하는 것이 아닌 어떤 유저가
어떤 게시물에 좋아요를 눌렀는지에 대한 데이터도 처리할 수 있어야 한다.

이를 레디스의 set에서 간단히 활용할 수 있다.

![[KakaoTalk_Photo_2025-09-15-14-11-42.jpeg|700]]
그림처럼 게시물 또는 댓글 별로 set을 생성한 뒤 좋아요를 누른 유저의 id를 set에 저장하면 중복 없이 데이터를 저장 가능

```
SCARD comment-like:12554
(integer 3)
>> SCARD 커맨드로 게시물, 댓글 등 독립적인 set 구조별로 좋아요 개수를 카운팅 가능
```

### 읽지 않은 메시지 수 카운팅하기
앞선 좋아요 예제와 다르게 채팅의 내용을 확인하거나 중복된 데이터를 고려할 필요 없이 단순히 채널에 새로 추가된 메시지의 개수를 확인
따라서 사용자의 ID를 키로 사용하고 채널의 ID를 아이템의 키로 활용해 숫자 형태의 메시지 카운트를 관리
![[KakaoTalk_Photo_2025-09-15-14-21-57.jpeg|625]]
그림과 같이 계층 구조를 가지도록 설계
UserID > channelId > 스코어

```
HINCRBY user:234 channel:4234 1
>> 234번 유저의 4234 채팅방에 값을 1 증가
>> 이런식으로 메시지를 수신할 때마다 읽지 않은 메시지 수를 증가 시킨다.
>> 마지막 인자를 음수로 지정한다면 값을 감소실킬 수도 있다.
```

### DAU 구하기
DAU(Daily Active User)는 하루 동안 서비스에 방문한 사용자의 수를 의미
하루에 여러번 방문했더라도 한 번으로 카운팅되는 값으로 실제 서비스를 이용한 사용자의 유니크한 수를 파악할 수 있는 지표

앞선 좋아요 예제와 같이 set으로 구현할 수 있지만 트래픽이 높은 서비스라면 문제가 발생한다.
하루에 수백만명이 접속하는 사이트의 경우에는 set 하나에 수백만개의 데이터가 쌓이게 되는데 이는 성능저하와 메모리 낭비를 야기한다.

하지만 비트맵을 이용하면 메모리를 효율적으로 사용하면서 실시간으로 DAU를 처리할 수 있다.

비트맵을 활용하면 1명의 사용자를 1비트로 표현할 수 있기 때문에 1천만명의 사용자가 발생해도 1.2MB면 충분히 처리가 가능하다.

**예시**
![[KakaoTalk_Photo_2025-09-15-14-45-51.jpeg]]
2022.11.06에 방문한 유저를 구하기 위해 Uv:20221106인 키를 만들고 유저가 접속할 때 userID에 맞춰서 오프셋을 1로 변경
```
SETBIT uv:20221106 14 1
(integer) 0 >> 바뀌기 이전의 비트맵 값
>> 14번 오프셋을 1로 변경
>> userID가 14인 사용자가 접속 했을 때 14번 오프셋을 1로 변경해서 2022.11.06에 접속했다는 것을 표현


BITCOUNT uv:20221106
(integer) 3 >> 접속한 인원 수
>> 2022.11.06에 접속한 유저를 카운팅하는 BITCOUNT 커맨드
```

BITTOP 커맨드를 활용하면 AND, OR, XOR, NOT 연산을 수행할 수 있으며
레디스 서버에서 바로 계산된 결과를 가져올 수 있어 개별 비트를 서버로 가져와 따로 처리하는 번거로움을 줄여 줄 수 있다.
```
11월 1일 부터 11월 3일 까지 매일 출석한 유저를 확인하는 방법
BITTOP AND event:202211(AND의 결과를 저장하는 새로운 비트맵 구조) uv:20221101 uv 20221102 uv:20221103
>> AND 커맨드를 활용하면 연속 출석한 유저를 event:202211이라는 새로운 비트맵 구조에 얻을 수 있다.
```

**비트맵을 애플리케이션 서버에서 변환하는 법**
```
GET event:202211
"\x01\x02" >> 비트맵을 16진수로 표현한 string 데이터
```
비트맵을 레디스에서 조회하면 이렇게 16진수의 string 데이터로 표현된다.
이를 애플리케이션 서버에서 활용하려면 비트 연산을 통해 각 문자를 이진 비트로 변환해서 사용해야한다.
![[KakaoTalk_Photo_2025-09-15-15-07-35.jpeg|800]]
파이썬을 활용해 이진 비트로 변환한 예시

1. 위의 예시에서 비트맵에 저장된 "\x01\x02" 값을 문자 단위로 순회하면서 비트 연산을 수행
2. 각 문자를 이진 비트로 변환하고 모든 비트를 순회하면서 비트의 값을 추출
3. 추출된 비트 값을 bitslist에 저장

이렇게 레디스에서 16진수로 표현된 문자열을 애플리케이션 레벨에서 비트 값으로 변환해서 활용할 수 있다.

### hyperloglog를 이용한 애플리케이션 미터링
미터링 : 사용량을 측정하고 기록하는 시스템

클라우드 환경에서 미터링은 중요한 시스템이다.
사용자가 서비스를 얼마나 사용했는지 정확히 측정해야 그에 따른 요금을 부과하여 결제를 받을 수 있다.

이처럼 미터링 솔루션은 사용자의 서비스 사용 내역을 이용하기 때문에 대용량 데이터를 처리할 수 있어야 한다.
서비스의 규모에 따라 초당 수천 건 이상의 작업이 발생할 수 있으며 이에 따라 높은 처리량과 낮은 대기시간을 요구한다.

다음 조건을 만족한다면 레디스의 hyperloglog를 사용하는 것을 고려해볼 수 있다.
1. 집합 내의 유일한 데이터의 개수를 카운팅해야 한다.
2. 1% 미만의 오차는 허용 가능
3. 카운팅할 때 사용한 정확한 데이터는 다시 확인하지 않아도 된다.

이는 카디널리티를 확인하는 hyperloglog의 특징과 맞물린 조건들이다.
hyperloglog는 데이터 자체를 저장하는 것이 아닌 확률적 기법에 의해 단순 카운팅만 하는 자료 구조이기 때문이다.

**예시**
레디스에서 hyperloglog를 이용해 유저의 월별 API 호출 횟수를 계산
```
각 유저를 구분하는 ID를 키로 사용하고 API 호출할 때마다 저장되는 로그의 식별자를 hyperloglog에 저장

PFADD 202211:user:245 49483
(integer) 1
>> 245인 유저가 49483이라는 로그를 저장

PFADD 202211:user:245 32714

PFADD 202211:user"245 49483

PFCOUNT 202211:user:245
(integer) 2 >> 245번 유저에 저장된 카디널리티는 2

245번 유저가 49483을 두 번 저장하고 32714를 1번 저장했지만 중복은 제거되고 카운팅 되는 숫자는 2
```

hyperloglog는 set과 비슷하지만 용량은 12KB로 고정되기 때문에 공간을 효율적으로 사용할 수 있다는 이점이 있다.

```
PFMERGE 2022:user:245 202211:user:245 202212:user:245
"OK"
>> 여러 개의 hyperloglog를 합칠 수 있는 커맨드, 분기 또는 연도별 합산 데이터를 계산할 때 사용
```

## Geospatial Index를 이용한 위치 기반 애플리케이션 개발

### 위치 데이터란
주로 경도와 위도(x, y) 좌표 쌍으로 표현되며 공간 데이터를 처리하는 데이터이다.

최근 서비스들에서는 이런 위치 데이터를 실시간으로 처리하는 기능들이 필요하다.(지도, 네이게이션 등)
- 사용자의 현재 위치 파악
- 사용자의 이동에 따른 실시간 변동 위치 업데이트
- 사용자의 위치를 기준으로 근처의 장소 검색

이런 특성은 간단해 보이지만 사용자가 늘어나면 처리할 데이터는 기하급수적으로 늘어난다.
모든 사용자의 정보를 1초마다 업데이트 한다고 가정한다면 사용자의 증가에 따른 데이터 처리량은 몇 십배로 증가한다.

### 레디스에서의 위치 데이터
레디스의 geo 자료 구조 장점은 메모리에서 빠르게 계산될 수 있다는 점이다.
RDB는 단순히 데이터를 저장할 뿐 실제 데이터 가공 및 처리는 저장소 외부에서 이루어지는데
레디스는 데이터 저장뿐만 아니라 실시간 위치 연산을 직접 수행할 수 있어서 애플리케이션 코드의 복잡성을 줄이고 빠른 응답 속도를 보장한다.

**geo set**
geo set은 위치 공간 관리에 특화된 데이터 구조로 각 위치 데이터는 경도와 위도의 쌍으로 저장
데이터는 내부적으로 sorted set으로 저장된다.
```
GEOADD 키 경도 위도 아이템명
ex)
GEOADD restaurant 50.07.... 14.41.... ukalendu
>> ukalendu라는 맛집을 레스토랑 키에 위치 데이터 저장

GEOPOS 키 아이템명
ex)
GEOPOS restaurant ukalendu
1) "50.07..."
2) "14.41..."
>> 키와 아이템 명을 통해 위치 데이터 검색

```

옵션으로 다양한 기준을 통해 검색할 수도 있다.
```
GEOSEARCH 키 옵션 경도 위도 [byradius/BYBOX] 인자 길이단위
ex)
GEOSEARCH restaurant fromlonlat 50.06... 14.41... byradius 1 KM
1) "ukalendu"
>> fromlonlat 옵션으로 지정한 경도 위도 기준으로 반경 1KM 이내에 restaurant 키에 존재하는 위치 데이터를 검색

FROMMEMBER 옵션
동일한 키 내에서 FROMMEMBER 옵션을 이용하면 위도와 경도를 직접 입력하지 않아도 원하는 데이터를 찾을 수 있다.
ex)
GEOSEARCH restaurant FROMMEMBER "ukalendu" BYRADIUS 1 KM
1) "ukalendu"
2) "masaa"
>> restaurant 키 내부에 ukalendu 위치를 기준으로 반경 1KM 이내에 있는 멤버를 조회

BYBOX 옵션
BYRADIUS는 반경을 기준으로 원형 모양의 위치 데이터를 산출한다면
BYBOX는 width, height를 입력하여 사각형 모양의 위치 데이터를 산출

GEOSEARCH key 옵션 경도 위도 BYBOX width height 길이단위
ex)
GEOSEARCH restaurant FROMMEMBER ukalendu BYBOX 4 2 KM
1) "ukalendu"
2) "masaa"
```
![[KakaoTalk_Photo_2025-09-15-16-25-54.jpeg|800]]
