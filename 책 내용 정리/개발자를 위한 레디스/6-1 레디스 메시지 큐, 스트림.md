
최근 서비스 아키텍처는 여러 모듈이 서로 느슨하고 적절하게 연결시킨 구조를 선호한다.
이런 구조는 모듈간 탄탄한 상호 작용이 필요하기 때문에 효율적인 메세징 솔루션, 즉 메시지 브로커를 필요로 한다.

모듈 간 통신에서는 되도록 비동기 통신을 사용하는 것을 권장하며 서비스간 통신이 불가능한 상황이 바로 장애로 이어지지 않게
당장 메시지를 처리하지 못하더라도 메시지를 어딘가에 쌓아놓고 나중에 처리할 수 있는 채널을 만들어 주는것이 메시지 브로커의 핵심 역할이다.

## 메시징 큐와 이벤트 스트림

![[KakaoTalk_Photo_2025-09-21-12-37-28 001.jpeg]]
메시징 큐에서 데이터를 생성하는 쪽을 생산자 데이터를 수신하는 쪽을 소비자로 지칭한다.

![[KakaoTalk_Photo_2025-09-21-12-37-28 002.jpeg]]
이벤트 스트림에서는 데이터를 생성하는 쪽을 발행자 데이터를 조회하는 쪽을 구독자로 지칭한다.

**메시징 큐와 이벤트 스트림의 차이점**
1. 방향성
	메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸쉬
	2개의 서비스에 같은 메시지를 보내야 한다면 생산자는 각각 다른 메시징 큐에 데이터를 푸쉬해야한다.
	반면 스트림은 특정 저장소에 하나의 메시지를 보낼 수 있고 필요한 소비자들이 스트림에서 메시지를 pull 한다.
2. 데이터 영속성
	메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제
	스트림에서는 바로 삭제되지 않고 저장소의 설정에 따라 특정 기간동안 저장

메시지를 보내는 도중 새로운 소비자를 추가할 때 메시징 큐를 이용한다면
새로 추가된 소비자는 추가된 시점 이후의 이벤트만 확인 가능하다.
```
ex)
생산자가 소비자 A에게 1이라는 메시지를 보낸 후 소비자 B가 추가된다면
B는 1이라는 메세지를 볼 수 없다.
```

하지만 스트림 방식은 스트림에 쌓인 데이터는 일정 기간동안 지워지지 않아서 새로 추가된 서비스도 확인 가능

메시징 큐는 1:1 상황에서 유용하고 스트림은 다대다 상황에서 유리하다.

**레디스를 메시지 브로커로 사용하기**
레디스에서 제공하는 pub/sub을 사용하면 빠르고 간단한 방식으로 메시지 브로커를 구현할 수 있다.

발행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소모할 수 있다.
레디스의 pub/sub은 모든 데이터가 한 번 채널에 전파된 뒤 삭제되는 일회성의 특성을 가진다.
메시지가 잘 전달되었는지 등의 정보는 보장하지 않으며 완벽하게 전달되어야 하는 상황에서는 적합하지 않다.
fire-and-forget 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용된다.
```
fire-and-forget 패턴
비동기 프로그래밍에서 사용되는 디자인 패턴
어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음코드를 실행하는 것을 의미
로깅, 이벤트 발행, 통계 데이터 수집과 같이 작업의 성공 또는 실패에 대한 관심이 없는 경우 활용
```

레디스의 list 자료 구조는 메시징 큐로 사용하기에 알맞다.
list의 데이터는 푸쉬, 팝이 가능하며 애플리케이션은 list에 데이터가 있는지 매번 확인할 필요 없이
대기하다가 list에 새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능을 사용할 수 있다.

레디스의 stream을 사용하면 레디스를 완벽한 스트림 플랫폼으로 활용할 수 있다.
레디스의 stream은 아파치 카프카에서 영감을 받아 만들어진 자료 구조이다.
데티어는 계속해서 추가되는 방식으로 저장(append-only)
소비자와 소비자 그룹이라는 개념을 이용하면 카프카와 비슷하게 데이터 분산 처리를 구현할 수 있다.
stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수도 있으며 저장돼 있는 데이터를 시간대별로 검색 가능하다.

## 레디스의 pub/sub
레디스 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다.

레디스의 pub/sub은 매우 가볍기 때문에 최소한의 메시지 전달 기능만 제공한다.
발행자는 메시지를 채널로 보낼 수 있을 뿐 구독자가 메시지를 읽는지 정상적으로 전달됐는지 알 수 없다.
구독자 또한 메시지가 언제 어떤 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.

한 번 전파된 데이터는 저장되지 않으며 단순히 메시지 통로 역할만 한다.
정합성이 중요한 데이터를 전달하기에는 적합하지 않을 수 있다.

### 메시지 publish 하기
PUBLISH 커맨드 이용
```
PUBLISH hello world
(integer) 1
>> hello라는 채널을 수신하고 있는 모든 서버들에 world라는 메시지가 전파된다.
>> 메시지를 수신한 구독자의 수가 반환된다.
```

### 메시지 구독하기
SUBSCRIBE 커맨드 이용
```
SUBSCRIBE event1 event2
Reading message...
1) "subscribe"
2) "event1"
3) (integer) 1
4) "subscribe"
5) "event2"
6) (integer) 2
>> event1과 event2 채널을 동시에 구독
```
클라이언트가 구독자로 동작할 때는 pub/sub 외에 다른 커맨드를 수행할 수 없다.

PSUBSCRIBE 커맨드
```
PSUBSCRIBE mail-*
>> 패턴에 일치하는 채널을 한번에 구독
```
이때 메시지는 message가 아닌 pmessage 타입으로 전달되며 SUBSCRIBE 방식으로 메시지를 구독하는 것과 구분된다.
![[KakaoTalk_Photo_2025-09-21-13-33-00.jpeg]]
그림과 같이 구독자가 SUBSCRIBE와 PSUBSCRIBE로 동시에 mail-1을 구독하고 있을 때
구독자는 message 타입, pmessage 타입 2개의 메시지를 받게 된다.

### 클러스터 구조에서의 pub/sub
레디스 클러스터에서 pub/sub을 사용할 때 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 전달
따라서 클러스터의 아무 노드에 연결해 SUBSCRIBE하면 데이터를 수신할 수 있다.
![[KakaoTalk_Photo_2025-09-22-13-01-25 001.jpeg|775]]
그림과 같이 클러스터에서 하나의 노드에 메시지를 발행하면 모든 노드에 전파된다.
하지만 클러스터의 주요 목적을 고려했을 때 이 방법은 비효율적이다.
클러스터는 주로 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위한 시스템인데 모든 레디스 노드에 데이터가 복제되는 것은 옳지 않다.
이는 불필요한 리소스 사용과 네트워크 부하가 발생된다.

### shared pub/sub
shared pub/sub은 각 채널이 슬롯에 매핑된다.
```
채널 : pub/sub에서 메시지가 전달되는 논리적인 경로


슬롯 : 레디스 클러스터에서 데이터 분산 저장을 위한 가상의 공간 단위
Redis 클러스터는 16,384개의 슬롯으로 구성됨 (0 ~ 16383)

ex) 3노드 클러스터:
├── 노드1: 슬롯 0 ~ 5460
├── 노드2: 슬롯 5461 ~ 10922  
└── 노드3: 슬롯 10923 ~ 16383

채널이 특정 슬롯에 매핑되어 처리되는 구조
ex)
1. 주문 관련 메시지 : "order" 채널
2. "order" 채널은 슬롯 1234에 매핑됨
3. 주문 관련 메시지는 노드 1번에 저장됨
```
![[KakaoTalk_Photo_2025-09-22-13-01-26 002.jpeg|775]]
SPUBLISH 커맨드로 발행된 메시지는 모든 노드에 전파되지 않고 노드의 복제본에만 전달된다.
```
10.0.0.1:6379> SPUBLISH apple a
-> Redirected to slot [7092] located at 10.0.0.2:6379
(integer) 1
10.0.02:6379
>> 로컬에서 redis-cli 클라이언트를 이용해 데이터를 전파하려고 할 때 연결된 노드에서 지정한 채널에 전파할 수 없다는 메시지와 함께
>> 연결된 노드로 리다이렉트 된다.
>> 즉 노드별로 정해진 채널이 있으며 해당 채널을 통하지 않으면 발행이 불가하다.
```

SSUBSCRIBE도 마찬가지로 특정한 서버에서만 수행될 수 있다.
```
10.0.0.1:6379> SSUBSCRIBE apple
-> Redirected to slot [7092] located at 10.0.0.2:6379
Reading messages...
>> 동일하게 접근 가능한 노드로 리다이렉트 된 후 메시지를 읽는다.
```

## 레디스의 list를 메시징 큐로 사용하기

### list의 EX 기능
인스타그램, 트위터, 페이스북 같은 SNS에는 각 유저별 타임라인이 존재하며 자신이 팔로우한 계정의 게시물 혹은 관련 있는 게시물등이 표시된다.
모든 유저는 각자 다른 타임라인을 가진다는 뜻이다.

트위터는 각 유저의 타임라인 캐시 데이터를 레디스에서 list 자료 구조로 관리한다.
![[KakaoTalk_Photo_2025-09-22-13-33-05.jpeg|750]]
유저 A가 새로운 트윗을 작성하면 그 데이터는 A를 팔로우하는 유저의 타임라인 캐시에 저장된다.

이 때 각 타임라인 캐시에 데이터를 저장할 때 RPUSH가 아닌 RPUSHX 커맨드를 사용한다.
```
RPUSHX Timelinecache:userB data3
(integer) 26
>> RPUSHX는 저장하고자 하는 list가 이미 존재할 때만 아이템을 추가하는 커맨드
>> 이 커맨드를 사용하면 이미 캐시된(이미 키가 존재하는) 타임라인데만 데이터를 추가할 수 있다.
>> 자주 트위터를 들어오지 않는 유저 D에 대해서는 캐시 데이터를 굳이 관리할 필요가 없기 때문이다.
```
이는 캐시가 존재하는지 유무를 애플리케이션에서 확인할 필요 없이 레디스에서 제어하기 때문에 성능을 향상 시킬 수 있다.

### list의 블로킹 기능
이벤트 기반 구조에서 시스템은 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 체크한다.
![[KakaoTalk_Photo_2025-09-22-14-39-14 001.jpeg|850]]
이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 체크하며 새로운 이벤트가 없을 경우 정해진 시간동안 대기한 뒤 다시 확인하는 과정을 반복한다.
이런 작업을 폴링이라 하며 폴링이 진행되는 동안 애플리케이션과 큐의 리소스가 불필요하게 소모된다.
또한 폴링 인터벌 시간동안 대기한 뒤 다시 확인하기 때문에 실시간으로 처리가 어렵다는 단점이 있다.

이 때 list의 블로킹 기능을 사용하면 된다.
BRPOP과 BLPOP은 각각 RPOP과 LPOP에 블로킹을 추가한 커맨드이다.

BLPOP을 사용하면 데이터를 요청했을 때 list에 데이터가 있으면 즉시 반환,
없으면 데이터가 들어올때 까지 대기하거나 지정한 타임아웃까지 대기 후 nil 값을 반환한다.
```
BRPOP queue:a 5
1) "queue:a"
2) "data"
>> 5초 동안 대기하고 경과하면 nil을 반환하라는 의미
>> 0을 넣으면 데이터가 들어올 때 까지 무한 대기하라는 뜻
>> BRPOP은 RPOP과 다르게 2개의 데이터를 반환, 첫 번째는 키를 반환하고 두 번째는 데이터를 반환한다.
```

![[KakaoTalk_Photo_2025-09-22-14-39-14 002.jpeg|850]]
2개의 데이터를 반환하는 이유는 그림과 같이 여러 개의 리스트에서 대기할 수 있게 하기 위해서다.

### list를 이용한 원형 큐
만약 특정 아이템을 반복 접근해야 하는 클라이언트 혹은 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 클라이언트에서는
원형 큐를 이용해 아이템을 처리할 수 있다.
![[KakaoTalk_Photo_2025-09-22-14-49-12.jpeg|750]]
RPOPLPUSH 커맨드를 사용하면 간편하게 원형 큐를 사용할 수 있다.
```
clist의 배열 순서가 [C, B, A]라고 가정했을 때

RPOPLPUSH clist clist
"A"
>> 첫 번째 clist 커맨드에서 RPOP으로 리스트의 오른쪽 끝 요소를 제거하고
>> 두 번째 clist 커맨드에서 LPUSH로 리스트의 왼쪽 끝 요소에 추가하여 원형 큐를 구현
>> 두 번째 clist 커맨드에서 넣는 데이터는 첫 번째 clist 커맨드에서 제거한 데이터를 그대로 사용

LRANGE clist 0 -1
1) "A"
2) "C"
3) "B"
>> 배열 순서가 C, B, A에서 A, C, B로 변경
```

