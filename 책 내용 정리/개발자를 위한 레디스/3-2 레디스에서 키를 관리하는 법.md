## 키의 자동 생성과 삭제
stream, set , sorted set, hash와 같이 하나의 키가 여러 개의 아이템을 가지고 있는 자료 구조에서는
명시적으로 키를 생성하거나 삭제하지 않아도 키는 알아서 생성되고 삭제된다.

### 키의 생성과 삭제의 공통적인 규칙
1. 키가 존재하지 않을 때 아이템을 넣으면 아이템을 삽입하기 전에 빈 자료 구조를 생성
	키가 존재하지 않을 때 LPUSH 커맨드로 입력하면 키를 생성하지 않아도 자동으로 자료 구조가 생성됨
	저장하고자 하는 키에 다른 자료 구조가 이미 생성돼 있을 때 아이템을 추가하면 에러를 반환
```
SET hello world >> 문자열

LPUSH hello 1 2 3 >> 정수
이렇게 다른 자료 구조를 삽입하면 오류가 발생
```
2. 모든 아이템을 삭제하면 키도 자동 삭제(stream 예외)
3. 키가 없는 상태에서 키 삭제, 아이템 삭제, 읽기 전용 커맨드를 수행하면 에러 대신 키가 있으나 아이템이 없는 것처럼 동작
```
DEL mylist
(integer) 0

LLEN mylist
(integer) 0

LPOP mylist
(nil)
```

## 키와 관련된 커맨드

### 키의 조회
**EXISTS : 키가 존재하는지 확인하는 커맨드**
```
EXIST key [key ....]
키가 존재하면 1, 존재하지 않으면 0

EXIST hello
(integer) 1 >> hello라는 키가 존재
```

**KEYS : 레디스에 저장된 모든 키를 조회, 매칭되는 패턴에 해당하는 모든 키를 list로 반환**
```
*     → 0개 이상의 모든 문자와 매치
?     → 정확히 1개의 문자와 매치  
[...] → 괄호 안의 문자 중 하나와 매치
[!...] → 괄호 안의 문자를 제외한 문자와 매치

ex)
# * 패턴
user*        → user, user123, username, user_data 매치
*user        → myuser, newuser, admin_user 매치  
*user*       → user123, myuser, user_admin 매치

# ? 패턴
user?        → user1, user2, userA 매치 (정확히 5글자)
user??       → user01, user99, userAB 매치 (정확히 6글자)

# [문자집합] 패턴
user[123]    → user1, user2, user3 매치
user[a-z]    → usera, userb, userz 매치
user[!123]   → user4, user5, usera 매치 (1,2,3 제외)
```

KEYS는 모든 키의 정보를 반환하기 때문에 잘못 쓰이면 성능에 문제가 생길 위험이 있다.
사용할 때 조심해서 사용해야한다.

**SCAN : KEYS를 대체해 키를 조회하는 커맨드, 특정 범위의 키만 조회**
```
SCAN 0
1) "17"
2) 1) "key:12"
   3) "key:8"

1번에 반환된 숫자(17)는 SCAN 커맨드를 사용할 때 인수로 사용해야할 위치다.
그 다음으로 반환된 데이터가 저장된 키의 list이다.

SCAN은 마치 페이지 개념처럼 일정 갯수만큼 잘라서 조회를 한다.
즉 17과 같은 인수는 다음 페이지를 가르키는 포인터 개념으로 생각하면 된다.


SCAN 17
1) "0"
2) 1) "key:5"
   3) "key:18"

다시 0이 나온것은 모든 키를 반환해서 더 이상 검색할 키가 없다는 뜻이다.

기본적으로 한 번에 반환되는 것은 10개 정도지만 COUNT 옵션을 사용해서 조절할 수 있다.

```

SCAN에 MATCH 옵션을 사용하면 KEYS 처럼 패턴을 이용하여 조회가 가능하다.
```
SCAN 0 match *11*
1) "48"
2) 1) "key:115"
   
하지만 한 번에 패턴에 매칭된 여러 개의 키 값이 반환되지 않는다.
적은 수의 결과가 반환되거나 빈 값이 반환될 수도 있다.

SCAN + MATCH를 사용할 때는 우선 데이터를 필터링 없이 스캔한 다음 데이터를 반환하기 직전에 필터링 하는 방식으로 동작하기 때문이다.

즉 앞서 말한 페이지 개념으로 조회를 한 다음 해당 페이지에 일치하는 데이터를 필터링해서 반환하기 때문에
방금 조회한 48번에서는 115 한 개만 일치하는 데이터가 있어서 한 개만 조회가 된 것이다.
```

SCAN + TYPE 커맨드로 타입을 확인할 수도 있다.
```
SCAN 0 TYPE zset
1) "48"
2) (empty array)
   
zset(sorted set) 형식이 없는 것
```

SCAN 과 비슷한 커맨드로 SSCAN(set), HSCAN(hash), ZSCAN(sorted set)이 있다.

**sort : list, set, sorted set에서만 사용할 수 있는 커맨드로 아이템을 정렬해 반환**
```
SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ....]] [ASC | DESC] [ALPHA] [STORE destination]

BY pattern : 외부 키 기준 정렬
ex)
SORT user_ids BY user:*:age >> 나이 순으로 정렬

limit 옵션 : 일부 데이터 조회
ex) SORT scores DESC LIMIT 0 3(상위 3개 점수 조회)

GET pattern : 추가 데이터 조회
ex)
SORT user_ids BY user:*:age GET user:*:name
>> 나이와 이름을 같이 조회

asc/desc : 오름차순, 내림차순

alpha : 대상이 문자열이면 데이터를 사전 순으로 정렬해서 조회
ex)
SORT mylist ALPHA
1) "a"
2) "b"
   
STORE : 정렬 결과를 다른 키에 저장
ex)
SORT user_ids BY user:*:age STORE sorted_users
>> 조회된 결과를 sorted_users에 저장
```

**RENAME/RENAMENX**
```
RENAME : 이름 변경 커맨드
RENAMEX : 변경할 키가 존재하지 않을 때만 동작

ex)
RENAME a aa
OK >> a에서 aa로 이름 변경

a, b 두 개의 키가 존재할 때
RENAMEX a b
(integer 0) >> 변경되지 않음, b라는 키가 이미 존재하기 때문에 중복되서 변경 X
```

**COPY**
```
COPY source destination [DB destination-db] [REPLACE]
Source에 지정된 키를 destination 키에 복사
destination에 지정한 키가 이미 있는 경우 에러가 반환되는데 REPLACE 옵션을 통해 destination 키를 삭제한 뒤 값을 복사하여 에러 발생 하지 않음

ex)
COPY B BB
(integer) 1 >> B의 값이 BB로 복사됨
```

**TYPE : 지정한 키의 자료 구조 타입을 반환**
```
TYPE key
```


### 키의 삭제
**FLUSHALL : 레디스에 저장된 모든 키를 삭제**
```
FLUSHALL [ASYNC | SYNC]
기본적으로는 SYNC로 동작해 모든 데이터가 삭제된 경우에만 OK를 반환해서 커맨드가 실행되는 도중 다른 응답은 처리 불가

ASYNC로 하면 백그라운드로 실행되고 커멘드가 수행된 순간 존재했던 키만 삭제하고 실행 중 생성된 키는 삭제되지 않음


lazyfree-lazy-user-flush 옵션을 yes로 하면 ASYNC 옵션을 사용하지 않아도 백드라운드로 실행된다.
```

**DEL : 키에 저장된 모든 아이템을 삭제**
```
DEL key [key ...]
기본적으로 동기적으로 작동
```

**UNLINK : DEL과 비슷하지만 백그라운드에서 실행**
```
UNLINK key [key ...]

비동기로 작동하기 때문에 삭제할 양이 많은 경우에는 DEL 보다는 UNLINK 추천
```

### 키의 만료시간
**EXPIRE : 초 단위로 키 만료 시간을 정의**
```
EXPIRE key seconds [NX | XX | GT | LT]

NX : 해당 키에 만료 시간이 정의돼 있지 않을 경우에만 수행
XX : 해당 키에 만료 시간이 정의돼 있을 때만 수행
GT : 현재 키가 가지고 있는 만료 시간보다 새로 입력한 초가 더 클 때만 수행
LT : 현재 키가 가지고 있는 만료 시간보다 새로 입력한 초가 더 작을 때만 수행
```

**EXPIREAT : 키가 특정 유닉스 타임스탬프에 만료될 수 있도록 키의 만료 시간을 직접 지정**
```
EXPIREAT key unix-time-seconds [NX | XX | GT | LT]

유닉스 타임스탬프(Unix Timestamp)는 1970년 1월 1일 00:00:00 UTC부터 경과한 초의 개수를 나타내는 숫자
```

**EXPIRETIME : 키가 삭제되는 유닉스 타임스탬프를 초 단위로 반환**
```
EXPIRETIME key

만료될 유닉스 타임스탬프를 반환
ex)

SET mykey "value"
EXPIRE mykey 3600  # 1시간 후 만료

EXPIRETIME mykey
# 결과: 1705127056 (만료될 정확한 유닉스 타임스탬프)

# 2분 후 다시 확인
EXPIRETIME mykey
# 결과: 1705127056 (동일한 타임스탬프, 변하지 않음)

즉 절대적인 시각을 표현하는 커맨드
키가 존재하지만 만료 시간이 설정돼 있지 않은 경우에는 -1, 키가 없을 때에는 -2를 반환
```

**TTL : 키가 몇 초 뒤에 만료되는지 반환**
```
TTL key

SET mykey "value"
EXPIRE mykey 3600  # 1시간 후 만료

TTL mykey
# 결과: 3598 (남은 초수, 시간이 지나면서 감소)

# 2분 후 다시 확인
TTL mykey  
# 결과: 3478 (줄어든 남은 초수)

즉 상대적인 시각을 표현하는 커맨드
키가 존재하지만 만료 시간이 설정돼 있지 않은 경우에는 -1, 키가 없을 때에는 -2를 반환
```