
## 레디스와 캐시

### 캐시란?
캐시란 데이터의 원본보다 더 빠르고 효율적으로 액세스 할 수 있는 임시 데이터 저장소

**캐시로 성능을 개선하기 위한 조건**
1. 원본 데이터 저장소에서 검색하는 시간이 오래 걸리거나 매번 계산을 통해 데이터를 가져와야 한다.
2. 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소보다 빨라야 한다.
3. 캐시에 저장된 데이터는 잘 변하지 않는 데이터다.
4. 캐시에 저장된 데이터는 자주 검색되는 데이터다.

위의 조건을 만족하는 상황이라면 캐시로 많은 문제점을 해결 가능하다.

**캐시의 장점**
1. 애플리케이션의 응답 속도 개선
2. 애플리케이션의 확장 가능
	캐시를 통해 원본 데이터 저장소의 커넥션을 줄일 수 있다.
	그만큼 애플리케이션 서버에서 커넥션에 대한 부하가 줄어들게 되고 애플리케이션 확장을 하는데 이점이 있다.

### 캐시로서의 레디스

**레디스의 장점**
1. 사용이 편리함
	레디스는 단순하게 키-값 형태로 저장하고 반환하는 것이 매우 간단하다.
	또한 자체적으로 다양한 자료 구조를 제공해서 애플리케이션에서 사용하던 자료 구조를 변환 없이 바로 저장이 가능하다.
2. 속도가 빠름
	레디스는 메모리에 저장하는 인메모리 저장소여서 검색과 반환이 빠르다.
	RDB는 디스크에 접근해서 검색, 반환을 해서 응답 시간이 느리지만 레디스는 RAM에 저장하기 때문에 속도 차이가 있다.
3. 고가용성
	레디스는 자체적으로 고가용성 솔루션을 제공한다.
	센티널, 클러스터 기능을 사용하면 장애가 발생해도 안정적으로 운영할 수 잇다.
4. 스케일 아웃 편리함
	자체적으로 샤딩 솔루션을 가지고 있어 수평 확장이 간단하다.

### 캐싱 전략

**읽기 전략(Look Aside)**
가장 일반적인 읽기 전략 방법
![[KakaoTalk_Photo_2025-09-17-12-57-26 001.jpeg]]
1. 찾고자 하는 데이터가 캐시에 있는지 먼저 확인
2. 캐시에 데이터가 있으면 캐시에서 데이터 읽어오기(캐시 히트)

![[KakaoTalk_Photo_2025-09-17-12-57-27 002.jpeg]]
3. 캐시에 데이터가 없으면 원본 데이터베이스로 접근 후 데이터 가져오기(캐시 미스)
4. 가져온 데이터를 캐시에 저장

look aside는 레디스에 문제가 생겨도 장애로 이어지지 않고 원본 데이터베이스에 접근해 데이터를 가져올 수 있다.
하지만 기존에 레디스 접근이 많았다면 많은 커넥션이 원본 데이터베이스로 몰려 부하가 발생할 수 있다.

데이터가 레디스에 없을 때만 레디스에 데이터가 저장되기 때문에 이런 구조를 lazy loading이라고 부른다.
만약 레디스를 서비스에 처음 투입한 경우 그 때마다 캐시 미스가 발생해 오히려 지연이 발생될 수 있다.
이럴 때에는 미리 데이터베이스에서 캐시로 데이터를 밀어넣어주는 작업을 하는데 이를 캐시 워밍이라고 한다.

### 쓰기 전략과 캐시의 일관성
캐시는 데이터베이스에 저장돼 있는 데이터를 복사해 온 값이다.
따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다.

원본 데이터의 값은 변경되었는데 캐시에 있는 데이터는 그대로라면 잘못된 데이터를 반환해줄 가능성이 있다.
그래서 캐시의 쓰기 전략이 필요하다.

**write through**
데이터베이스에 업데이트 할 때마다 캐시에도 데이터를 함께 업데이트 시키는 방식

캐시가 항상 최신 데이터를 가지고 있다는 장점이 있지만 매번 2개의 저장소에 저장해서 쓰기 성능이 안좋다는 단점이 있다.
또한 캐시는 다시 사용될 만한 데이터가 저장되어야 하는데 모든 데이터가 캐시에 저장되기 때문에 리소스 낭비도 있다.

**cache invalidation**
데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략
저장소에서 특정 데이터를 삭제하는 것이 저장하는 것보다 리소스를 적게 사용하기 때문에 write through의 단점을 보완

**write behind(write back)**
쓰기가 빈번하게 발생하는 서비스에서 사용

데이터베이스에 대량의 쓰기 작업이 발생하면 많은 디스크 I/O를 유발해 성능 저하 발생
따라서 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 후 비동기적으로 데이터베이스에 업데이트

데이터가 실시간으로 정확하지 않아도 되는 경우 이 방법이 유용하다.


## 캐시에서의 데이터 흐름
레디스는 메모리에 모든 데이터를 저장하며 서버의 스토리지보다 훨씬 적은 양을 보관할 수 밖에 없다.
따라서 캐시는 가득 차지 않게 일정 양의 데이터를 유지해야 한다.

### 만료 시간
레디스에서 만료 시간(TTL, Time To Live)은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정이다.
일반적으로 초단위로 표현되며 지정된 시간이 지난 후에 레디스에서 자동으로 삭제된다.

EXPIRE 커맨드를 사용하면 만료 시간을 설정할 수 있다.
```
EXPIRE b 60
>> b라는 키에 60초 만료 시간 설정
```

SET 커맨드로 string을 저장할 때 EX 옵션을 같이 사용하면 데이터 저장과 만료 시간을 동시에 저장할 수 있다.
```
SET a 100 EX 60
>> a라는 키에 60초 만료 시간 설정
```

TTL 커맨드를 통해 키에 대한 만료 시간을 조회할 수 있다.
```
TTL a
(integer) 58
>> 58초 남았다는 뜻, -2는 키가 존재하지 않음, -1은 만료 시간이 지정되지 않음을 뜻한다.
```

PTTL, PEXPIRE는 밀리세컨드 단위로 지정 가능

INCR, RENAME을 이용해 키의 이름을 바꾸거나 데이터를 조작해도 만료 시간은 변경되지 않는다.
그러나 기존 키에 새로운 값을 저장해 키를 덮어 쓸 때에는 이전에 설정한 만료 시간을 사라진다.
```
INCR a
(integer) 101
>> 만료 시간은 변경되지 않음

SET a apple
"OK"

TTL a
(integer) -1
>> 데이터를 조작하면 만료 시간 사라짐
```

**passive 방식과 active 방식**
레디스에서 키가 만료됐다고 바로 삭제되는 것은 아니다.

paasive : 클라이언트가 키에 접근할 때 키가 만료됐다면 메모리에서 수동적으로 삭제
		사용자가 해당 키에 접근할 때만 삭제가 됨

active : TTL 값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤 만료된 키를 모두 메모리에서 삭제
		만약 25% 이상의 키가 삭제됐다면 다시 20개를 뽑아 동일한 과정 반복

### 메모리 관리와 maxmemory-policy 설정
만료 시간을 설정해서 관리하더라도 많은 양의 데이터를 저장하다보면 메모리 용량을 초과하는 경우가 발생한다.
이 때 레디스는 내부 정책을 사용해 어떤 키를 삭제할지 결정한다.

레디스에는 데이터의 최대 저장 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 maxmemory-policy 설정값을 이용해 메모리 관리를 한다.

**Noeviction**
기본값은 Noeviction이다.
이 값은 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정값이다.

하지만 데이터 저장을 못해 에러가 발생할 경우 장애 상황으로 이어질 수 있으므로 레디스를 캐시로 사용할 때 권장하지 않는 설정이다.
데이터 관리를 캐시에게 맡기지 않고 애플리케이션 측에서 관리하겠다는 것을 의미하며 캐시 내부적 판단으로 데이터 삭제가 위험하다고 판단될 때 사용하는 옵션이다.

**LRU eviction**
LRU(Least-Recently Used) eviction이란 레디스에 데이터가 가득 찼을 때 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책이다.
최근에 액세스 되지 않은 데이터는 나중에도 액세스 될 가능성이 낮을 것이라는 가정이며
캐시는 나중에 사용될 가능성이 있는 데이터를 유지하는 것을 목표로 하기 때문에 효율적인 메모리 관리 방법이다.

레디스는 LRU 알고리즘을 이용한 두 가지 설정값을 가지고 있다.
1. volatile-lru
	만료 시간이 설정돼 있는 키에 한해서 LRU 방식으로 키를 삭제
	만료 시간이 설정돼 있다면 언젠가 삭제될 키이기 때문에 이런 키 중 가장 오래 사용되지 않은 키를 삭제한 방식
2. allkeys-LRU
	모든 키에 대해 LRU 알고리즘을 이용해 삭제하는 방식

**LFU eviction**
LFU(Least-Frequently Used) eviction이란 레디스에 데이터가 가득 찼을 때 가장 자주 사용되지 않은 데이터부터 삭제되는 정책이다.
자주 사용되지 않은 데이터는 나중에도 액세스될 가능성이 낮을 것이라는 가정을 전제하고 있다.

LFU는 LRU와 비슷하지만 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다.
키가 오랫동안 사용되지 않았더라도 예전에 자주 액세스했던 키라면 나중에도 자주 사용될 수 있다는 가정하에 우선순위가 높아진다.

LFU도 두 가지 설정값을 갖고 있다.
1. volatile-lfu : 만료 시간이 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제
2. allkeys-lfu : 모든 키에 대해 LFU 알고리즘 적용

**RANDOM eviction**
레디스에 저장된 키 중 하나를 임의로 골라내 삭제
앞서 소개한 알고리즘을 사용하지 않기 때문에 삭제할 키를 계산하지 않아도 된다는 점에서 레디스의 부하를 줄여줄 수 있다.
하지만 나중에 사용될 수도 있는 데이터는 삭제할 가능성이 높다.

random eviction도 두 가지 설정값이 있다.
1. volatile-random
	만료 시간이 설정돼 있는 키에 한해 랜덤하게 키를 삭제
2. allkeys-random
	모든 키에 대해 랜덤하게 키를 삭제

**volatile-ttl**
만료 시간이 가장 작은 키를 삭제

### 캐시 스탬피드 현상
![[KakaoTalk_Photo_2025-09-17-14-28-13.jpeg|850]]
애플리케이션 1과 2가 look aside 방식으로 레디스를 사용하고 있을 때
레디스의 특정 키가 만료되는 시점에 두 개의 애플리케이션이 한꺼번에 데이터베이스에 가서 데이터를 읽어오는 과정을 거친다.(중복 읽기)
그리고 동일하게 데이터베이스에서 읽어온 데이터를 레디스에 쓰게 된다.(중복 쓰기)

이런 경우 중복으로 데이터베이스에 접근하고 레디스에 쓰는 동작들은 서비스 이슈로 이어질 수 있다.
이런 현상을 캐시 스탬피드라고 하며 이를 줄위기 위한 방법을 알아보자.

**적절한 만료 시간 설정**
가장 간단한 방법으로 만료 시간을 너무 짧지 않게 설정하는 것이다.
저장 시점부터 만료 시간을 충분히 길게 설정

**선 계산**
키가 만료되는 시점에 이 값을 미리 갱신해준다면 캐시 스탬피드 현상을 방지할 수 있다.

만료되기 전 랜덤한 확률로 데이터베이스에 접근해서 데이터를 읽어와 캐시의 값을 갱신

**PER(Probablistic Early Recomputation) 알고리즘**
캐시 값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산 가능
```
currenttime - (timeToCompute * beta * log(rand())) > expiry

currenttime : 현재 남은 만료 시간
timeToCompute : 캐시된 값을 다시 계산하는데 걸리는 시간
beta : 1.0보다 큰 값으로 설정 가능
rand() : 0과 1 사이의 랜덤 값을 반환하는 함수
expiry : 키를 재설정할 때 새로 넣어줄 만료 시간

timeToCompute * beta * log(rand())는 무작위성을 가진 값이며 이 값은 항목의 만료 여부에 영향을 미친다.
currenttime에서 timeToCompute * beta * log(rand())를 뺀 값이 expiry보다 크면 false이고 작으면 true이다.

만료 시간이 가까워질 수록 currenttime과 expiry의 차이는 작아지며 조건이 참이 될 확률이 높아진다.
이것은 만료 시간이 점점 다가올 때 미리 갱신할지 결정하는 확률이 높아진다는 뜻이다.
```
이 알고리즘은 만료 시간이 가까워질수록 true를 반환할 확률이 높기때문에 이는 불필요한 재계산을 효과적으로 방지하는 방법이다.
따라서 데이터를 가져오는 과정에서 GET 대신 이 함수를 사용하면 캐시 스탬피드 현상을 줄이고 성능을 최적화하는 데 도움이 된다.


## 세션 스토어로서의 레디스

### 세션이란?
서비스를 이용하는 클라이언트의 상태 정보를 의미
현재 서비스에 로그인돼 있는 클라이언트가 누구인지, 어떤 활동을 하고 있는지에 대한 유저 정보

ex) 활용 사례
쇼핑몰 사이트에 유저가 장바구니에 담은 물건, 최근 봤던 상품등에 대한 정보를 세션에 저장
유저의 행동을 분석해 비즈니스 개선에 활용 가능

### 세션 스토어가 필요한 이유
서비스의 웹 서버가 1대만 있을 때는 굳이 세션 스토어가 필요 없다.
웹 서버에 세션 스토어를 두고 자체적으로 관리하면 되기 때문이다.
하지만 웹 서버가 여러 대인 경우에는 세션스토어가 필요하다.

각 웹 서버별로 세션 스토어를 관리한다면 유저 데이터에 정합성 문제가 발생한다.
사용자가 장바구니에 분명히 아이템을 저장했는데 서버에 재접속 할 때마다 아이템이 사라졌다 생겼다 한다면 정상적인 서비스 이용이 불가능하다.

이런 경우를 방지하기 위해 여러 방법이 존재한다.
**all-to-all**
모든 웹 서버에 세션 정보를 복제해서 저장하는 방법

하지만 유저의 세션 데이터가 불필요하게 여러 서버로 복사되기 때문에 공간 효율성에 문제가 있으며
데이터를 복제한 ㄴ과정에서 불필요한 네트워크 트래픽도 다수 발생한다.

**데이터베이스 세션스토어**
데이터베이스를 세션스토어로 활용하는 방법

하지만 세션 데이터는 유저가 활동하는 동안 자주 액세스되는 특성이 있다.
데이터베이스를 세션 스토어로 사용하게 된다면 DB에 부하가 발생하고 서비스 품질에 영향을 줄 수 있다는 단점이 있다.

**레디스 세션 스토어**
레디스를 세션 스토어로 활용하는 방법

레디스는 어떤 웹 서버에 연결되더라도 동일한 세션 데이터를 조회할 수 있어 트래픽을 효율적으로 분산시킬 수 있으며
RDB보다 훨씬 빠르고 접근하기 편해서 데이터를 가볍게 저장할 수 있다.

### 캐시와 세션의 차이
캐시는 데이터베이스의 완벽한 서브셋으로 동작한다.
즉 캐시가 갖고 있는 데이터는 모두 데이터베이스에 저장돼 있으며 캐시 내부의 데이터가 유실되더라도 데이터베이스에서 찾을 수 있다.
또한 캐시에 저장된 데이터는 여러 애플리케이션에서 함께 사용할 수 있다.

하지만 세션 스토어에 저장된 데이터는 여러 사용자 간 공유되지 않으며 특정 사용자 ID에 한해 유효하다.

일반적인 세션 스토어에서는 유저가 로그인하면 세션 데이터는 세션 스토어에 저장된다.
세션이 활성화돼 있는 동안에는 애플리케이션은 데이터베이스가 아닌 세션 스토어에만 저장한다.
유저가 로그아웃할 때 세션은 종료되며 이때 데이터의 종류에 따라 데이터베이스에 영구 저장할 것인지 삭제할 것인지가 결정된다.
최근에 봤던 상품 리스트는 휘발시켜도 되지만 장바구니에 담아 놨던 상품들은 데이터베이스에 저장시켜 다음 로그인시에도 확인할 수 있도록 해야 한다.

이처럼 세션 스토어는 캐시와 달리 데이터베이스와 완벽한 데이터 호환을 이루지 않아도 된다.