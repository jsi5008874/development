가용성은 서비스의 안정성을 측정하는 데 사용되는 지표다.
```
Availability = Available for Use Time / Total Time
```
수식처럼 가용성이란 일정 기간 동안 서비스를 정상적으로 사용할 수 있는 시간의 비율을 뜻하며 이 값이 클수록 가용성이 높다고 한다.
가용성이 높은 시스템을 고가용성 시스템이라고 부른다.

레디스에서 고가용성을 확보하기 위해서 두 가지 기능이 필요하다

1. 복제 : 마스터 노드의 데이터를 복제본 노드로 실시간 복사하는 기능
	마스터 노드의 서버에 장애가 생겨도 복제본 노드에서 데이터 확인 가능
2. 자동 페일오버 : 마스터 노드에서 발생한 장애를 감지해 레디스로 들어오는 연결을 자동으로 복제본 노드로 리디렉션하는 기능

두 가지 기능 중 하나라도 작동하지 않는다면 고가용성을 확보할 수 없다.

## 레디스에서의 복제 구조
레디스는 멀티 마스터 구조를 지원하지 않으며 마스터는 복제본이 될 수 없다.
레디스 버전 2.6 이상부터 복제본 노드는 기본으로 읽기전용으로 동작한다.
모든 데이터의 입력은 마스터 노드에서 이뤄지는 게 일반적이며 복제본은 마스터에서 변경된 데이터를 그대로 받아온다.

### 복제 구조 구성하기
```
REPLICAOF <master-ip> <master-port>
```
![[KakaoTalk_Photo_2025-09-30-13-28-11.jpeg|650]]
복제본이 될 노드 B에서 REPLICAOF 커맨드를 입력해 마스터 노드의 정보를 입력하면 복제 연결이 시작
애플리케이션은 마스터 노드인 A를 바라봐야하고 문제가 생길 시 연결 설정을 B로 변경하면 서비스를 계속할 수 있다.

![[KakaoTalk_Photo_2025-09-30-13-33-24 001.jpeg|675]]
레디스에서 마스터는 여러 개의 복제본이 연결될 수 있으며(왼쪽)
복제본 노드에 새로운 복제본을 추가하는 것도 가능하다.(오른쪽)

하지만 한 개의 복제 그룹에서는 항상 한 개의 마스터 노드만 존재한다.
가장 상위의 노드인 마스터 노드만 데이터를 업데이트할 수 있으며 하위 복제본은 모두 읽기 전용으로 동작한다.

### 패스워드 설정
레디스 6.0 이상부터 도입된 ACL 기능이 아닌 기본적인 패스워드를 사용해 데이터를 복제할 때에는 masterauth 옵션에 패스워드를 입력해야한다.
![[KakaoTalk_Photo_2025-09-30-13-33-24 002.jpeg|675]]
requirepass 옵션을 이용해 패스워드를 설정할 수 있으며 복제본 노드는 masterpass 옵션에 마스터의 requirepass 값을 입력해야 한다.

복제본 노드에 requirepass를 다른 값으로 설정해 각 레디스 노드마다 다른 패스워드를 사용할 수도 있지만
하나의 복제 그룹에 속한 마스터와 복제본 노드는 같은 패스워드로 설정하는 것이 일반적이다.

## 복제 메커니즘
![[KakaoTalk_Photo_2025-09-30-13-54-32.jpeg|675]]
버전 7 이전에서는 repl-diskless-sync 옵션의 기본값이 no이며 그림과 같다.

1. REPLICAOF 커맨드로 복제 연결 시도
2. 마스터 노드에서는 fork로 자식 프로세스를 새로 만든뒤 RDB 스냅샷을 생성
3. 2번 과정 동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜(RESP) 형태로 마스터의 복제 버퍼에 저장
4. RDB 파일이 생성 완료되면 파일은 복제본 노드로 복사
5. 복제본에 저장됐던 모든 내용을 모두 삭제한 뒤 RDB 파일을 이용해 데이터를 로딩
6. 복제 과정 동안 버퍼링됐던 복제 버퍼의 데이터를 복제본으로 전달해 수행

이와 같은 복제 과정에서 복제 속도는 디스크 I/O 처리량에 영향을 받는다.
마스터에서 RDB 파일을 저장하는 시간, 복제본에서 RDB 파일을 읽어오는 과정 모두 디스크 I/O 속도에 영향을 받기 때문이다.

버전 7 이후부터 repl-diskless-sync의 기본값은 yes다.
![[KakaoTalk_Photo_2025-09-30-13-59-43.jpeg|650]]
1. REPLICAOF 커맨드로 복제 연결 시도
2. 마스터 노드는 소켓 통신을 이용해 복제본 노드에 바로 연결하며 RDB 파일은 생성됨과 동시에 점진적으로 복제본의 소켓에 전송
3. 2의 과정 동안 마스터 노드에서 수행된 데이터셋 변경은 복제 버퍼에 저장
4. 소켓에서 읽어온 RDB 파일을 복제본의 디스크에 저장
5. 복제본에 저장된 모든 데이터를 삭제한 뒤 RDB 파일 내용을 메모리에 로딩
6. 복제 버퍼의 데이터를 복제본으로 전달

복제본의 repl-diskless-load 옵션은 기본으로 disable이기 때문에 소켓에서 읽어온 RDB 데이터를 메모리에 바로 로드하지 않고
복제본 노드의 디스크에 저장하는 과정을 거친다.

복제본 노드는 마스터에서 가져온 데이터를 불러오기 전에 자신의 데이터를 모두 삭제하는 과정을 먼저 거치는데 이때 소켓 통신으로 받아온 RDB 데이터가 정상적인지를 미리 확인할 수 없기 때문에 모두 삭제하기 전 자신의 디스크에 데이터를 저장하는 과정을 선행해서 데이터의 안정성을 높인다.

디스크 I/O가 느리고 네트워크가 빠른 경우 디스크를 사용하지 않는 복제 방식이 더 빠르게 복제연결을 완료할 수 있다.

디스크를 사용하는 복제 방법에서 RDB가 생성되는 도중 다른 노드에서 복제 연결 요청이 들어오면
이 연결은 큐에 저장되며 기존 RDB 파일의 저장이 완료되면 여러 복제본이 한 번에 복제 연결을 시작할 수 있었다.

하지만 디스크를 사용하지 않는 방식에서 이미 복제 연결이 시작된 경우에는 복제 과정이 끝나기 전까지 다른 복제본과 연결은 수행될 수 없고
다른 복제본들은 하나의 복제 연결이 끝날때 까지 큐에서 대기해야한다.
이를 방지하기 위해 repl-diskless-sync-delay 옵션을 사용할 수 있다.
```
repl-diskless-sync-delay 5
```
이 값의 기본값은 5초로 새로운 복제 연결이 들어오면 기본 5초를 기다린 뒤 복제 연결을 시작한다는 의미다.
이 기간 내에 또 다른 복제 연결이 들어오면 마스터는 여러 복제본으로 소켓 통신을 연결해 한 번에 여러 개의 복제본에 RDB 파일을 전송할 수 있다.
보통 네트워크가 유실돼 재동기화를 요청할 경우 마스터에는 한 번에 여러 개의 복제본에서 복제 연결이 들어오는것이 일반적이기 때문에 활성화하는 것이 좋다.

### 비동기 방식으로 동작하는 복제 연결
복제 연결이 된 상태에서 데이터 전달은 비동기 방식으로 동작한다.
![[KakaoTalk_Photo_2025-09-30-16-48-55.jpeg|650]]
그림처럼 마스터에서 데이터를 입력하는 커맨드가 수행되면 레디스는 마스터 노드에서 커맨드를 처리한 후 클라이언트에게 OK 응답을 보낸다.
이후에 복제본에게 변경된 데이터를 전달한다.

레디스에서 클라이언트는 데이터를 입력할 때마다 복제본에 데이터가 정확히 전달됐는지 확인하는 과정이 없기 때문에 높은 성능을 발휘할 수 있다.
또한 2번 과정 이후로 레디스 마스터 노드가 비정상 종료된 경우 복제본으로 데이터 전달이 되지 않을 수 있는데
실제로는 복제본에 전달되는 속도가 굉장히 빨라서 이런 데이터 유실은 빈번하게 발생되지 않는다.

### 복제 ID
모든 레디스 인스턴스는 복제 ID(replication ID)를 가지고 있다.
복제 기능을 사용하지 않는 인스턴스도 모두 랜덤 스트링 값의 복제 ID를 가지며 오프셋과 쌍으로 존재한다.
레디스 내부의 데이터가 수정되는 모든 커맨드를 수행할 때마다 오프셋이 증가한다.

INFO REPLICATION 커맨드를 사용하면 복제 연결상태를 확인할 수 있다.
![[KakaoTalk_Photo_2025-09-30-16-57-11 001.jpeg|625]]
인스턴스의 역할은 마스터이며 연결된 복제본은 없다는 것을 알 수 있다.
또한 master_replid를 통해 복제 ID를 알 수 있고 오프셋이 709라는 정보도 확인할 수 있다.

![[KakaoTalk_Photo_2025-09-30-16-57-11 002.jpeg|625]]
마스터 노드에 복제본을 연결한뒤 커맨드로 다시 확인해보면
connected_slave가 1로 변경됐으며 slave0에 새로 연결된 노드의 정보가 추가된 것을 볼 수 있다.

![[KakaoTalk_Photo_2025-09-30-16-57-12 003.jpeg|625]]
복제된 노드의 정보를 보면 role은 slave이며 마스터의 정보도 추가됐다.
복제연결을 하면 master_replid가 복제본의 replid가 아닌 마스터 노드의 replid로 변경되며 오프셋은 복제본에서 마지막으로 수행된 마스터의 오프셋을 의미한다.

![[KakaoTalk_Photo_2025-09-30-16-57-12 004.jpeg|625]]
복제본 노드는 마스터의 replid와 동일하며 현재 마스터 노드의 오프셋은 807, 복제본 노드의 오프셋은 801인 것으로 보아
현재 복제본은 마스터와 정확하게 일치하지 않으며 802~807까지의 커맨드를 수행했을 때 정확히 일치될 것이다.

즉 레디스에서 replicaion id와 오프셋이 같을 때 두 노드는 정확히 일치된 상태라는 것을 의미한다.

### 부분 재동기화
복제 연결이 끊길 때마다 마스터에서 RDB 파일을 새로 내려 복제본에 전달하는 과정을 거친다면 네트워크가 불안정한 상황에서 레디스의 성능은 나빠질 것이다.
이를 방지하기 위해 레디스는 부분 재동기화(partial resynchronization)기능을 사용해 안정적인 복제 연결을 유지한다.

마스터는 커넥션 유실을 대비해 백로그 버퍼라는 메모리 공간에 복제본에 전달한 커맨드 데이터들을 저장해둔다.
하나의 복제 그룹에서 replication id와 오프셋을 이용하면 복제본이 마스터의 어느 시점까지 데이터를 가지고 있는지 파악할 수 있다.
만약 복제 연결이 잠시 끊긴 뒤 재연결되면 복제본은 PSYNC 커맨드를 호출해 자신의 replication ID와 오프셋을 마스터에 전달한다.
![[KakaoTalk_Photo_2025-09-30-17-17-38.jpeg|725]]
만약 복제본의 오프셋이 900, 마스터의 오프셋이 915인 상황이라면
복제본이 마스터에 재연결을 시도했을 때 마스터는 RDB 파일을 새로 저장할 필요 없이 백로그에 저장된 901~915의 데이터를 복제본에게 전달해 재동기화할 수 있다.

하지만 마스터의 백로그 버퍼에 원하는 데이터가 남아 있지 않거나 복제본이 보낸 replication ID가 일치하지 않으면 전체 재동기화를 시도한다.

복제 백로그 크기는 repl-backlog-size로 지정할 수 있으며 기본값은 1MB이다.
백로그는 1개 이상의 복제본이 연결된 경우에만 할당되며 repl-backlog-ttl 만큼의 시간이 경과하면 메모리에서 백로그 공간을 삭제한다.

복제본은 언제든지 마스터로 승격될 수 있어서 복제본에 직접 연결된 복제 연결이 없더라도 백로그 버퍼를 해제하지 않는다.
### Secondary 복제 ID
![[KakaoTalk_Photo_2025-09-30-17-23-10 001.jpeg|600]]
한 개의 복제본 그룹 내의 모든 레디스 노드는 동일한 복제 ID를 갖는다.
그림에서 복제본 노드 B, C는 마스터 A의 복제 ID와 동일한 복제 ID를 갖고 있다.

![[KakaoTalk_Photo_2025-09-30-17-23-10 002.jpeg|600]]
마스터 A에 장애가 발생해 복제가 끊어지고 복제본 B가 마스터로 승격되는 상황

마스터 노드와 복제가 끊어짐과 동시에 복제본은 새로운 복제 ID를 갖게 된다.
그 이유는 복제가 끊어진 뒤에도 노드 B가 기존 복제 ID인 aaaaa를 유지하며 마스터로 동작하다가 A가 다시 복구되서 돌아왔을 때 문제가 발생한다.
이런 상황에서 두 노드는 동일한 복제 ID, 동일한 오프셋이 동일한 데이터셋을 갖는다는 사실을 위반할 수 있기 때문이다.

노드 B가 마스터로 승격되면서 새로운 복제 ID인 bbbbb를 갖게 됐으며 기존 복제 ID는 master_replid2로 변경되었다.
이때 C는 B로 연결되며 B와 같은 replid를 갖게된다.

또한 노드 C가 B에 연결될 때 재 동기화를 시도하고 노드 B의 백로그가 재동기화를 하기위한 데이터를 갖고 있는 경우라면 부분 재동기화 할 수 있다.

레디스가 2개의 복제 ID를 갖는 이유는 마스터로 승격되는 복제본 때문이며 같은 복제 그룹 내에서 페일오버 이후 승격된 새로운 마스터에
연결된 복제본은 전체 재동기화를 수행할 필요가 없을 수 있다.

### 읽기 전용 모드로 동작하는 복제본 노드
버전 2.6 이후 레디스에서 복제를 구성하면 복제본은 기본으로 읽기 전용 모드로 동작
클라이언트는 복제본 노드에 연결되더라도 읽는 커맨드만 수행이 가능하다.
이 설정은 replica-read-only 옵션을 이용해 제어된다.

복제본 노드에서도 데이터 변경이 가능해진 경우 복제본이 재시작되거나 커넥션이 유실돼 마스터와 전체 재동기화를 수행하게되면
복제본에서 수행한 데이터는 사라지기 때문에 유의해야 한다.

복제본에 직접 데이터를 쓸 수 있다 하더라도 복제본에 쓰는 내용은 오직 로컬에서만 유지되며 다른 복제본으로 전파되지 않는다.
서브 복제본은 항상 최상위 마스터가 중간 복제본으로 보낸것과 동일한 복제 프로토콜을 전달 받는다.

![[KakaoTalk_Photo_2025-09-30-17-41-07.jpeg|600]]
그림처럼 중간 복제본인 B에 replica_read_only 옵션이 비활성화 된 경우
B의 데이터를 변경해도 B에서만 변경되고 C에는 아무런 영향이 없다.
C는 오직 마스터인 A노드에서 변경한 데이터만 B를 통해 받는다.

### 유효하지 않은 복제본 데이터
유효하지 않은(stable) 데이터란 복제본의 데이터와 마스터의 데이터가 정확하게 일치하지 않는 경우의 데이터를 의미한다.
레디스에서 복제본이 마스터와 연결이 끊어진 상태 또는 복제 연결이 시작된 뒤 아직 완료되지 않은 경우 데이터가 유효하지 않다고 판단할 수 있다.

복제본의 데이터가 유효하지 않다고 판단될 때 복제본의 동작 방식은 replica-serve-stable-data 파라미터를 이용해 제어할 수 있다.
기본값은 yes로 복제본의  데이터가 유효하지 않다고 판단될 때에도 클라이언트로부터 들어오는 모든 읽기 요청에 데이터를 반환한다.
이 값을 no로 설정할 경우 INFO, CONFIG, PING 등의 일부 기본 커맨드를 제외한 모든 커맨드는 오류를 반환한다.

### 백업을 사용하지 않는 경우에서의 데이터 복제
레디스에서 복제를 사용하는 경우 마스터와 복제본에서 백업 기능을 사용하는 것이 좋다.
만약 이 기능을 사용하지 않으려면 레디스가 자동으로 재시작되지 않도록 설정해야한다.
![[KakaoTalk_Photo_2025-10-02-12-16-29.jpeg|625]]
1. 백업 기능을 사용하지 않는 마스터와 복제본 노드가 존재
2. 마스터 노드가 장애로 인해 종료됐지만 레디스 프로세스를 자동 재시작하는 시스템에 의해 노드가 재부팅되며 메모리는 초기화 된다.
3. 복제본 노드에는 데이터가 존재하지만 마스터 노드로의 복제 연결을 시도한다.
4. 마스터에서 복제본으로 빈 데이터 셋을 전달한다.

만약 백업을 사용했다면 2번 상황에서 레디스가 재부팅될 때 백업 파일을 자동으로 읽어와서 데이터가 복원된다.

자동 재시작 기능을 사용하지 않았다면 복제본 노드에는 데이터가 존재하기 때문에 애플리케이션 연결 설정을
마스터에서 복제본 노드로 변경해 데이터를 계속 사용할 수 있다.
또는 복제본 노드에서 데이터를 새로 백업받아 마스터 노드에 전달한 뒤 마스터 노드를 시작시키면서
복제본 노드에 저장된 내용으로 데이터가 복원될 수 있다.

데이터 안정성을 위해 복제 기능을 사용할 경우 백업 기능을 사용하는 것이 좋으며
그렇지 않을 경우 마스터에서는 인스턴스 자동 재시작을 활성화하지 않는것을 권장한다.