
## String
String은 레디스에서 가장 간단한 자료 구조

### 특징
1. 이진 데이터를 포함하는 모든 종류의 문자열이 binary-safe하게 처리됨
```
binary-safe 란?
모든 바이너리 데이터를 안전하게 처리할 수 있다는 의미

ex)
C 언어 문자열(binary-safe X)
char str[] = "Hello\0World";  // \0에서 문자열이 끝난다고 인식(\0은 아스키 코드상 null 바이트라는 특수 문자)
printf("%s", str);  // 출력: "Hello" (World는 출력 안됨)

>> C 언어는 binary-safe가 아니라서 데이터 소실 가능성이 있음

Java의 문자열(binary-safe O)
String str = "Hello\0World"; 
System.out.println(str.length()); // 11 (null 바이트 포함 전체 길이) 
System.out.println(str); // "Hello\0World" (전체 출력)

>> Java는 binary-safe로 데이터 손실 가능성 없음(레디스도 마찬가지)
```

2. 키와 실제 저장되는 아이템이 일대일로 연결되는 유일한 자료 구조
	String이 아닌 다른 자료 구조는 하나의 키에 여러 아이템이 저장됨

### 활용 방법

**데이터 입력, 조회**
```
SET key value
>> key, value 형식으로 데이터를 저장하는 명령어

Get key
>> key에 할당된 value를 조회

ex)
SET hello(key) world(value)
>> hello라는 key와 world라는 value를 매핑해서 데이터 저장

GET hello(key)
"world"(value)
>> hello라는 key로 조회하면 world라는 value 조회됨


만약 hello에 다른 값이 연결돼 있었다면 기존 값은 새로 입력된 값으로 대체, 저장된 형태가 string이 아닌 다른 자료 구조도 동일하게 동작
ex)
기존 데이터 : hello(key) hi(value)

여기에 SET hello world로 입력하면

바뀐 데이터 : hello(key) world(value)
이렇게 변경됨
```

**옵션 입력**
```
NX : 지정한 키가 없을 때만 새로운 키를 저장

ex)
이미 hello라는 키가 존재할 경우

SET hello new NX(옵션)
(nil)
>> 이미 hello가 존재하는 키여서 저장되지 않음


XX : 키가 이미 있을 때에만 새로운 값으로 덮어 쓰며 새로운 키를 생성하지 않도록 동작

ex)
이미 hello라는 키가 존재할 경우

SET hello new XX(옵션)
OK
>> 저장됨


MSET, MGET : 한번에 여러 개의 키를 조작 가능
ex)
MSET a 10 b 20 c 30
>> 3개의 키가 동시에 저장

MGET a b c
"10"
"20"
"30"
>> 3개의 값이 동시에 조회
```

**원자적 명령어**
같은 키에 여러 클라이언트가 접근해도 경쟁 상태(race condition)를 발생시킬 일이 없다는 의미

예시(INCR, INCRBY)
```
SET counter 100
OK

INCR counter (INCR : 숫자 1 증가)
(integer) 101

INCRBY counter 50 (INCRBY : 입력한 숫자만큼 증가)
(integer) 150

DECR, DECRBY : 감소 명령어
```

INCR, DECR 같은 명령어는 원자적 명령어인데 이는 여러 클라이언트가 동시에 접근해도 1번만 수행된다.
```
A, B 두명의 클라이언트가 동시에 counter(100)에 접근 했을 때

A : INCR counter
B : INCR counter
동시 입력

GET counter
(integer) 101
>> INCR을 두 번 입력해도 1번만 실행, 순서에 맞게 두 번째 명령어도 실행되긴 함
```

## List
순서를 가지는 문자열 목록

### 특징
일반적인 배열처럼 인덱스를 이용해 접근이 가능하지만 레디스에서는 주로 스택이나 큐로 사용됨

### 활용 방법

**PUSH, RANGE 명령어**
```
LPUSH : 왼쪽(head)에 데이터 추가
ex)
LPUSH mylist E
(integer) 1    >> list의 크기

RPUSH : 오른쪽(tail)에 데이터 추가
ex)
RPUSH mylist B
(integer) 2

LRANGE : list에 있는 데이터 조회
ex)
LRANGE mylist 0 -1
1) "E"
2) "B"
   
LRANGE는 시작과 끝 아이템의 인덱스를 인수로 받아 출력
-1은 가장 오른쪽(tail)에 있는 아이템의 인덱스를 뜻함
-2는 그 앞의 인덱스

위의 예시는 0부터 마지막까지의 아이템을 출력하라는 의미
```

**POP, TRIM 명령어**
```
LPOP : list의 첫 번째 아이템을 반환하면서 list에서 삭제, 숫자와 함께 사용하면 지정한 숫자만큼 반복해서 반환
ex)
한개만 뺏을 때
LPOP mylist
"E"

인수를 통해 여러 개 뺏을 때
LPOP mylist 2
"E"
"B"
>> 이렇게 빼고나면 mylist에서 E, B는 삭제된다.


LTRIM : 지정한 범위에 속하지 않는 아이템 모두 삭제, 삭제된 아이템을 반환하진 않음
ex)
LTRIM mylist 0 1
OK   >> POP과 다르게 반환하지 않음
```

LPUSH와 LTRIM을 함께 사용하면 고정된 길이의 큐를 쉽게 유지 가능
```
1000개의 로그 데이터를 보관한다고 가정

LPUSH logdata <data>
LTRIM logdata 0 999

logdata 리스트에 데이터가 쌓일때 마다 LTRIM을 같이 실행하면 크기가 1000인 리스트를 계속 유지할 수 있다.
```

**LINSERT, LSET, LINDEX**
```
LINSERT : 원하는 데이터의 앞이나 뒤에 데이터 추가
ex)
mylist = [A, B, C]

LINSERT mylist BEFORE B E >> "B"라는 데이터 앞에 "E"를 추가
(integer) 4

LRANGE mylist 0 -1
1) "A"
2) "E"
3) "B"
4) "C"
>> B앞에 E가 추가 됨

BEFORE 대신 AFTER를 사용하면 뒤에 추가됨


LSET : 지정한 인덱스의 데이터를 입력한 데이터로 변경
ex)
mylist = [A, B, C]
LSET mylist 2 F
ok

LRANGE mylist 0 -1
1) "A"
2) "B"
3) "F"
>> 인덱스 2번의 값이 C에서 F로 변경


LINDEX : 원하는 인덱스의 데이터를 확인
ex)
mylist = [A, B, C]
LINDEX mylist 2
"C" 
```


## Hash
필드-값 쌍을 가진 아이템의 집합
```
키와 필드의 차이점 : 계층 구조

Redis 전체
├── 키1 (user:1001)
│   └── HASH 값
│       ├── 필드1 (name) → 값 (홍길동)
│       ├── 필드2 (age) → 값 (30)
│       └── 필드3 (email) → 값 (hong@email.com)
├── 키2 (user:1002)
│   └── HASH 값
│       ├── 필드1 (name) → 값 (김철수)
│       └── 필드2 (age) → 값 (25)
└── 키3 (product:100)
    └── STRING 값 (iPhone)

키에 매핑된 필드들이 있고 각 필드마다 값이 매핑되어 있는 구조이다.
즉 String, list와 달리 더 깊은 계층구조를 가지고 있다.
```

### 특징
1. 필드는 하나의 hash 내에서 유일하며 필드와 값 모두 문자열 데이터로 저장
	위 예시에서 user:1001을 하나의 hash로 이해하면 된다. user:1001에 두 개의 name 필드가 존재할 수 없다는 뜻
 
2. hash는 객체를 표현하기에 적절한 자료 구조
	계층형으로 존재해 객체를 표현하기 좋고 RDB 테이블로 변환하기 좋다.

3. 유연한 구조
	칼럼이 고정된 RDB 테이블과 달리 필드를 추가하는 것이 매우 간단하고 동적으로 필드를 추가할 수 있다.

### 활용 방법
**HSET, HGET**
```
HSET : hash에 아이템을 저장, 한 번에 여러 필드-값 저장 가능
ex)
HSET Product:123(키) Name(필드) "Happy"(값)
(integer) 1  >> hash의 크기

HSET Produc:234 Name "Track" TypeID 32
(integer 2)
>> 여러 필드 저장 예시, name과 typeId 필드 동시 저장


HGET : 저장된 데이터 조회
ex)
HGET Product:123(키) Name(필드)
"HAPPY"

HMGET : hash 내 여러 필드의 값 조회
ex)
HMGET Product:234 Name TypeID
1) "Track"
2) "32"

HGETALL : hash 내 모든 필드 조회
ex) HGETALL Product:123
1) "NAME"
2) "HAPPY"
```


## SET
정렬되지 않은 문자열의 모음

### 특징
1. set에는 중복된 데이터는 저장되지 않는다.
2. 교집합, 차집합, 합집합 등 집합 연산과 관련된 커맨드 제공
	객체 간의 관계를 계산하거나 유일한 원소를 구할 경우 사용

### 활용 방법
**SADD, SMEMBERS, SREM**
```
SADD : set에 아이템 저장
ex)
SADD myset(set이름) A(값)
(integer) 1

SADD myset A A B C C C D D
(integer) 4   >> 중복된 값은 모두 제거하고 한 개만 삽입된다. 따라서 A, B, C, D 한 개씩 삽입되어 크기는 4


SMEMBERS : set에 저장된 전체를 출력, 순서와 상관없이 랜덤으로 출력
ex)
SMEMBERS myset
1) "B"
2) "A"
3) "C"
4) "D"
   
SREM : set에서 원하는 데이터 삭제, 여러 개 동시에 삭제 가능
ex)
SREM myset B
(integer) 1 >> 삭제된 건 수

SPOP : set 내부의 아이템 중 랜덤으로 반환 후 set에서 삭제
ex)
SPOP myset
"B"
>> "B" 반환 후에 set에서 삭제 됨
```

**SUNION, SINTER, SDIFF**
![[KakaoTalk_Photo_2025-09-08-23-00-14.jpeg]]
```
SUNION : 합집합
ex)
SUNION set:111 set:222
A~H 조회됨

SINTER : 교집합
ex)
SINTER set:111 set:222
1) "D"
2) "E"

SDIFF : 차집합
ex)
SDIFF set:111 set:222
1) "A"
2) "C"
3) "B"
>> 앞에 선언한 set 기준으로 조회된다. 여기서는 set:111의 값이 조회됨
```

## Sorted Set
스코어 값에 따라 정렬되는 고유한 문자열의 집합

![[KakaoTalk_Photo_2025-09-13-12-06-29.jpeg]]
**value의 구성**
member : 그림 상 user:A, user:B 처럼 스코어를 식별하고 조회할 때 사용되는 속성
score : 그림 상 100, 150 처럼 데이터를 나타내는 속성

### 특징
1. 그림과 같이 스코어-값 쌍을 가지며 저장될 때부터 스코어 값으로 정렬돼 저장
	같은 스코어를 가진 아이템은 데이터의 사전 순으로 정렬돼 저장
	멤버가 다르다면 스코어가 같아도 상관 없음
2. 모든 아이템은 스코어 순으로 정렬돼 있어 list처럼 인덱스를 이용해 접근 가능
	인덱스 사용 시 list보다 sorted set이 더 효율적이다.
	list 시간복잡도 : O(n)
	sorted set 시간복잡도 : O(log(n))
```
list의 조회 시간복잡도가 O(n)인 이유?
레디스의 list는 linked list로 구현되어 있어 인덱스를 통한 접근의 시간복잡도가 O(n)
일반적인 list라면 O(1)이 맞음

sorted set의 조회 시간복잡도가 O(log(n))인 이유?
레디스 sorted set이 내부적으로 skip list 자료구조를 사용하기 때문
```
[[Skip List]](스킵 리스트 정리)

### 활용 방법
**ZADD**
```
ZADD : sorted set에 아이템 저장 명령어
ex)
ZADD score:220871(키) 100(값) user:B(멤버)

만약 중복된 값이라면 기존에 저장된 값을 업데이트 해준다.

ZADD의 옵션

XX: 아이템이 이미 존재할 때만 업데이트
NX : 아이템이 존재하지 않을 때만 신규 삽입
LT : 업데이트하고자 하는 스코어가 기존 아이템보다 작을 때에만 업데이트, 신규 삽입 가능
GT : 업데이트하고자 하는 스코어가 기존 아이템보다 클 때만 업데이트, 신규 삽입 가능
```


 **ZRANGE**
 ```
ZRANGE : sorted set에 저장된 데이터 조회, start/stop 범위를 항상 입력해야함
ex)
ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]


인덱스로 조회 : start와 stop 인자에는 검색하고자 하는 첫 번째와 마지막 인덱스를 전달
ex)
ZRANGE score:220817 1 3 WITHSCORES(멤버, 스코어 같이 출력) REV(역순으로 출력)
>> 인덱스 1 ~ 3을 역순으로 출력하는 명령어


스코어로 데이터 조회 : BYSCORE 옵션을 이용해 스코어를 통한 데이터 조회 가능
                  start, stop 인자는 조회하고자 하는 최소, 최대 스코어 값
ex)
ZRANGE score:220817 100 150 BYSCORE WITHSCORES
>> 스코어가 100이상 150이하인 값을 조회하라는 명령어

인수로 전달하는 스코어에 (를 추가하면 해당 스코어를 포함하지 않는 값만 조회
ZRANGE score:220817 (100 150 BYSCORE WITHSCORES
>> 100을 포함하지 않고 100 초과 150 이하의 스코어를 조회

스코어의 최솟값과 최댓값을 표현하기 위해 infinity를 의미하는 -inf, +inf 사용
ZRANGE score:220817 200 +inf BYSCORE WITHSCORES
>> 200보다 큰 모든 값을 출력


사전 순으로 데이터 조회 : BYLEX 옵션을 사용하면 사전식 순서를 이용해서 조회(가나다, abc, 123 순서)
					 BYLEX에서는 스코어에 반드시 ( 제외 수식 또는 [ 포함 수식을 포함해야한다.
ZRANGE mySortedSet (b (f BYLEX
>> b 초과 f 미만의 값 조회


사전식 문자열의 가장 처음은 - 문자로, 가장 마지막은 + 문자로 대체할 수 있다.
ZRANGE <key> - + BYLEX >> sorted set에 저장된 모든 데이터 조회
 ```
 
## 비트맵
독자적인 자료 구조는 아니며 string 자료 구조에 bit 연산을 수행할 수 있도록 확장한 형태

### 특징
1. 저장 공간 절약
	1비트로 하나의 상태(0 또는 1)를 표현하기 때문에 저장 공간을 대폭 절약할 수 있음
```
일반 방식 (Set 사용):
사용자 ID: 1, 5, 7, 10이 로그인함
Set<Integer> = {1, 5, 7, 10}
→ 각 Integer당 32비트 = 128비트 사용

비트맵 방식:
Position: 0 1 2 3 4 5 6 7 8 9 10
Bit:      0 1 0 0 0 1 0 1 0 0 1
→ 11비트만 사용 (약 1/10 크기)
```

### 활용 방법
**SETBIT, GETBIT, BITCOUNT**
```
SETBIT : 비트 저장
ex)
SETBIT mybitmap(키) 2(위치) 1(값)
(integer) 1 >> 저장 이전의 값
>> 2번 째 비트에 1로 설정


GETBIT : 저장된 비트를 조회
ex)
GETBIT mybitmap 2
(integer) 1 >> 조회된 값
>> 2번 째 비트의 값을 조회


BITFIELD : 한 번에 여러 비트를 저장
ex)
BITFIELD mybitmap SET u1 6 1 SET u1 10 1 SET u1 14 1
(integer) 1
(integer) 1
(integer) 1 
>> 각각 6, 10, 14번째 비트에 1을 저장

u1은 u(unsigned, 부호 없는) + 1(비트 수) >> 부호 없는 1비트를 저장
만약 u4라면 부호있는 4비트(0~15)를 저장하는 것


BITCOUNT : 1로 설정된 비트의 개수를 카운팅
ex)
BITCOUNT mybitmap
(integer) 4 >> 1로 설정된게 4개
```


## Hyperloglog
집합의 원소 개수인 카디널리티를 추정할 수 있는 자료 구조
대량 데이터에서 중복되지 않는 고유한 값을 집계할 때 유용한 자료 구조

### 특징
1. 데이터 자체를 저장하지 않고 자체적인 방법으로 데이터를 변경해 처리
	데이터를 저장하는 것이 아닌 leading zero 방식을 이용한 확률적 기법으로 최대 값을 저장하는 방식
	[[leading zero 기법]]

2. 데이터 개수에 구애받지 않고 일정한 메모리를 유지
	12KB의 고정된 크기를 사용(1개든 10억개든 12KB 사용)
3. 중복되지 않는 유일한 원소의 개수를 계산
	해시를 통한 중복 제거 매커니즘으로 중복을 제거하고 고유한 개수만 카운트

### 활용 방법
**PFADD, PFCOUNT**
```
PFADD : hyperloglog에 아이템 저장
ex)
PFADD members 123
(integer) 1 >> 변경 여부(0이면 변경되지 않음, 1이면 변경 됨)

PFCOUNT : 저장된 아이템의 개수 추정
PFCOUNT members
(integer) 3 >> 카디널리티 갯수
```

## Geospatial
경도, 위도 데이터 쌍의 집합으로 지리 데이터를 저장할 수 있는 방법

### 특징
1. 내부적으로 데이터는 sorted set으로 저장
2. 하나의 자료 구조 안에 키는 중복 저장되지 않음

### 활용 방법
**GEOADD, GEOPOS, GEODIS, GEOSEARCH**
```
GEOADD : 경도 위도 저장
ex) GEOADD travel(키) 14.399689....(경도) 50.099242.....(위도) seoul(멤버)
(integer) 1


GEOPOS : 저장된 위치 데이터 조회
ex)
GEOPOS travel seoul
1)14.399689....
2)50.099242.....

GEODIS : 두 아이템 사이의 거리를 반환
GEODIS tracel seoul busan KM(거리 단위)
"400.1123" >> 거리


GEOSEARCH : 특정 위치를 기준으로 원하는 거리 내에 있는 아이템을 검색
ex)
GEOSEARCH travel FROMLONLAT 14.399689.... 50.099242..... BYRADIUS 200 KM
1) Incheon
2) Daejeon

```


## Stream
레디스를 메시지 브로커로서 사용할 수 있게 해주는 자료 구조
카프카에서 영향을 받아 만들어짐

### 특징
1. 소비자 그룹 개념을 도입해 데이터를 분산 처리
2. 실시간 이벤트 혹은 로그성 데이터 저장에 사용

자세한 내용은 7장에서.....
