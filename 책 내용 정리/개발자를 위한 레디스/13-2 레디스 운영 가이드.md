## 레디스 버전 업그레이드
레디스는 릴리스 주기가 다른 데이터베이스에 비해 굉장히 빠른편이며 EOL(End Of Life)도 굉장히 짧은 편이다.
버그와 보안 취약점을 방지하기 위해 최신 버전의 레디스를 사용하도록 업데이트 해주는것이 좋다.
레디스 버전 업그레이드 방식은 크게 두 가지로 나뉜다.

1. 업그레이드 할 버전의 레디스 인스턴스를 새로운 서버에 설치한 뒤 데이터 복제
	운영 중인 애플리케이션에서 레디스로의 접속 정보를 변경해야하지만 다운타임이 존재하지 않는다.
2. 신규 버전의 레디스 소스 파일로 재실행
	레디스 접속정보를 변경하지 않아도 되지만 싱글 구성이었다면 다운 타임이 존재한다.

### 센티널 구성의 레디스 버전 업그레이드
1. 신규 버전의 레디스 바이너리 파일 다운로드
```
$wget http://download.redis.io/releases/redis-7.0.7.tar.gz
$ tar -zxvf redis-7.0.7.tar.gz
$ rm redis-7.0.7.tar.gz
$ cd redis-7.0.7
$ make
$ mv /home/centos/redis /home/centos/redis-old
$ mv /home/centos/redis-7.0.7 /home/centos/redis
>> 바이너리 파일 다운 후 압축 해제, 빌드하고 기존 버전은 redis-old로 옮기고 신규 버전은 redis로 옮긴다.
```
2. 3대의 센티널 인스턴스 모두 중단
```
$ /home/centos/redis/src/redis-cli -p 26379 shutdown
>> 센티널 포트 중단
```
3. 신규 버전 폴더에 기존 sentinel.conf 복사
```
cp /home/centos/redis-old/sentinel.conf /home/centos/redis/sentinel.conf
```
4. 신규 바이너리 파일을 이용해 3대의 센티널 인스턴스 시작
```
$ /home/centos/redis/src/redis-sentinel /home/centos/redis/sentinel.conf
>> 센티널 설정 파일을 참조하여 센티널을 실행하라는 명령어
```
5. 복제본 인스턴스 중단
```
$ /home/centos/redis/src/redis-cli config rewrite
$ /home/centos/redis/src/redis-cli shutdown
>> 인스턴스를 중단하기 전에 레디스 인스턴스의 정보가 설정 파일에 반영될 수 있도록 rewrite를 먼저 해주는 것이 좋다.
```
6. 신규 버전 폴더에 기존의 redis.conf 복사
```
$ cp /home/centos/redis-old/redis.conf /home/centos/redis/redis.conf
```
7. 신규 바이너리 파일을 이용해 복제본 인스턴스 시작
```
$ /home/centos/redis/src/redis-server /home/centos/redis/redis.conf
```
8. 센티널에서 수동 페일오버 수행
```
127.0.0.1:26379> sentinel failover mymaster
OK
>> 센티널을 수동으로 페일오버 시켜 마스터 서버에서 INFO replication 커맨드를 사용해 정상적으로 slave 변경된 것을 확인해야한다.
```
9. 기존 마스터 인스턴스 중단
10. 신규 버전 폴더에 기존의 redis.conf 복사
11. 신규 바이너리 파일을 이용해 기존 마스터 인스턴스 시작
12. 센티널에서 수동 페일오버 수행(페일백)
9~12번은 5~8번 까지의 행동을 반복하여 기존 마스터를 다시 마스터 인스턴스로 수행하는 페일백을 할 수 있다.

### 클러스터 구성의 레디스 버전 업그레이드
클러스터 구성은 센티널보다 더 간단하게 진행할 수 있다.
클러스터의 각 레디스 인스턴스를 A~F라 하고 A~C가 마스터, D~F가 복제본일 때 업그레이드 예시를 보자

1. D, E, F 노드 각각 버전 업그레이드
2. D 노드에서 페일오버
3. A 노드 업그레이드
4. E 노드에서 페일오버
5. B 노드 업그레이드
6. F 노드 페일오버
7. C 노드 업그레이드

복제본 먼저 업그레이드 후 순차적으로 복제본을 페일오버하고 마스터 노드들을 업그레이드 해주면 된다.

## 레디스 운영 가이드

### 장애 또는 성능 저하를 유발할 수 있는 레디스의 설정 항목

#### maxmemory-policy
레디스가 메모리 한계에 도달했을 때 어떤 키를 제거할지를 결정하는 설정값
기본값은 Noeviction으로 레디스에 데이터가 가득 차더리도 임의로 데이터를 삭제하지 않고 데이터 저장이 불가하는 오류를 반환

이는 데이터 유실은 방지하지만 레디스에 데이터 입력이 불가해 애플리케이션 장애로 이어질 가능성이 높다.
따라서 allkey-lru로 설정하는 것을 권장

#### stop-writes-on-bgsave-error
RDB 스냅샷이 정상적으로 저장되지 않았을 때 레디스로의 모든 쓰기 작업을 중지하는 역할

레디스 서버에 다른 모니터링 기능이 활성화돼 있어 디스크 문제가 발생해도 이를 신속하게 감지할 수 있으며
레디스의 쓰기 작업은 중단하지 않고 계속되기를 원한다면 이 설정을 비활성화 하는것을 권장

기본 설정값은 yes이며 no로 바꿀 결우 백업이 실패해도 쓰기 작업이 계속 된다.

#### 자동 백업 옵션
레디스에서 RDB와 AOF를 사용해 백업 파일을 생성하는 작업은 레디스 인스턴스에 큰 부하를 줄 수 있다.
따라서 백업 작업은 의도한 시간에 의도한 레디스 인스턴스에서 실행될 수 있도록 설정해야한다.

save 옵션은 일정 기간 동안 변경된 키의 개수가 조건에 맞을 때 자동으로 RDB 파일을 생성하는데
트래픽이 많은 서비스의 경우 기본 설정값을 사용하지 않는것이 좋다.(기본 값을 설정할 경우 RDB 백업 빈도가 너무 잦아진다.)
```
CONFIG GET save
1) "save"
2) "3600 1 300 100 60 10000" >> 기본 값으로 1시간에 1번, 5분에 100번, 1분에 10,000번의 변경 작업이 수행되면 RDB 백업

CONFIG SET save ""
OK
>> 따라서 save 값을 변경해준다.
```

appendonly를 yes로 설정해서 AOF 형식의 백업을 수행하는 경우에도 주의해야 한다.
```
CONFIG GET auto-aof-*
1) "auto-aof-rewrite-percentage"
2) "100"
3) "auto-aof-rewrite-min-size"
4) "67108864"
```
percentage가 100인 경우 AOF 파일 크기가 기존 AOF 파일 크기보다 100% 증가하면 자동으로 재작성하기 때문에
해당 값을 0으로 변경해서 자동으로 재작성되는 것을 방지하고 운영자가 원하는 시점에 수동으로 백업하도록 바꾼다.

### 레디스 운영 및 성능 최적화

#### 오래 걸리는 커맨드 사용
레디스는 싱글 스레드로 동작하여 모든 요청을 이벤트 루프를 이용해 순차적으로 실행한다.
이 때 한 번에 하나의 커맨드만 처리가 가능하므로 특정 커맨드의 실행 시간이 길어지면 다른 요청이 대기하는 시간이 길어진다.
따라서 레디스에서 O(N) 이상의 시간 복잡도를 갖는 커맨드를 사용하는것을 지양한다.

keys, flushall 등 한 번에 여러 키에 접근하는 커맨드의 수행시간이 오래 걸린다고 생각하지만
실제로는 set, list, hash와 같은 커맨드들도 자료 구조안에 여러 개의 아이템이 있으면 아이템의 개수에 비례해 실행 시간이 증가한다.

**키스페이스 커맨드**
키스페이스 커맨드의 시간 복잡도에서 N은 전체 키의 개수를 의미하며
커맨드의 시간 복잡도가 O(N)일 때 레디스에 저장된 키의 개수에 비례해 수행 시간이 증가한다.

KEYS
레디스에 저장된 모든 키에 한 번씩 접근하기 때문에 O(N)의 시간 복잡도를 가진다.
키가 많을수록 오랜 시간이 소요되므로 SCAN 커맨드로 대체하는 것이 좋다.

FLUSHALL
옵션 없이 실행하면 SYNC 방식으로 동작한다.
모든 키를 삭제한 뒤 OK를 반환하기 때문에 O(N)의 시간 복잡도를 가진다.
FLUSHALL과 ASYNC를 함께 사용하면 데이터 삭제 작업이 백그라운드에서 실행되어 다른 작업을 블락시키지 않는다.

FLUSHDB
FLUSHALL과 마찬가지로 옵션 없이 사용하면 SYNC로 동작하며 O(N)의 시간 복잡도를 가진다.
ASYNC를 함께 사용하면 백그라운드에서 작업하여 다른 작업을 블락하지 않는다.
```
FLUSHALL과 FLUSHDB의 차이점
FLUSHALL은 레디스 내의 모든 데이터 삭제
FLUSHDB는 선택된 데이터 베이스만 삭제
>> 레디스는 0~15번까지 16개의 논리적 데이터에이스를 제공한다. 이중 선택된 데이터 베이스만 삭제하는게 FLUSHDB

SELECT 0 >> DB 0번 선택
SELECT 1 >> DB 1번 선택
```

**자료 구조 공통 커맨드**
자료 구조 공통 커맨드의 시간 복잡도에서 N은 자료 구조 내부의 아이템 개수를 의미하며 하나의 자료 구조에 속한 아이템의 개수에 비례해 수행 시간이 증가한다.

DEL
키를 삭제하는 커맨드
string 키를 삭제한다면 O(1)의 시간 복잡도를 갖지만
list, set, sorted set ,hash와 같은 자료 구조를 삭제할 때는 자료 구조 내의 아이템 개수에 따라 선형적으로 증가해 O(N)의 시간 복잡도를 가진다.
포그라운드에서 작동되는 커맨드여서 백그라운드 방식으로 키를 삭제하고 싶다면 UNLINK를 사용해야한다.

SORT/ SORT_RO
list, set, sorted set에서만 사용 가능한 커맨드로 키 내부의 아이템을 정렬해 반환

SORT의 시간 복잡도는 O(N + Mlog(M))이다.
여기서 N은 리스트나 셋 내부의 아이템 수를 나타내며 M은 반환되는 아이템 수를 의미한다.

SORT_RO 커맨드는 SORT와 동일하게 동작하지만 SORT에 있는 STORE 옵션(정렬 결과를 새로운 키에 저장하는 옵션)을 사용할 수 없다.
SORT는 STORE 옵션으로 인해 쓰기가 가능한 커맨드로 분류되며 복제본에서 사용할 수 없다.
SORT_RO는 STORE를 사용할 수 없기 때문에 읽기 전용으로 분류되어 복제본에서 사용할 수 있다.

**set 관련 커맨드**
set 자료 구조에서 집합 연산을 수행하는 커맨드는 모두 집합의 카디널리티에 비례해 수행시간이 증가

SDIFF/SDIFFSTORE
차집합을 수행하는 커맨드로 O(N)의 시간 복잡도를 가진다.
SDIFF는 차집합 연산 결과를 반환하고 SDIFFSTORE는 연산 결과를 따로 저장한다.

SUNION/SUNIONSTORE
합집합을 수행하는 커맨드로 O(N)의 시간 복잡도를 가진다.
SUNION은 합집합 연산 결과를 반환하고 SUNIONSTRORE는 연산 결과를 저장한다.

SINTER/SINTERSTORE/SINTERCARD
교집합을 수행하는 커맨드로 O(N X M)의 시간 복잡도를 가진다.
N은 가장 작은 집합의 카디널리티이며 M은 연산을 수행하는 집합의 수를 의미한다.
SINTER는 교집합의 결과를 반환하고 SINTERSTORE는 연산 결과를 저장한다.

버전 7에서 새로 추가된 SINTERCARD는 교집합 연산으로 얻어진 결과의 카디널리티만 반환한다.

**list 관련 커맨드**
lis는 인덱스를 가지고 있지만 내부의 특정 인덱스에 접근할 때까지의 아이템 수에 비례해 수행시간이 증가한다.
최악의 경우 list의 전체를 순회해야 할 수 있다.
```
레디스의 List는 내부적으로 linked list로 구현되어 있어 특정 인덱스에 접근할 때 O(N)이다.
```

LINDEX
list에서 입력받은 인덱스 위치에 있는 아이템을 리턴
시간 복잡도는 O(N)이며 인덱스에 있는 아이템에 도달하기 위해 지나쳐야 하는 아이템의 개수를 의미한다.

LINSERT
BEFORE 또는 AFTER라는 피봇 값을 필수 인자로 입력받는데 해당 피봇 값의 이전 또는 이후에 신규 아이템을 입력하도록 동작한다.
시간 복잡도는 O(N)이며 N은 피봇 값까지 도달하기 위해 지나쳐야하는 아이템의 개수를 의미한다.
```
LINSERT key BEFORE|AFTER pivot(기준값) value(삽입할 값)
>> 기준 값을 찾아서 그 앞/뒤에 넣으라는 명령어
```

LSET
특정 인덱스의 아이템을 신규 입력한 문자열로 변경하며 시간 복잡도는 O(N)이다.
N은 리스트의 길이를 뜻한다.

LPOS
레디스 6.0.6에서 추가된 커맨드로 문자열을 인자로 입력받는다.
list를 순회하며 입력받은 문자열이 있는지 확인하고 해당 아이템의 인덱스를 리턴한다.
시간 복잡도는 O(N)이며 N은 리스트의 길이를 뜻한다.

**hash 관련 커맨드**
hash 내부에 아이템이 많아지면 전체 키에 접근하는 커맨드의 수행 시간이 증가해 위험할 수 있다.

HGETALL
hash에 저장된 모든 아이템의 키와 값을 리턴하기 때문에 O(N)의 시간 복잡도를 갖는다.

HKEYS
hash에 저장된 모든 아이템의 키를 리턴하기 때문에 O(N)의 시간 복잡도를 갖는다.

HVALS
hash에 저장된 모든 아이템의 값을 리턴하기 때문에 O(N)의 시간 복잡도를 갖는다.

**sorted set 관련 커맨드**
sorted set은 데이터가 자동으로 정렬되므로 O(log(N))의 시간 복잡도를 갖는다.
이는 아이템 수가 증가해도 실행 시간이 빠르게 증가하지 않는 효율적인 방식을 의미한다.

하지만 집합 연산을 할 때에는 set과 마찬가지로 아이템 개수에 비례해 수행 시간이 증가한다.

ZDIFF/ZDIFFSTROE
차집합을 수행하는 커맨드이며 O(L+(N-K)lon(N))의 시간 복잡도를 가진다.
L은 모든 집합의 총 아이템 수, N은 첫 번째 셋의 크기, K는 결과 셋의 크기를 의미한다.

ZUNION/ZUNIONSTORE
합집합을 수행하는 커맨드이며 O(N)+O(M X log(M))의 시간 복잡도를 가진다.
N은 모든 집합의 총 아이템 수이며 M은 결과 집합의 아이템 수를 의미한다.

ZINTER/ZINTERSTORE/ZINTERCARD
ZINTER/ZINTERSTORE는 교집합을 수행하는 커맨드이며 O(N X K) + O(M X log(M))의 시간 복잡도를 가진다.
N은 가장 작은 집합의 카디널리티이며 K는 연산을 수행하는 집합의 수, M은 결과 집합의 카디널리티를 의미한다.

ZINTERCARD는 교집합 연산으로 얻어진 집합의 카디널리티를 반환하며 시간 복잡도는 O(N X K)이다.

#### 레디스에서의 트랜잭션 사용과 주의 사항
레디스도 트랜잭션을 사용할 수 있으며 원자적으로 수행돼야 하는 커맨드를 보장할 수 있어 유용하다.
그러나 레디스는 싱글 스레드로 동작하기 떄문에 트랜잭션을 사용할 때 주의해야 한다.

**MULTI/EXEC**
multi는 트랜잭션을 시작하는 커맨드로 multi 이후에 실행하고자 하는 커맨드를 입력하고 EXEC을 실행하면
입력했던 커맨드를 원자적으로 실행하고 트랜잭션이 성공하면 결과를 반환한다.
만약 트랜잭션 중간에 오류가 발생하면 트랜잭션 내 모든 커맨드를 롤백하고 트랜잭션을 종료한다.

**루아 스크립트**
루아 스크립트는 가볍고 빠르며 임베디드가 가능한 스크립트 언어로 간단한 문법과 빠른 실행속도를 갖고 있다.
(임베디드가 가능하다 : 다른 프로그램 안에 내장시켜서 사용할 수 있다는 뜻)

레디스는 루아 스크립트 실행 기능을 내장해 데이터 조작 및 계산과 같은 작업을 루아 스크립트로 처리할 수 있다.

루아 스크립트는 레디스 내에서 원자적으로 실행되므로 여러 명령을 한 번에 실행할 수 있고 중간에 다른 요청을 받아들이지 않아 데이터 일관성을 유지할 수 있다.
트랜잭션과 비슷한 원자성을 갖지만 트랜잭션과 달리 일부 명령어가 실패해도 다음 명령어로 진행되며 롤백이 발생하지 않는다.

루아 스크립트를 사용하면 데이터를 매번 네트워크로 전송하지 않고 서버에서 계산을 수행해 애플리케이션의 성능을 향상시킬 수 있다.
```
## 입금 트랜잭션 루아 스크립트 예시

local key = KEYS[1] -- 키 이름
local amount = tonumber(ARGV[1]) -- 인자로 받은 값을 숫자로 변환

-- 인자값만큼 증가시키고 새로운 잔고를 계산
local newBalance = redis.call('INCRBY', key, amount)

-- 로그에 기록
local logMessage = '입금' .. amount
local logCount = redis.call('RPUSH', 'transaction_log', logMessage)

-- 결과 반환
return { newBalance, logCount}
```

레디스에서 스크립트를 로드하고 실행하려면 SCRIPT LOAD 커맨드와 EVALSHA 스크립트를 사용할 수 있다.
```
## SCRIPT LOAD
> SCRIPT LOAD "local key = KEYS[1] .... 스크립트 내용"
"1bb437215..." >> hash 값

SCRIPT LOAD로 루아 스크립트를 로드하면 해당 스크립트에 대한 hash 값이 반환된다.
한번 로드한 이후에는 반환된 해시 값을 이용해 스크립트를 실행할 수 있다.

## EVALSHA
EVALSHA를 사용하면 스크립트를 다시 전송하지 않고도 스크립트를 반복해 실행할 수 있으며 네트워크 대역폭을 절약할 수 있다.

> GET account_balance
 0

>EVALSHA 1bb437215...  1 account_balance 1000
1000
1

> GET account_balance
1000

> LRANGE transaction_log 0 -1
입금 1000

>> 이렇게 매번 스크립트 전체를 보내지 않고 해시값만 보내도 루아 스크립트가 실행된다.
>> 결론적으로 네트워크 전송량이 줄어들어 성능도 향상되고 네트워크 비용도 절약할 수 있다.
```

**트랜잭션과 루아 스크립트 사용할 때의 주의점**
트랜잭션과 루아 스크립트를 사용하는 도중에 다른 클라이언트의 커맨드는 모두 대기 상태에 머물러서 트랜잭션이 길어지지 않도록 주의해야 한다.
레디스에서는 트랜잭션과 루아 내부에 블로킹 커맨드(BLPOP, BRPOP)를 사용할 수 없도록 강제하고 있는데
트랜잭션 내부에서 블로킹 될 경우 레디스는 무한 대기 상태에 빠질 수 있다.
```
블로킹 커맨드 : 조건이 만족될 때까지 기다리는 명령어
```

#### has-get / has-del 패턴
레디스에서 데이터 조회 또는 삭제 시 EXISTS 커맨드를 사용해 데이터 존재 여부를 확인 후 처리하는 has-get, has-del 패턴은 지양하는것이 좋다.
이런 패턴은 네트워크 부하를 발생시키며 성능을 저하시킨다.

부하 뿐만 아니라 원자성 문제도 야기할 수 있다.
키의 존재 여부를 확인한 후 다음 커맨드를 수행하기 전까지 다른 클라이언트가 해당 키를 변경하거나 삭제할 수 있으므로 예상치 못한 결과를 초래할 수 있다.

#### 클라이언트 출력 버퍼 사이즈
보통 버퍼 크기는 기본 설정값으로 충분할 수 있지만 대용량 데이터를 처리하거나 많은 커맨드를 처리하는 경우 버퍼 크기가 작을 때 버퍼 오버플로우가 발생할 수 있다.
트래픽이 많은 서비스의 경우 출력 버퍼의 크기를 늘리는 것이 좋다.
또한 복제를 사용하는 경우에는 출력 버퍼의 크기를 늘리는 것이 거의 필수적이다.

출력 버퍼 사이즈는 클라이언트 별로(normal, pub/sub, replica) 설정할 수 있으며 12장에서 자세히 다뤘다.

레디스의 스펙 업그레이드를 할 때 maxmemory 또는 maxclients를 확장할 때 복제본에 대한 출력 버퍼 사이즈를 조절하는 것이 중요하다.
이를 고려하지 않으면 데이터를 복제할 때 복제 버퍼가 가득 차 부분 동기화 또는 데이터 손실 등의 문제가 발생할 가능성이 존재한다.

#### 레디스 키스페이스 알림 기능을 사용한 키 만료 모니터링
키스페이스 알림 기능은 레디스 내부 키에 대한 변경 사항을 모니터링하며 내부의 pub/sub 채널을 이용해 변경 사항에 대한 메시지를 구독할 수 있는 기능이다.
예를 들어 키의 만료를 지속적으로 감시하다가 만료 이벤트가 발생하면 감지해서 애플리케이션에서 필요한 추가 작업을 수행할 수 있다.

notify-keyspace-events 설정을 통해 어떤 알람을 수신할 것인지를 지정해야 한다.
```
K: 키스페이스 이벤트, 이벤트가 발생한 데이터베이스에 대해 keyspace@<db> 접두사와 함께 발행, 키를 중심으로 모니터링
E: 키 이벤트, 이벤트가 발생한 데이터베이스에 대해 keyevent@<db> 접두사와 함께 발행, 명령어를 중심으로 모니터링
g: 일반적인 명령 이벤트, DEL, EXPIRE, RENAME 등과 같은 명령어와 관련된 이벤트
$:문자열 명령어와 관련된 이벤트
l: 리스트 명령어 관련된 이벤트
s: 집합 명령어와 관련된 이벤트
h: hash 명령어와 관련된 이벤트
z: 정렬 집합 명령어와 관련된 이벤트
t: stream 명령어와 관련된 이벤트
x: 만료된 키 이벤트(expire)
e:삭제된 키 이벤트(eviction)
m:누락된 키 이벤트(miss), 존재하지 않는 키에 접근할 때 발생
n: 새로운 키 이벤트(new)
A: "g$lshztxed"의 별칭으로 "m" 및 "n" 이벤트를 제외한 모든 이벤트를 포함
```

예시
```
CONFIG SET notify-keyspace-events Ex
OK
>> E는 키 이벤트, x는 만료된 이벤트이므로 만료 명령어를 모니터링 하겠다는 의미
>> CONFIG SET으로 설정 가능

__keyevent@0__:expired 채널을 구독하면 키가 만료될 때 아래와 같은 메시지를 수신 가능
SUBSCRIBE __keyevent@0__:expired
1) "message"
2) "__keyevent@0__:expired"
3) "my_key"
>> 명령어를 모니터링해서 만료된 키가 어떤 것인지 반환받음

반대로 __keysapace@0__:my_key 였다면(키스페이스 이벤트)
SUBSCRIBE __keyspace@0__:my_key
1) "message"
2) "__keyspace@0__:my_key"
3) "del"
>> 키를 모니터링해서 해당 키에 실행된 명령어가 어떤 것이지 반환받음
```

이렇게 키 만료를 감지해 다른 작업을 수행해야하는 서비스에서는 메시지를 안정적으로 관리하기 위해 추가적인 조치가 필요할 수 있다.
많은 키가 동시에 만료될 가능성이 있는 서비스에서는 pub/sub 버퍼의 크기를 늘려서 많은 이벤트가 대기할 수 있도록 조절해야한다.

#### 특정 프리픽스를 가진 키 삭제하기
레디스에서는 특정 프리픽스를 기반으로 키를 삭제하는 기능을 제공하지 않는다.
하지만 프리픽스를 사용해 키를 구분하는 경우가 많으며 특정 프리픽스를 가진 키를 일괄적으로 삭제해야 하는 경우가 생긴다.

```
pattern = 'prefix:*'
count = 100
cursor, keys = 0, []

# SCAN 명령을 사용해 특정 프리픽스를 가진 키 검색
while True:
	cursor, partial_keys = r.scan(cursor, match=pattern)
	keys.extend(partial_keys)
	if cursor == 0:
	break

# 검색된 키 삭제
for key in keys:
	r.delete(key)
	
이렇게 특정 프리픽스를 가진 키를 스캔하여 keys 배열에 넣어 일괄적으로 삭제한다.
```
![[KakaoTalk_Photo_2025-10-23-21-54-46 1.jpeg|800]]
해당 방식은 A : 키 검색 후 반환, B : 키 삭제로 총 두 번의 접근이 필요해 시간이 오래 걸린다.

하지만 루아 스크립트를 이용한다면 네트워크 I/O를 줄여서 효율적으로 실행할 수 있다.
```
# 삭제할 키의 패턴 및 스캔 파라미터 설정
pattern = 'prefix:*'
count = 100
sursor = "0"

# 루아 스크립트 정의
lua_script = ""
local cursor = ARGV[1]
local pattern = ARGV[2]
local count = ARGV[3]
>> ARGV는 스크립트 호출 시 전달된 인자 배열

local keys = redis.call("SCAN", cursor, "MATCH", pattern, "COUNT", count)
>> redis에서 scan 명령을 실행, 결과는 {새로운 커서, 찾은 키 목록}    ex. {"12345", {key1, key2 ...}}
local cursor = keys[1]
>> keys의 첫 번째 인자인 새로운 커서 값이 cursor에 할당, 다음 스캔에 사용할 위치 정보(cursor)
local keylist = keys[2]
>> keys의 두 번째 인자인 반환된 키 목록

for _, key in ipairs(keylist) do
	redis.call("DEL", key)
	end
>> _는 인덱스 사용 안함, keylist 배열을 순회하여 각 키를 삭제

return {cursor, #keylist}
>> 2개의 값을 배열로 반환, cursor: 다음 스캔을 위한 커서 값 #keylist: 삭제한 키의 개수(#은 루아에서 배열 길이 연산자)

# 반복적으로 루아 스크립트를 호출해 키를 조회하고 삭제
while True:
	result = r.eval(lua_script, 0, cursor, pattern, count)
	cursor, deleted_count = result[0], result[1]
	total_deleted_count += deleted_count
	
	if cursor == "0" :
	break
>> 루아 스크립트를 계속 호출해서 cursor가 0이 될 때까지 반복
```
![[KakaoTalk_Photo_2025-10-23-22-02-22.jpeg|675]]
루아 스크립트를 사용하면 매번 DEL 명령을 호출하는 과정이 생략됐다.

루아 스크립트가 실행되는 동안 다른 클라이언트의 커맨드는 차단될 수 있기 때문에 운영 환경에서는 적절한 크기로 count 매개변수를 조절해야 한다.

### 레디스 모니터링

#### 슬로우 로그
슬로우 로그는 실행 속도가 느린 커맨드를 기록하는 로그
슬로우 로그를 주기적으로 모니터링해 느린 커맨드를 추적하고 디버깅해서 성능을 향상시킬 수 있다.

redis-cli에서 SLOWLOG GET 커맨드로 확인 가능
```
SLOWLOG GET
1) 1) (integer) 1923
   2) (integer) 1696344048
   3) (integer) 35233   
   4) 1) "SCAN"
      2) "10179327"
      3) "COUNT"
      4) "50000"

각 레코드 정보
실행 시간(timestamp) : 명령이 실행된 시간 정보
실행 시간(ms) : 명령이 실행되는 데 소요된 시간(ms 단위)
명령 : 느리게 수행됐던 커맨드
인자 : 느린 명령에 대한 인자 정보
```

슬로우 로그에 남는 기준은 slowlog-log-slower-than 설정에서 변경할 수 있으며 기본은 10,000ms로 10초이다.

또한 slowlog-max-len에서 슬로우 로그에 유지되는 레코드의 개수를 제한 한다.
기본값은 128개이며 최대 128개의 로그 레코드만 유지되고 오래된 레코드는 새로운 레코드로 교체된다.

슬로우 로그를 주기적으로 검토해 오래 걸리는 명령을 확인하고 성능 개선을 할 수 있다.

#### 그래프 지표
레디스를 안정적으로 운영하기 위해서는 각 지표를 적절히 모니터링 해야한다.
CPU, 메모리, 네트워크 등 컴퓨팅 자원을 얼마나 쓰고 있는지 확인하고 과다 또는 과소 사용되고 있는 부분을 확인해서 조치를 취해야 한다.

#### cpu
일반적으로 시간 복잡도가 높은 커맨드를 자주 사용하면 cpu 부하가 늘어나고 집합 자료 구조의 카디널리티가 높을 수록 성능 저하의 원인이 될 수 있다.

슬로우 로그를 활용해 실행 시간이 오래 걸리는 작업을 확인하고 불필요한 작업을 최소화하는 것이 좋다.

#### 메모리
메모리는 레디스의 핵심 요소 중 하나이며 안정적인 운영을 위해 주의 깊게 모니터링 해야하는 지표이다.

레디스 메모리 사용에 대한 핵심 지표 중 하나는 used_memory로 이는 레디스가 현재 할당한 메모리를 나타낸다.
또한 메모리 사용량을 파악하기 위해 현재 메모리 사용량 BytesUsedCache와 maxmemory의 백분율을 계산하는 
DatabaseMemoryUsagePercentage 지표를 활용할 수 있다.

DatabaseMemoryUsagePercentage가 100%에 도달하면 레디스의 maxmemory 정책이 작동하며 정책에 따라 이빅션이 실행될 수 있다.

used_memory가 레디스가 논리적으로 사용하는 메모리라면
used_memory_rss는 운영체제가 레디스 프로세스에 할당한 실제 물리적인 메모리 양을 반영한다.
논리적인 메모리에 비해 물리적 메모리가 너무 커질 때 메모리 단편화 문제가 발생할 수 있다.
이는 메모리 효율설이 떨어질 수 있으며 이를 관리하기 위해 active defragmentation 기능을 활성화 할 수 있다.
이는 메모리 단편화 문제를 해결하는데 도움을 주며 기본적으로는 비활성화 되어있다.

#### 네트워크
레디스를 사용할 때에는 네트워크 I/O 지표를 확인해 네트워크 트래픽을 모니터링해야 한다.
가상 머신, 도커, 쿠버네티스 등의 환경에서 레디스를 사용하는 경우 레디스가 실행되는 노드의 네트워크 대역폭 한계에 도달하면 성능에 영향을 미친다.
따라서 네트워크 모니터링을 통해 네트워크 병목현상이 발생하고 있는지 확인하는 것이 좋다.

읽기 작업이 문제가 되는 경우에는 복제본을 우선적으로 사용하는지 확인하고 그래도 네트워크 사용량이 높은 경우 추가 복제본 구성으로 해결할 수도 있다.

쓰기 작업이 문제가 되는 경우에는 서버의 사양을 업그레이드 하거나 클러스터 모드로 사용해 여러 노드에 분산되도록 하여 부하를 분산할 수 있다.

#### 커넥션
클라이언트의 연결 추이를 모니터링하는 것은 중요하다.

레디스의 활성 연결 수와 신규 연결 수를 확인해 일반적인 수준과 다른 변화가 있는지 주시해야 한다.
갑자기 활성 연결 수가 증가하는 경우에는 애플리케이션에 문제가 발생하거나 연결이 올바르게 종료되지 않아 레디스에 유지되고 있는지 확인해야한다.
이때 레디스의 tcp-keepalive 설정을 활용하면 유휴 연결을 방지할 수 있다.

레디스에서 새로운 연결을 설정하는 것은 상당한 비용이 들기 때문에 기존 연결을 재사용하기 위해 커넥션 풀링을 사용하는 것이 좋다.

#### 복제
마스터 노드는 복제본이 있는 경우 지속적으로 데이터 명령 스트림을 전송한다.

복제 구성의 경우에는 복제 지연이 있는지 확인하는 것이 중요한데 복제 지연의 급증은 마스터 노드의 속도를 복제본이 따라가지 못하는 것이다.
복제 지연이 길어지면 전체 동기화를 요청해야 할수도 있는데 이 과정에서 마스터 노드에서 스냅샷을 생성하기 때문에 레디스의 성능 저하를 유발한다.

마스터 노드로의 많은 쓰기 작업, 네트워크 대역폭 고갈 등으로 복제 지연이 발생할 수 있다.
복제 지연이 발생한다면 원인을 파악하고 조치하기 위해 다른 메트릭을 확인하는 편이 좋다.
