
## 고가용성 기능의 필요성
복제본을 구성하고 마스터에 장애가 발생한 경우에도 복제본에 데이터가 남아 있을 수 있다.
하지만 클라이언트가 마스터에 직접 연결된 상태였다면 장애 발생시 처리 과정이 다르다.
![[KakaoTalk_Photo_2025-10-02-12-43-28.jpeg|625]]
1. 복제본 노드에 직접 접속한 뒤 REPLICA OF NO ONE 커맨드를 입력해 읽기 전용 해제
2. 애플리케이션 코드에서 레디스의 엔드포인트를 복제본의 IP로 변경
3. 배포

따라서 운영 환경에서 별다른 고가용성 기능의 도입 없이 위와 같은 복제 구성으로만 레디스를 사용한다면
마스터 노드에 발생한 장애 처리가 지연돼 서비스 기능의 문제로 이어질 수 있다.

그리고 look aside 구성의 캐시로 사용할 경우에도 주의해야 한다.
애플리케이션이 캐시에 접근할 수 없을 경우 MySQL 같은 원본 데이터 소스에 접근을 하는데 이는 원본 소스에 부하가 급증하는 경우가 발생할 수 있다.

## 센티널이란?
센티널은 데이터를 저장하는 레디스 인스턴스와는 다른 역할을 하는 별도의 프로그램이며
자동 페일오버 기능을 사용하면 마스터 인스턴스에 장애가 발생하더라도 레디스를 계속 사용할 수 있도록 레디스의 다운타임을 최소화할 수 있다.

### 센티널의 기능
1. 모니터링 : 마스터, 복제본 인스턴스의 상태를 실시간으로 확인
2. 자동 페일오버 : 마스터의 비정상 상태를 감지해 정상 상태의 복제본 중 하나를 마스터로 승격
3. 인스턴스 구성 정보 안내 : 클라이언트에게 현재 구성에서의 마스터 정보를 알려주고 페일오버가 발생하면 변경된 마스터 정보를 재전달하기 때문에
					 페일오버가 발생하더라도 레디스의 엔드포인트 정보를 변경할 필요가 없다.

![[KakaoTalk_Photo_2025-10-02-12-56-55 001.jpeg|650]]

### 분산 시스템으로 동작하는 센티널
SPOF(Single Point Of Failure)는 하나의 서비스에 문제가 발생했을 때 전체 시스템이 영향을 받는 지점을 뜻한다.
복제와 자동 페일오버를 이용해 고가용성을 확보하는 이유는 레디스가 SPOF가 되는것을 방지하기 위함이다.

센티널은 그 자체로 SPOF가 되는 것을 방지하기 위해 최소 3대 이상일 때 정상적으로 동작할 수 있도록 설계됐으며
하나의 센티널에 이상이 생기더라도 다른 센티널이 계속해서 역할을 수행할 수 있게 된다.

센티널은 그림과 같이 클라이언트는 센티널에 먼저 연결해 마스터의 정보를 받아온다.
만약 레디스 인스턴스는 정상이지만 센티널 인스턴스에 문제가 생겨 정보를 받환할 수 없게 된다면 클라이언트는 레디스로 새로운 커넥션을 맺을 수 없게 된다.
하지만 3대의 센티널이 동작하기 때문에 하나의 센티널에 문제가 생기더라도 클라이언트는 다른 센티널에서 마스터의 정보를 정상적으로 받아올 수 있다.

**쿼럼(quorum)**
센티널이 오탐을 줄이기 위해 사용하는 개념
마스터가 비정상 동작을 한다는 것에 동의해야 하는 센티널의 수로 쿼럼을 만족하는 경우 페일오버를 시작

일반적으로 센티널 인스턴스가 3개일 때 쿼럼은 2로 설정
이 경우 최소 2개 이상의 센티널이 마스터의 비정상 상태를 동의해야 페일오버 프로세스를 시작한다.

센티널은 쿼럼을 이용하기 때문에 3대 이상의 홀수로 구성하는 것이 좋다.

### 센티널 인스턴스 배치 방법
기본적으로 센티널 인스턴스는 물리적으로 서로 영향받지 않는 서버에서 실행되는 것이 좋다.
![[KakaoTalk_Photo_2025-10-02-12-56-56 002.jpeg|650]]
그림과 같이 서로 다른 물리 서버에 배치하는 것이 가장 일반적인 배치 방법이다.
보통 하나의 서버에 레디스와 센티널 프로세스를 동시에 실행시킨다.

만약 해당 구조에서 마스터에 문제가 생기면 B, C에 있는 센티널이 마스터가 비정상 상태라는 것에 동의한 뒤 페일오버를 진행시킨다.
![[KakaoTalk_Photo_2025-10-02-13-31-01 001.jpeg|650]]
서버 B, C의 센티널 인스턴스는 새롭게 마스터가 될 복제본을 선출한 뒤 마스터로 승격시킨다.
기존 마스터를 바라보고 있던 클라이언트는 모두 새롭게 선출된 B로 연결되며 레디스로 들어오는 모든 커넥션은 B로 연결된다.

![[KakaoTalk_Photo_2025-10-02-13-31-01 002.jpeg|650]]
이후 서버 a가 복구 된다면 센티널 인스턴스 들은 기존 마스터 였던 서버 A를 B의 복제본으로 구성되도록 만든다.
이는 모두 센티널 인스턴스의 판단으로 자동 구성되며 운영자의 개입이 필요하지 않다.

예시와 달리 복제본이 1개만 필요한 서비스도 존재한다.
![[KakaoTalk_Photo_2025-10-02-13-38-28 001.jpeg|650]]
이 경우에는 2개의 서버에 레디스, 센티널 서비스를 실행하고 1개의 서버에는 센티널만 실행해도 된다.
센티널만 실행될 서버는 데이터를 직접 저장하지 않고 클라이언트의 요청을 받지도 않기 때문에 최저 사양으로 구성돼도 괜찮다.

![[KakaoTalk_Photo_2025-10-02-13-38-28 002.jpeg|650]]
만약 앞선 예제 처럼 서버 A에 문제가 생겨 마스터 노드와 센티널에 접근할 수 없게 되면
서버 B, C의 센티널이 서로 동의하여 복제본이 있는 서버 B를 마스터로 승격하여 운영될 수 있다.

서버 C는 최저 사양으로 구성해 리소스 비용을 아끼면서도 마스터의 장애를 감지해 자동 페일오버를 수행할 수 있는 안정적인 구조다.

## 센티널 인스턴스 실행하기
![[KakaoTalk_Photo_2025-10-02-13-38-29 003.jpeg|650]]
총 3대의 서버가 있으며 한 대는 센티널만 사용하는 구조이다.

### 센티널 프로세스 실행
센티널 프로세스를 띄우기 위해서는 sentinel.conf라는 별도의 구성 파일이 필요
```
sentinel.conf에 해당 내용을 추가
port 26379
sentinel monitor master-test 192.168.0.11 6379 2
>> sentinel monitor는 모니터링할 마스터의 이름을 지정하고 쿼럼 값을 지정한다.
```
센티널은 마스터와 복제본을 포함한 모든 레디스 프로세스를 모니터링하지만 구성파일에서는 복제본 정보를 입력하지 않아도 된다.
센티널 프로세스가 시작하면 마스터에 연결된 복제본을 자동으로 찾아내는 과정을 거친다.

센티널 인스턴스를 실행시킬 모든 서버에서 sentinel.conf를 작성한 뒤 각각 인스턴스를 시작해야한다.
```
# redis-sentinel을 이용한 방법
redis-sentinel /path/to/sentinel.conf

# redis-server를 이용한 방법
redis-server /path/to/sentinel.conf --sentinel
```
2개의 방법은 동일하게 동작하며 명시된 sentinel.conf 파일을 이용해 센티널 인스턴스를 시작시킨다.

레디스의 redis-cli를 통해 접근할 수도 있다.
```
redis-cli -p 26379
```

센티널 인스턴스에 접속하면 센티널이 모니터링하고 있는 마스터와 복제본 노드의 정보, 다른 센티널 인스턴스의 정보를 확인할 수 있다.
하지만 레디스가 가지고 있는 데이터는 확인할 수 없다.
```
SENTINEL master <master-name>
```
SENTINEL master 커맨드를 이용하면 원하는 마스터의 IP, 포트, 연결된 복제본의 개수 등 다양한 정보를 얻을 수 있다.

SENTINEL master 커맨드 입력후 출력되는 데이터를 통해 센티널이 정상적으로 구성됐는지 확인 가능하다.
```
num-other-sentinels : 마스터를 모니터링 하고 있는 다른 센티널의 정보

flags : 마스터의 상태, 비정상이면 s_down 또는 o_down으로 표시된다.

num-slaves : 현재 마스터에 연결된 복제본의 개수를 나타낸다.
```

SENTINEL replicas 또는 SENTINEL sentinels를 이용하면 마스터에 연결된 복제본의 자세한 정보를 확인 가능

SENTINEL ckquorum을 이용하면 마스터를 바라보고 있는 센티널 인스턴스가 설정한 쿼럼 값보다 큰지 확인할 수 있다.

### 페일오버 테스트
마스터와 복제본을 감시할 수 있도록 센티널이 정상적으로 구성된 것을 확인했다면 페일오버 테스트를 진행해보는 것이 좋다.

**커맨드를 이용한 페일오버 발생(수동 페일오버)**
```
SENTINEL FAILOVER <master-name>
```
해당 커맨드를 사용하면 다른 센티널의 동의를 구하지 않고 페일오버를 바로 발생시킬 수 있다.

센티널과 복제본 노드 간 네트워크 단절 등의 이슈로 인해 페일오버가 실패하진 않는지
센티널에 연결된 애플리케이션의 커넥션이 정상적으로 롤체인지된 마스터에 연결되는지 등의 정보를 볼 수 있다.

**마스터 동작을 중지시켜 페일오버 발생(자동 페일오버)**
직접 마스터 노드에 장애를 발생시킨 뒤 페일오버가 잘 발생하는지 확인, 센티널이 마스터가 비정상인 것을 잘 인지하는지 확인할 수 있다.
```
redis-cli -h <master-host> -p <master-port> shutdown
>> 레디스 프로세스를 직접 셧다운
```
센티널은 주기적으로 마스터 노드에 PING을 보내 응답이 정상적으로 돌아오는지 확인하여 마스터의 상태를 파악

이때 sentinel.conf에 지정한 down-after-milliseconds 시간 동안 응답이 없으면 비정상으로 간주해 페일오버를 트리거한다.
해당 옵션의 기본 값은 30,000으로 30초이다.

## 센티널 운영하기

### 패스워드 인증
마스터와 복제본 노드에 reqirepass/masterauth 옵션을 이용해 패스워드를 설정한 경우 센티널의 설정 파일에서도 패스워드를 지정해야 한다.
센티널을 이용한 구성에서는 장애 상황에 센티널이 자동으로 페일오버 시키기 때문에 복제 구성내의 모든 레디스 노드는 마스터 노드가 될 가능성이 있다고 볼 수 있다.
따라서 하나의 복제 그룹에서 requrepass와 masterauth 값은 모두 동일하게 설정해야 한다.

패스워드가 걸려 있는 레디스를 모니터링할 경우에는 sentinel.conf에 패스워드를 지정해야한다.
```
sentinel auth-pass <master-name> <password>
```

### 복제본 우선순위
모든 레디스 인스턴스는 replica-priority라는 파라미터를 가지고 있다.
센티널은 페일오버를 진행할 때 각 복제본 노드의 해당 파라미터 우선순위를 확인하며 값이 가장 작은 노드를 마스터로 선출한다.

기본값은 100이며 이 값이 0인 복제본은 절대 마스터로 선출하지 않는다.

### 운영 중 센티널 구성 정보 변경
센티널 실행 도중 모니터링할 마스터를 추가, 제거, 변경할 수 있다.
센티널이 여러 대라면 각 센티널에 모두 설정을 적용해야하며 설정 변경이 다른 센티널로 전파되진 않는다.
```
SENTINEL MONITOR <master name> <ip> <port> <quorum>
>> 새로운 마스터를 모니터링 할 수 있도록 한다.

SENTINEL REMOVE <master name>
>> 더 이상 지정하는 마스터를 모니터링 하지 않도록 지시한다.

SENTINEL SET <name> [<option> <value> ...]
>> 특정 마스터에 대해 지정한 파라미터를 변경할 수 있다.
ex)
SENTINEL SET mymaster down-after-milliseconds 1000
OK
>> mymaster라는 마스터의 down-after-milliseconds 옵션을 1초로 변경

```

레디스 버전 6.2 이상부터는 각 마스터에 종속되지 않는 센티널의 고유한 설정값도 런타임 중에 변경할 수 있다.
```
SENTINEL CONFIG GET <configuration name>
SENTINEL CONFIG SET <contiguration name> <value>
```
레디스 노드에서 CONFIG GET/SET으로 파라미터를 변경했던 것과 유사하게 사용할 수 있다.

### 센티널 초기화
센티널은 비정상적이라 판단한 복제본 노드에 대해서도 모니터링을 멈추지 않는다.

예를들어 서버 A가 마스터였지만 장애로 인해 서버 B가 마스터로 승격된 상황에서도 서버 B, C는 주기적으로 서버 A에게 PING을 보내 상태를 확인한다.
만약 서버 A가 더 이상 사용될 수 없는 상황이어서 모니터링을 중단하려면 SENTINEL RESET을 활용해 센티널 상태 정보를 초기화해야한다.
```
SENTINEL RESET <master name>
>> 마스터의 이름을 직접 지정할 수도 있고 *을 입력해 센티널이 모니터링 하고 있는 전체 마스터 정보를 초기화할 수도 있다.
```
실행 중인 센티널 인스턴스에서 RESET 커맨드를 이용하면 센티널 인스턴스의 상태 정보를 초기화하고
센티널이 모니터링 하고 있는 마스터, 복제본, 다른 센티널 인스턴스의 정보를 새로 고친다.

### 센티널 노드의 추가/제거
마스터를 모니터링 하도록 설정한 센티널 인스턴스를 실행시키면 자동 검색 메커니즘에 의해 자동으로 기존에 실행 중이던 다른 센티널의 known-list에 추가된다.

서버 C를 교체하기 위해 서버 D에 새로운 센티널을 추가할 경우
서버 D가 서버 A의 마스터를 모니터링 한다면 자동으로 서버 A, B에서 실행되고 있는 센티널에서 이를 인지하게 된다.

만약 한 번에 여러 대의 센티널을 추가해야한다면 10초 이상의 간격을 두고 1개씩 목록에 들어가도록 천천히 추가하는것이 오류를 줄일 수 있다.
추가가 끝나면 SENTINEL MASTER 커맨드를 통해 이상 없이 추가됐는지 확인할 수 있다.

센티널을 제거할 때는 제거할 센티널의 프로세스를 종료한 뒤 SENTINEL RESET을 통해 모니터링 정보를 리셋하면 된다.
이 때 센티널 인스턴스 사이에는 최소 30초의 대기 시간을 가지며 차례대로 실행하는 것이 좋다.

### 센티널의 자동 페일오버 과정

**마스터의 장애 상황 감지**
센티널은 down-after-milliseconds 파라미터에 지정된 값 이상 동안 마스터에 보낸 PING에 대해 유효한 응답을 받지 못하면 마스터가 다운됐다고 판단한다.
PING에 대한 유효한 응답은 +PONG, -LOADING, -MASTERDOWN이며 다른 응답이나 응답을 받지 못한 경우 유효하지 않다고 판단한다.

**sdown, odown 실패 상태로 전환**
하나의 센티널 노드에서 레디스 마스터 인스턴스에 대한 응답을 늦게 받으면 그 센티널은 우선 sdown(subjectly down, 주관적 다운)으로 플래깅한다.
```
SENTINEL is-master-down-by-addr <master-ip> <master-port> <current-epoch> <*>
>> 이후에 센티널 노드는 해당 커맨드를 보내 다른 센티널에게 장애를 전파한다.
```
해당 커맨드를 받은 센티널들은 해당 마스터 서버의 장애를 인지했는지 여부를 응답한다.
자기 자신을 포함해 쿼럼 값 이상의 센티널 노드에게 마스터의 장애를 인지한다면 센티널 노드는 마스터의 상태를 odown(objectly down, 객관적 다운)으로 변경한다.

이런 장애전파는 마스터 노드에서만 이루어지며 복제본 노드에서 장애가 발생했다해서 sdown을 전파하지 않는다.
다만 복제본에 sdown이 발생했다면 플래깅만 해놓고 추후에 마스터에 장애가 발생했을 때 해당 복제본을 마스터로 승격이 되지 않도록 한다.

**에포크 증가**
처음으로 마승터 노드를 odown으로 인지한 센티널 노드가 페일오버 과정을 시작한다.
센티널은 페일오버를 시작하기 전 우선 에포크(epoch) 값을 하나 증가 시킨다.

센티널은 에포크라는 개념을 이용해 각 마스터에서 발생한 페일오버의 버전을 관리한다.
에포크는 증가하는 숫자값으로 처음으로 페일오버가 일어날 때의 에포크 값은 1이 된다.
새로운 페일오버가 발생할 때마다 에포크 값은 하나씩 증가하며 동일한 에포크 값을 이용해 페일오버 과정이 진행되는 동안 모든 센티널 노드가 같은 작업을 시도하고 있다는 것을 보장할 수 있다.

**센티널 리더 선출**
에포크를 증가시킨 센티널은 다른 센티널 노드에게 센티널 리더를 선출하기 위해 투표하라는 메시지를 보낸다.
이 때 증가시긴 에포크를 함께 전달하는데 해당 메시지를 받은 다른 센티널 노드가 현재 자신의 에포크보다 전달 받은 에포크가 클 경우 자신의 에포크를 증가시키며
센티널 리더에게 투표하겠다는 응답을 보낸다.

만약 센티널 노드가 투표 요구를 받았을 때 함께 전달받은 에포크 값이 자신의 에포크 값과 동일할 때에는 이미 리더로 선출한 센티널의 id를 응답한다.
하나의 에포크에서 센티널은 하나의 센티널에 투표할 수 있으며 투표 결과는 변경할 수 없다.

**복제본 선정 후 마스터로 승격**
과반수 이상의 센티널이 페일오버에 동의했다면 센티널은 페일오버를 시도하기 위해 마스터가 될 수 있는 복사본을 선정한다.
승격 자격이 있는 복제본
1. redis.conf 파일에 명시된 replica-priority가 낮은 복제본
2. 마스터로부터 더 만흥 ㄴ데이터를 수신한 복제본
3. 2번 조건까지 동일하다면 runID가 사전 순으로 작은 복제본

선정한 복제본 에는 slaveOf no one 커맨드를 수행해 기존 마스터로부터의 복제를 끊는다.

**복제 연결 변경**
기존 마스터에 연결돼 있던 다른 복제본이 새로 승격된 마스터의 복제본이 될 수 있도록 복제본 마다 replicaof new-ip new-port 커맨드를 수행해 복제 연결 변경
복제 그룹의 모든 센티널 노드에서도 레디스의 구성 정보를 변경한다.

**장애 조치 완료**
모든 과정이 완료된 뒤 센티널은 새로운 마스터를 모니터링 한다.

### 스플릿 브레인 현상
스플릿 브레인이란 네트워크 파티션 이슈로 인해 분산 환경의 데이터 저장소가 끊어지고 끊긴 두 부분이 각각을 정상적인 서비스라고 인식하는 현상을 의미
![[KakaoTalk_Photo_2025-10-03-13-58-15 001.jpeg|625]]
그림은 마스터와 센티널 A, 복제본과 센티널 B, C간 네트워크 단절이 일어난 상황이다.
단절이 길어지면 센티널 B, C는 마스터 노드로의 접근이 정상적이지 않다는 것을 감지하여 복제본 노드를 마스터로 승격시킨다.
만약 마스터에 장애가 아닌 네트워크 단절의 상황이라면 한 복제 그룹에 2개의 마스터가 생기는 스플릿 브레인 현상이 발생한다.

![[KakaoTalk_Photo_2025-10-03-13-58-15 002.jpeg|625]]
클라이언트는 레디스에 연결할 때 센티널에 마스터 주소를 질의한 뒤 곧바로 마스터 인스턴스에 직접 연결된다.
따라서 기존에 마스터와 연결된 클라이언트는 계속해서 기존 마스터에 데이터를 입력하고
새로 연결을 요청하는 클라이언트는 센티널 B, C에 의해 새로 승격된 마스터에 연결을 하게 된다.

![[KakaoTalk_Photo_2025-10-03-13-58-15 003.jpeg|625]]
만약 네트워크 단절이 복구된다면 기존 마스터는 센티널 B, C에 의해 승격된 마스터의 복제본으로 연결된다.
그럼 새로 승격된 마스터의 데이터를 기존 마스터(현재 복제본)에 전달해 데이터 복제를 하는데
단절된 기간동안 기존 마스터에 입력된 데이터는 날아가고 새로 승격된 마스터의 데이터만 남게된다.