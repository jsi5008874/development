
## 레디스에서 데이터를 영구 저장하기
레디스는 인메모리 시스템이기 때문에 레디스 인스턴스 또는 서버가 재시작 될 경우 모든 데이터가 손실된다.

레디스를 복제 구조로 사용할 경우 데이터가 실시간으로 복제본에 전달되고 있어서 데이터 백업이 필요 없다고 느껴질 수 있다.
하지만 백업과 복제는 목적이 다르다는 것을 유의해야 한다.
복제는 가용성을 위한 수단이고 백업은 장애 상황에서 데이터 복구를 위해 필요하다.
만약 개발자의 실수 또는 프로그램상의 버그로 마스터 노드에서 의도하지 않은 데이터 삭제 커맨드가 실행되면 복제본에서도 삭제된다.
이처럼 복제 구조만으로 데이터를 안전하게 유지할 수 없다.

따라서 레디스를 영구 저장소로 사용하려면 디스크에 데이터를 주기적으로 백업하는게 안전하다.

**AOF와 RDB 방식**
AOF(append only file) : 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록
				    복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성

ROB(Redis DataBase) : 일정 시점에 메모리에 저장된 데이터 전체를 저장

```
SET key1 a
OK

SET key1 apple
OK

SET key2 b
OK

DEL key2
(integer) 1

>> key1에 a를 저장 > key1에 apple로 수정 > key2에 b를 저장 > del로 key2 삭제
```
![[KakaoTalk_Photo_2025-09-24-12-17-55.jpeg|675]]
해당 그림의 위의 예시에서 AOF와 RDB 방식에서 어떻게 저장되는지 보여준다.

실제로 RDB 파일은 바이너리 형식으로 저장되어 우리가 읽을 수 없는 형태이며 AOF 파일은 레디스 프로토콜 형태로 저장

AOF 파일에는 레디스에서 실행된 모든 쓰기 작업이 기록
key1의 데이터가 변경된 내역, key2가 생성됐다가 삭제된 내역 모두 기록된다.

RDB는 스냅샷 방식으로 저장되는 시점의 메모리 데이터가 그대로 저장된다.

**AOF와 RDB의 장단점**
AOF는 파일의 크기가 크고 주기적으로 압축해야하지만 원하는 시점으로 복구할 수 있다.

RDB는 시점 단위로 여러 백업본을 저장할 수 있고 AOF 보다 복원이 빠르지만 특정 시점으로 복구는 불가능하다.


하나의 인스턴스에서 RDB와 AOF 옵션을 동시에 사용하는 것도 가능하며 데이터 안정성을 원하는 경우 두 가지 백업 방식을 동시에 사용하는 것을 권장
레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때뿐이며 레디스 인스턴스의 실행 도중에 데이터 파일을 읽어올 수 없다.

레디스 서버는 재시작 될 때 AOF 파일이나 RDB 파일이 존재하는지 확인한 뒤 존재하면 파일을 로드한다.
RDB, AOF 파일 모두 존재한다면 AOF의 내구성이 더 보장된다고 판단하여 AOF를 로드한다.


## RDB 방식의 데이터 백업
RDB는 스냅샷 형식으로 저장하기 때문에 백업에 적합한 파일 형태라 볼 수 있다.
하지만 장애가 발생했을 때 손실 가능성을 최소화해야 하는 서비스에는 적합하지 않다.
사용자가 지정한 시간 단위로 파일을 저장하기 때문에 저장 시점부터 장애가 발생한 시점까지 데이터는 손실 될 가능성이 있기 때문이다.

RDB 파일을 생성할 수 있는 방법은 크게 세 가지다.
설정 파일에서 특정 조건에 파일이 자동으로 저장되도록 지정할 수 있으며 사용자가 원하는 시점에 커맨드를 이용해 수동으로 생성할 수도 있다.
복제 기능을 사용하면 레디스는 자동으로 RDB 파일을 생성한다.

### 특정 조건에 자동으로 RDB 파일 생성
```
redis.conf(레디스 설정파일) RDB 옵션

save <기간(초)> <기간 내 변경된 키의 개수>
>> 일정한 기간동안 변경된 키의 개수가 조건에 맞을 때 자동으로 RDB 파일 생성

dbfilename <RDB 파일 이름>
>> 해당 옵션에 지정된 이름으로 파일 생성, 기본값은 dump.rdb

dir <RDB 파일이 저장될 경로>
>> 지정한 경오레 저장

ex)
save 900 1
>> 900초 동안 1개 이상의 키가 변경된 경우 RDB 파일 저장
```

만약 RDB 파일을 저장하고 싶지 않다면 save "" 와 같이 빈 문자열로 설정해서 비활성화할 수 있다.
레디스 인스턴스가 실행 중인 상태에서 비활성화 하고 싶다면 CONFIG SET 커맨드를 이용해 비활성화 할 수 있다.
```
CONFIG SET save ""
>> 재설정

CONFIG REWRITE
OK
>> 인스턴스가 실행중일 때는 REWRITE 커맨드를 실행해서 변경된 설정이 적용되도록 해야한다. 
```

### 수동으로 RDB 파일 생성
SAVE, BGSAVE 커맨드를 이용하면 원하는 시점에 직접 RDB 파일을 생성할 수 있다.

SAVE는 동기 방식으로 파일을 저장한다.
SAVE 커맨드를 실행하면 파일 생성이 완료될 때 까지 다른 모든 클라이언트의 명령을 차단한다.
일반적인 운영환경에서는 되도록 사용하지 않는다.

BGSAVE는 fork를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성 후 종료된다.
만약 이미 백그라운드로 데이터가 저장되고 있었다면 이 커맨드를 수행할 때 에러를 반환한다.
이런 상황에서 BGSAVE와 SCHEDULE 옵션을 함께 사용하면 레디스는 일단 OK를 반환한 후 기존 백업 작업이 완료된 후 다시 BGSAVE를 실행한다.

RDB 파일이 정상적으로 저장됐는지는 LASTSAVE 커맨드로 확인할 수 있다.
마지막으로 저장된 RDB 파일이 저장된 시점을 유닉스 타임스탬프로 반환한다.

### 복제를 사용할 경우 자동으로 RDB 파일 생성
복제본에서 REPLICAOF 커맨드를 이용해 복제를 요청하면 마스터 노드에서는 RDB 파일을 새로 생성해 복제본에 전달한다.
또는 이미 복제 연결이 돼 있는 상태에서 네트워크 등의 이슈로 일정 시간 이상 복제가 끊어졌다가 복구된 상황에서는
마스터 노드가 복제본으로 RDB 파일을 전송한다.

따라서 복제 연결을 처음 시작할 때 뿐만 아니라 이미 복제 연결이 돼 있는 상태에서도 마스터에서는 언제든지 RDB 파일을 재생성할 수 있다.


## AOF 방식의 데이터 백업
```
redis.conf(레디스 설정파일)에서 AOF 옵션

appendonly yes
>> AOF 사용여부
appendfilename "appendonly.aof"
>> aof 파일 이름
appenddirname "appendonlydir"
>> aof 저장 폴더 이름, dir 옵션 하위에 폴더 생성됨
```

AOF 파일의 저장 방식
```
SET key1 apple
OK

DEL key1
(integer) 1

DEL non_existing_key
(integer) 0

1, 2번 커맨드는 생성, 삭제로 데이터 변경이 일어난 커맨드이고 3번 커맨드는 존재하지 않는 키를 삭제한 것으로 변경이 일어나지 않은 커맨드다.
AOF는 메모리상 데이터가 변경된 커맨드만 기록되기 때문에 1, 2번 커맨드만 기록되고 3번은 기록되지 않는다.
```

AOF에서 모든 커맨드의 실행 내역은 레디스 프로토콜(RESP) 형식으로 저장된다.
```
*3
$3
Set
$4
key1
$5
apple
.....
*2
$3
del
$4
key1
```
하지만 항상 AOF 파일이 사용자가 실행한 커맨드를 그대로 저장하는 것은 아니다.
list에서 블로킹 기능을 지원하는 BRPOP 커맨드는 AOF 파일에 저장될 때에는 RPOP으로 기록된다.
AOF 파일에서 블로킹 기능(리스트가 비어있으면 대기하는 기능)을 굳이 명시해줄 필요는 없기 때문이다.

기존 string 값에 사용자가 입력한 부동소수점 값을 더해주는 INCRBYFLOT 커맨드도 AOF 파일에서 그대로 기록되지 않는다.
레디스가 실행되는 아키텍처에 따라 부동소수점을 처리하는 방식이 다를 수 있기 때문에 AOF 파일에는 증분 후의 값을 직접 SET 하는 커맨드로 변경돼 저장된다.
```
INCRBYFLOT counter 50
"150"

AOF 파일 저장 방식
*4
$3
SET
$7
counter
$3
150
$7
KEEPTTL
>> 이렇게 INCRBYFLOT 커맨드가 기록되는게 아니라 SET 하는 방식
```

AOF는 실행되는 커맨드가 파일의 뒤쪽에 계속 추가되는 방식으로 작동한다.
따라서 인스턴스가 실행되는 시간에 비례해서 AOF 파일 크기는 계속 증가한다.
### AOF 파일을 재구성 하는 방법
AOF 파일을 이용한 백업 기능을 안정적으로 사용하려면 점점 커지는 파일을 주기적으로 압축시키는 재구성(Rewrite) 작업이 필요하다.
RDB와 마찬가지로 특정 조건에 자동으로 재구성되도록 설정할 수 있으며 사용자가 원하는 시점에 커맨드를 이용해 재구성할 수 있다.

재구성은 기존 디스크에 저장된 AOF 파일을 사용하는 것이 아니라 레디스 메모리에 있는 데이터를 읽어와 새로운 파일로 저장하는 형태로 동작한다.
설정 파일에서 기본 옵션인 aof-use-rdb-preamble yes를 no로 변경하지 않는다면 데이터는 RDB 파일 형태로 저장한다.
![[KakaoTalk_Photo_2025-09-24-14-20-56 001.jpeg|675]]
버전 7 이전까지 AOF는 하나의 파일로 관리 됐다.
AOF 파일의 앞부분은 메모리 데이터를 읽어와 바이너리 형태로 저장한 RDB 파일이 위치하고 이후 레디스 메모리를 변경한 커맨드 로그들은 RESP 형태로
RDB 파일의 뒤에 쌓이는 형태로 증가한다.

![[KakaoTalk_Photo_2025-09-24-14-20-56 002.jpeg|675]]
7 버전 이후 AOF 재구성
1. 레디스는 fork()를 이용해 자식 프로세스를 생성, 자식 프로세스는 레디스의 메모리를 읽어와 신규로 생성한 임시파일에 저장
2. 백그라운드로 1번이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 기존의 AOF 파일과 인메모리 버퍼에 동시에 저장
3. 1번의 AOF 재구성이 끝나면 인메모리 버퍼에 저장된 내용을 1번의 임시 파일 마지막에 추가
4. 생성된 임시 파일로 기존 AOF 파일 덮어 쓰기

![[KakaoTalk_Photo_2025-09-24-14-26-57.jpeg|675]]
버전 7 이후에서 AOF는 기본이 되는 바이너리 형태의 RDB 파일, 증가하는 RESP의 텍승트 형태의 AOF 파일로 나눠서 데이터를 관리한다.
또한 현재 레디스가 바라보고 있는 파일이 어떤 것이지 나타내는 매니페스트 파일을 추가적으로 도입했으며
매니패스트 파일은 RDB와 AOF 파일이 어떤것인지 알려주는 역할을 한다.
세 파일은 모두  설정 파일에 지정한 appenddirname 이름의 폴더 내에 저장된다.

AOF가 재구성될 때마다 AOF를 구성하고 있는 각 RDB와 AOF의 파일명의 번호, 매니페스트 파일 내부의 seq 값도 1씩 증가한다.

![[KakaoTalk_Photo_2025-09-24-14-30-23.jpeg|675]]
1. 레디스 인스턴스는 fork를 통해 자식 프로세스를 생성하고 자식 프로세스는 데이터를 읽어와 신규로 생성한 임시 파일에 저장
2. 백그라운드로 1번이 진행되는 동안 데이터가 변경된 내역은 신규 AOF 파일에 저장
3. 1번의 재구성이 끝나면 임시 매니페스트 파일 생성한 뒤 변경된 버전으로 매니페스트 파일 내용을 업데이트
4. 생성된 임시 매니페스트 파일로 기존 매니페스트 파일 덮어 씌운 뒤 이전 버전의 AOF, RDB 파일 삭제

기존 버전의 2, 3단계의 비효율을 줄일 수 있어 훨씬 간단한 과정으로 데이터를 저장할 수 있다.
(기존 AOF 파일, 인메모리 버퍼 이중 저장 문제 해결)

앞서 aof-use-preamble 옵션에 의해 압축되는 데이터 파일은 RDB 형태로 저장된다고 언급했다.
이를 no로 변경한다면 베이스 파일은 .base.rdb 형태가 아닌 .base.aof 형태로 저장되며 RESP 프로토콜 형태의 텍스트로 변경된다.

레디스에서 AOF 파일의 재구성 과정은 모두 순차 입출력(sequential I/O)만 사용하기 때문에 디스크에 접근하는 모든 과정이 효울적이다.
레디스 서버는 복원 시 순차적으로 데이터를 로드하는 용도로만 AOF 파일을 사용한다.
파일 내에서 직접 데이터를 검색할 필요가 없기 때문에 랜덤 입출력을 고려할 이유가 전혀 없다.

### 자동 AOF 재구성
```
auto-aof-rewrite-percentage 100
>> AOF 파일을 다시 쓰기위한 시점을 정하기 위한 옵션
>> 마지막으로 재구성됐던 AOF 파일의 크기와 비교해 현재 AOF 파일이 지정된 퍼센트만큼 커졌을 때 재구성을 시도

auto-aof-rewrite-min-size 64mb
>> 재구성된 이후의 AOF 파일의 최소 크기
```
마지막으로 저장된 AOF 파일의 크기는 레디스에서 INFO PERSISTENCE 커맨드로 확인할 수 있는 aof_base_size 값이다.

```
INFO Persistence
...
aof_current_size:186830
aof_base_size:145802
>> auto-aof-rewrite-percentage가 100이라면 aof_current_size가 aof_base_size의 100%만큼 커진 291604가 되면 재구성을 시도한다.
```
데이터가 아무것도 없는 상태로 인스턴스가 처음 부팅됐을 떄의 aof_base_size는 0이므로
이럴 때에는 auto-aof-rewrite_min_size를 기준으로 데이터를 재구성한다.

사용자가 데이터를 생성하고 삭제하는 작업을 반복했다고 가정
실제로 재구성을 시도해 새로 저장된 RDB 파일의 크기, 즉 aof_base_size가 1KB로 줄어드는 경우가 발생할 수 있다.
이 경우 aof_current_size가 1KB의 100%에 도달할 때마다 재구성을 시도해야하는 발생할 수 있으며 이는 비효율적인 작업을 트리거 할 수 있다.
따라서 마지막으로 작성된 AOF 파일 크기를 기준으로 재구성하되 적어도 AOF 파일이 특정 크기 이상일 때에만 재구성 하도록 지정할 수 있다.
(예시에서는 64MB 이상일 때만 재구성 가능하도록 설정했기 때문에 비효율적인 작업이 실행되지 않도록 막아준다는 뜻)

### 수동 AOF 재구성
BGREWRITEAOF 커맨드를 이용하면 직접 AOF 파일을 재구성 가능

### AOF 타임스탬프
버전 7 이상부터는 AOF를 저장할 때 타임스탬프를 남길 수 있다.
```
aof-timestamp-enabled no
>> 설정 파일에서 해당 옵셥을 활성화 시키면 AOF 데이터가 저장될 때 타임스탬프도 함께 저장된다.
```
이를 이용하면 수동으로 AOF 파일을 조작하지 않아도 시스템상에서 시점 복원이 가능하다.

레디스에서 제공하는 redis-check-aof 프로그램을 사용해 특정 시점 이후의 데이터를 모두 복원할 수 있다.
```
src/redis-check-aof --truncate-to-timestamp 1669532844 appendonlydir/appendonly.aof.manifast

truncate-to-timestamp 옵션을 사용해 AOF 파일을 복구하면 원본 파일이 변경된다.
작업을 수행하기 이전의 AOF 파일을 보호하고 싶다면 위의 옵션을 사용하기 전에 원본 파일을 미리 다른 곳으로 복사해야한다.
```
타임스탬프 기능은 버전 7 이후부터 지원되며 이 옵션을 켜서 저장한 AOF 파일은 이전 버전의 레디스와 호환되지 않는다.

### AOF 파일 복원
시점 복원에서 사용한 redis-check-aof 프로그램은 AOF 파일이 손상됐을 때에도 사용할 수 있다.

레디스가 의도치 않은 장애로 중단됐을 때 redis-check-aof 프로그램을 사용하면 AOF 파일의 상태가 정상적인지 확인할 수 있다.
```
src/redis-check-aof appendonlydir/appendonly.aof.manifast
Start checking Multi part AOF
......
[offset 169912] RDB looks OK!
......
AOF appendonly.aof.15.incr.aof is not valid. Use the --fix option to try fixing it.
>> aof 파일이 정상적이지 않다는 뜻
```
해당 예시는 RDB 파일은 정상이지만 AOF 파일이 비정상이라 실행이 불가능하며 fix 옵션으로 해결하라는 문구가 나왔다.

```
src/redis-check-aof --fix appendonlydir/appendonly.aof.manifast
.....
Successfullt truncated AOF appendonly.aof.15.incr.aof
All AOF files and manifest are valid
>> fix 옵션을 통해 복구
```
fix 옵션 또한 원본 파일을 변경하기 때문에 이전 데이터를 보호하고 싶다면 다른 곳에 복사해야 한다.

### AOF 파일의 안전성
운영체제에서 시스템 콜을 이용해 데이터를 파일에 저장하는 방법
![[KakaoTalk_Photo_2025-09-24-15-34-58.jpeg|650]]
운영체제에서 애플리케이션이 파일에 데이터를 저장하고자 할 때 곧바로 디스크에 저장되지 않는다.
WRITE라는 시스템 콜을 이용해 애플리케이션이 파일에 데이터를 저장하겠다 하면 데이터는 커널 영역의 OS 버퍼에 임시로 저장한다.
운영체제가 판단하기에 커널이 여유가 있거나 최대 지연 시간인 30초에 도달하면 커널 버퍼의 데이터를 실제로 디스크에 내려 쓴다.

FSYNC는 커널의 OS 버퍼에 저장된 내용을 실제로 디스크에 내리도록 강제하는 시스템 콜이다.
OS에 부하가 있더라도 FSYNC가 호출되면 데이터는 무조건 디스크에 플러시된다.

레디스에서 AOF 파일을 저장할 때 APPENFSYNC 옵션을 이용하면 FSYNC 호출을 제어할 수 있다.
```
APPENDFSYNC no : AOF 데이터를 저잘할 때  WRITE 시스템 콜을 호출한다.
				데이터는 커널 영역에 데이터가 잘 저장되는지만 확인하기 때문에 쓰기 성능이 가장 빠르다.

APPENFDSYNC always : AOF 데이터를 저장할 때 항상 WRITE와 FSYNC 시스템 콜을 함께 호출한다.
					매번 쓰고자 하는 데이터가 파일에 정확하게 저장되는지 기다리기 때문에 쓰기 성능은 가장 느리다.

APPENDFSYNC everysec : 데이터를 저장할 때 WRITE 시스템 콜을 호출하며 1초에 한번 씩 FSYNC 시스템 콜을 호출한다.
					성능은 no 옵션과 거의 비슷하다.
```
기본 옵션은 everysec로 서버에 장애가 발생했을 때 유실될 수 있는 데이터는 최대 1초이기 때문에 속오와 안정성의 균형을 맞출 수 있는 값이다.
always는 성능이 느려지고 no로 설정할 경우 최대 30초 동안 FSYNC가 발생하지 않아 30초 동안의 데이터 유실이 발생할 가능성이 있다.
따라서 everysec을 권장한다.

## 백업을 사용할 때 주의할 점
RDB와 AOF 파일을 사용하는 경우 인스턴스의 maxmemory 값은 실제 서버 메모리보다 여유를 갖고 설정하는 것이 좋다.

BGSAVE 커맨드를 사용하면 fork 해서 자식 프로세스를 생성한다고 했다.
이후에 자식 프로세스는 레디스의 메모리를 그대로 파일에 저장하며 기존의 부모 프로세스는 다른 메모리의 데이터를 이용해 연결을 처리한다.
이때 레디스는 Copy-On-Write(COW) 방식을 이용해 메모리상의 데이터를 하나 더 복사하는 방법을 이용해 백업을 진행하면서도
클라이언트의 요청 사항을 받아 메모리의 데이터를 읽고 수정하는 작업을 진행할 수 있다.

하지만 물리적 메모리에 있는 실제 메모리 페이지가 그대로 복제되기 때문에 최악의 경우 레디스는 기존 메모리 용량의 2배를 사용하게될 수 있다.
이때 레디스의 maxmemory 값을 너무 크게 설정한 경우 레디스의 COW 동작으로 인해 
OS 메모리가 가득 차게되고 OOM(Out Of Memery)로 서버가 다운될 수 있다.

따라서 maxmemory 옵션을 실제 메모리보다 여유를 갖고 설정하는 것이 안정적이다.
![[KakaoTalk_Photo_2025-09-24-15-49-03.jpeg|700]]

RDB 스냅샷을 저장하는 도중에는 AOF 재구성을 할 수 없고 AOF 재구성이 진행될 때에는 BGSAVE를 실행할 수 없다.