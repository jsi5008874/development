  

### 인덱스 거는 문법(mysql 기준)

  

![[image 174.png]]

  

CREATE index 인덱스명 ON 테이블명(컬럼명); >> 일반 인덱스

CREATE UNIQUE INDEX 인덱스명 ON 테이블명(컬럼명, 컬럼명) >> 유니크하게 식별되는 인덱스

>> 프라이머리 키 처럼 유니크하게 식별할 수 있는것을 뜻한다.

  

### 테이블 생성시 인덱스 거는 문법

![[image 175.png]]

테이블 생성시에 인덱스를 같이 생성하면 된다.

  

### 인덱스 정보를 보는 법

![[image 176.png]]

SHOW INDEX FROM 테이블명;

  

해당 테이블의 인덱스 정보를 보여준다.

Non_unique : 0이면 유니크 인덱스, 1이면 논유니크 인덱스

seq_in_index : 인덱스에 포함되는 컬럼의 갯수를 보여줌

(여기서는 team_id_backnumber_idx가 2개 있고 나머지는 1개만 있음)

column_name : 해당 인덱스에 해당하는 컬럼명을 보여줌

  

### B Tree 기반 인덱스의 동작 방식

  

![[image 177.png]]

기본적으로 index는 오름차순 **정렬이 되어있고 Binary search 형식으로 작동**한다.

우선 index가 a에 걸려있기 때문에 a를 기준으로 BS를 한다.

1. index표 상 5가 중간 값이기 때문에 5를 기준으로 7이 더 크기 때문에 5보다 낮은 값은 배제
2. 그다음 중간 값이 현재 초록색으로 보이는 7중 마지막 7이 중간값이기 때문에 마지막 7을 기준으로 BS를 다시 시작한다.
3. 7은 a=7이라는 조건과 맞기 때문에 우선 킵해두고 마지막 7외에 다른 7이 있을 수 있기 때문에 BS를 이어서한다.
4. 마지막 7 이후의 값은 9이기 때문에 9를 포함하여 9 이후의 모든 값은 배제
5. 마지막 7보다 앞에 있는 숫자들을 search하는데 모두 7이기 때문에 모두 테이블로 이동해서

b=95인지 하나하나 확인(full scan)

1. 그 결과 두 번째 7이 조건과 맞는 row인것을 알 수 있다.

  

해당 예제는 결국 index를 통해 성능이 좋아졌더라도 결국 찾은 index 안에서 **full scan을 해야한다.**

이걸 피하려면 **복합 인덱스를 설정**하면 된다.

### 복합인덱스 동작 방식

![[image 178.png]]

우선 복합 인덱스의 정렬방식은 인덱스 중 먼저 선언된 키를 정렬하고 그 다음 키를 정렬한다.

7을 예로 들면 a가 정렬이 되어있는 상태이고 같은 7이더라도 b가 78인 row부터 정렬되어있다.

  

1. 동일하게 a를 기준으로 BS를 진행
2. a=7, b=95인 값을 찾았지만 동일한 값이 있을 수 있기 때문에 계속 BS 진행
3. 하지만 두 번째 7을 보면 a=7, b=80이므로 더 이상 진행해봤자 b가 80보다 같거나 작기 때문에 BS를 진행하지 않고 끝나게 된다.

  

즉 복합인덱스를 사용하면 처음 예제와 다르게 Full Scan을 하지 않아도 된다.

  

![[image 179.png]]

이렇게 b=95 조건만 있다면 오히려 복합인덱스를 사용하지 않는 것이 좋다.

위 의 그림에 나와있듯이 b만 놓고 보면 정렬이 되어 있지 않아 Full Scan과 별 차이가 없다.

  

### 쿼리가 어떤 인덱스를 쓰는지 확인하는 방법

  

![[image 180.png]]

EXPLAIN 문구를 통해 쿼리 실행계획을 볼 수 있는데

여기서 사용할 index를 보여준다.

해당 실행 계획은 옵티마이저가 자동으로 지정해서 사용하는 것이지만

  

내가 인덱스를 직접 고르고 싶다면 밑의 키워드를 사용한다.

![[image 181.png]]

USE >> 권장사항 느낌

FORCE >> 무조건 써야한다 느낌

IGNORE >> 해당 인덱스는 쓰지 말라는 문구

  

### Index를 막 만들어도 괜찮을까?

![[image 182.png]]

인덱스는 정렬을 하기 때문에 write(insert, update, delete)할 때 마다 재배치를 해야 한다.

즉 인덱스가 많으면 그만큼 **오버헤드 발생**

  

그리고 index 또한 index를 위한 데이터가 존재해서 **추가적인 저장 공간이 필요**하기 때문에

막 만들면 좋지 않다.

  

### Covering Index

![[image 183.png]]

위 그림처럼 조회하려는 attribute가 index에 모두 포함되어 있을 때

즉 index만으로 쿼리문이 커버가 될 때를 말한다.

이렇게 되면 굳이 테이블로 가서 조회를 해볼 필요 없이 인덱스 테이블에서 바로 조회 가능

  

### Hash Index

![[image 184.png]]

시간복잡도가 O(1)이어서 B Tree 인덱스보다 좋은 것 같지만

  

rehashing에 대한 부담 : hash table이 꽉 차면 테이블 사이즈를 늘려주는 작업을 해줘야하는데

이 작업이 리소스를 많이 잡아먹는 부담스러운 작업이다.

equality 비교만 가능 range 비교 불가능 : = 만 가능하고 <, > 범위 비교는 불가능하다.

복합 인덱스는 전체 attributes에 대한 조회만 가능 : B tree는 index(a, b)라면 a만 키로 지정해도

활용가능하지만 hash index는 a, b 모두 사용해야

활용 가능하다.

  

### Full Scan이 더 좋은 경우

![[image 185.png]]

조회하려는 데이터가 테이블의 상당 부분을 차지할 떄

>> 쿼리를 예시로 보면 통신사가 SK인 고객이 70%이상이라면? 굳이 인덱스를 써도 너무 많은 조회를 해야하기 때문에 의미가 없다.

  

  

  

  

![[image 186.png]]


**출처 : 유튜브 쉬운코드 https://www.youtube.com/@ezcd