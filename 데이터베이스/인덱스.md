  

### **추가적인 저장 공간을 사용해서 테이블 검색 속도를 향상**시키기 위한 자료구조  
  

###   
인덱스를 사용하는 이유  

**인덱스는 실제 테이블의 데이터 크기에 비해 굉장히 작다**. 따라서 인덱스는 실제 데이터베이스 테이블에 비해 메모리에 적재하기 쉽다. 메모리(RAM)에 최대 1gb를 적재할 수 있고, 하드디스크에 100gb의 데이터베이스가 존재한다고 가정하자.

만약 우리가 찾고자 하는 데이터가 데이터베이스의 맨 끝에 있다면, 100gb의 데이터를 모두 탐색한 끝에야 원하는 데이터를 얻을 수 있다. 하지만, 우리에게 주어진 메모리는 1gb이므로 100gb의 데이터를 100개로 나눈뒤, 100번 꺼내와야한다.

  

하지만 인덱스를 사용한다면 인덱스만 메모리에 적재하고 원하는 데이터의 물리적 주소를 찾아

접근을 한다.

  

**즉, 데이터 I/O를 줄여 데이터 탐색 성능을 향상**

  

### 인덱스 알고리즘

  

**해시 테이블**

데이터의 Key를 알고 있으면, 데이터에 _O_(1)의 시간 복잡도로 접근할 수 있다. 언뜻 보면 데이터베이스에 적합한 자료구조인 것 같다.

  

하지만 실제로 RDB에서는 해시 테이블을 사용하지 않는다.

이유는 우선 해시 테이블은 정렬이 되어있지 않고 부등호 연산에 부적합하기 때문이다.

  

**B-Tree**

![[image 151.png]]

자식 노드가 2개 이상인 트리

**노드의 개수를 늘리고 트리의 전체 높이를 줄여서 빠른 탐색 속도**를 얻을 수 있다. 

최대 M개의 자식을 가질 수 있는 B-Tree를 M차 B-Tree라고 한다.

  

B-Tree의 특징

1. 리프 노드가 모두 같은 레벨을 가진다.
2. 한 노드가 여러 데이터를 가질 수 있다.

노드 내의 데이터를 key라고 부르고 노드 내부의 key들은 항상 오름차순 정렬

노드 기준 좌, 우로 가리키는 포인터가 존재(좌는 작은 값, 우는 큰 값)

1. 노드의 각 키는 실제 데이터의 물리적 위치를 가리키고 있는 데이터 포인터를 가짐

키를 기준으로 데이터를 탐색한 뒤 일치하는 키 발견 시 데이터 포인터가 가리키는 곳으로 이동

1. 조회는 빠르지만 수정, 삭제, 제거는 느리다.

  

**B+Tree**

![[image 152.png]]

오직 리프 노드의 키만 데이터 포인터를 가지고 있는 구조

  

B-Tree와 다르게 리프 노드에만 데이터 포인터가 존재해서 **내부노드에 더 많은 키를 보관**할 수 있게 된다.

>> 이 말은 B-Tree와 달리 내부 노드에는 데이터 포인터가 없고 자식 노드를 가르키는 포인터만 있어서 같은 용량이라면 더 많은 리프 노드를 가질 수 있다는 뜻이다.

  

이는 곧 **트리의 높이가 낮아**지는 것을 의미하고, **탐색 속도가 B-Tree에 비해 더 향상**됨을 의미

  

또한 중복된 값을 가질 수 있다.

  

B+Tree의 특징

1. 순차 검색에 유리하다.

B+Tree는 리프 노드를 연결 리스트로 연결해서 정렬 상태의 리프 노드를 순차검색 가능

반면 B-Tree는 부등호 연산 시 트리 순회를 해야해서 오래 걸림

(리프노드에 원하는 값이 없으면 부모 노드로 올라갔다가 다른 자식 노드로 순회 하는 방식)


[[Clustered Index, Non-Clustered Index]]



**출처 : https://hudi.blog/