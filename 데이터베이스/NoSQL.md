  

### RDB의 단점

1. 경직된 스키마

![[image 209.png]]

유연한 확장성이 부족하다.

그림의 예시처럼 5천만 개의 row를 가진 테이블에 새로운 컬럼을 추가해야할 때

DB에 엄청난 무리가 생기게 된다.

이처럼 유연하게 스키마를 확장하는게 어렵다

  

2 join과 성능하락

복잡한 join은 read의 성능 하락을 가져온다

복잡한 join을 가진 쿼리문은 DB서버의 CPU 사용량이 늘어나고 시간도 오래 걸린다.

  

1. Scale-out 편하지 않음

  

DB 서버에 과도한 트래픽이 들어오면 트래픽을 처리하기 위한 여러 방법이 있는데

그 방법 중 하나가 scale up

![[image 210.png]]

scale up : DB 서버의 하드웨어 자원을 업그레이드 하는 것(CPU, Memory 등)

  

  

![[image 211.png]]

scale out : replication, shading 등 여러 개의 서버를 복사해서 부하 분산하는 방법

하지만 RDB가 Scale-out 방식에 유연한 DB는 아니다.

  

1. ACID가 성능에 영향을 미침

![[image 212.png]]

  

  

### NoSQL 등장 배경

  

![[image 213.png]]

인터넷이 보급이 되기 시작하고 수많은 사용자가 생기게 되었다.

그리고 SNS의 보급이 시작되면서 글로벌 서비스들이 생기기 시작했고

그 전과 다른 엄청난 양의 트래픽을 처리해야했다.

  

대량의 트래픽을 처리하기 위해서 기존과 다른 요구사항이 생기게 되었다.

**high-throughput이 요구됨 : 높은 처리량이 요구**

**low-latency 요구됨 : 빠른 응답시간 요구**

  

또한 다양한 사람들이 다양한 형태의 데이터를 발생시켜서 RDB에서 정의해 놓은

데이터 형태와 다른 **비정형 데이터가 증가**하게 되었다.

  

그래서 탄생한 것이 **NoSQL**이다.

  

### NoSQL의 특징

  

1. **유연한 스키마**

![[image 214.png]]

mongo DB 기준

RDB의 table이 mongo DB에서는 Collection

  

생성할 때도 RDB와 달리 명칭만 넣어서 생성해주면 끝

  

![[image 215.png]]

데이터를 삽입할 때도 정형화된 구조가 없어서 json 형식에 맞춰 넣으면 된다.

  

![[image 216.png]]

데이터 조회 시 원하는 조건을 json 형식으로 find 하면 결과를 내어줌

id는 mongo DB에서 자동으로 생성한 값이다.

이런 조회결과를 RDB에서는 row 또는 tuple이라고 하지만

mongo DB에서는 document라고 한다.

  

![[image 217.png]]

전체 데이터를 가져오고 싶을 때는 find 조건에 {} 빈 json 형식으로 조회

그러면 전체 데이터를 가져온다.

  

하지만 application에서 스키마 관리가 필요하다.

개발자가 해당 스키마에 어떤 데이터가 들어가야하는지 신경써서 개발을 해야한다.

RDB에서는 형식이 맞지 않으면 자동으로 관리해줬지만

NoSQL은 형식이 맞지 않아도 입력 출력 모두 되기 때문에

개발자가 application level에서 스키마 관리를 해야한다.

  

1. **중복 허용(join 회피)**

![[image 218.png]]

order 컬렉션을 조회한 결과를 보면

RDB 관점에서는 Product 테이블, User 테이블로 나눠서 관리를 해야 하는 구조이다.

하지만 NoSQL은 중복을 허용하기 때문에 한번에 저장을 해서 나중에 조회를 할 때

Join을 할 필요가 없도록 만들어서 성능이 더 향상되었다.

  

하지만 이런 데이터 들이 최신성을 유지할 수 있도록 application level에서 관리를 해야한다.

  

1. **Scale-out에 최적화**

서버 여러 대를 하나의 클러스터에 구성해서 사용

>> 만약 100개의 데이터를 5대 서버로 나눠서 하나의 클러스터에 구성한다면

1번 서버: 1~20번 데이터, 2번 서버 : 21~40번 데이터 ….. 5번 서버 : 81~100번 데이터

이런식으로 한대의 서버가 가진 데이터를 여러 서버가 나눠서 한 대의 서버처럼 동작하는 것

  

만약 RDB를 하나의 클러스터에 나누게 되면 join에서 문제가 생긴다.

1번 서버에서 1번 테이블과 2번 서버의 3번 테이블을 조인해야하는 상황이 온다면?

내부적으로 엄청난 리소스를 잡아먹게 된다.

하지만 NoSQL은 join을 할 필요가 없어서 scale-out에 최적화 되어있는 구조이다.

  

1. **ACID 일부를 포기하고 high-throughput, low-latency 추구**

하지만 금융 시스템처럼 consistency(일관성)가 중요한 환경에서는 사용하기 조심스러움




**출처 : 유튜브 쉬운코드 https://www.youtube.com/@ezcd