---
~
---
## SQL 파싱과 최적화

### 구조적, 집합적, 선언적 질의 언어
SQL은 원하는 결과 집합을 구조적, 집합적으로 선언하지만 그 결과집합을 만드는 과정은 절차적일 수 밖에 없다.
결과집합을 만들기 위해서는 프로시저가 필요한데 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 옵티마이저다.

사용자가 SQL을 DBMS에게 던지면 옵티마이저가 내부적으로 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만든다.
이런 과정을 SQL 최적화라고 한다.

### SQL 최적화
#### SQL 파싱
SQL을 받으면 SQL 파서가 파싱을 진행
- 파싱 트리 생성 : SQL을 구성하는 구성요소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 요류 확인 > 키워드 체크/누락된 키워드 확인 등
- Semantic 체크 : 의미상 오류 확인 > 테이블/컬럼 존재 여부, 오브젝트 권한 확인 등
#### SQL 최적화
옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 실행경로 생성 > 가장 효율적인 하나를 선택

#### 로우 소스 생성
옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포매팅
로우 소스 생성기가 담당

### SQL 옵티마이저
사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 데이터 액세스 경로를 선택해주는 DBMS 엔진

#### 옵티마이저 최적화 단계
1. 쿼리를 수행하는 데 후보군이 될만한 실행 계획 찾기
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계 정보를 활용해 실행 계획의 예상비용 산정
3. 최저 비용을 나타내는 실행계획 선택

```
data dictionary란?
DBMS 내의 모든 객체와 구조에 대한 메타데이터를 저장하는 중앙 저장소

테이블 정보, 컬럼 정보, 인덱스 정보 등 여러 메타 데이터를 저장하지만
오브젝트 통계, 시스템 통계 등 통계정보도 저장하여 옵티마이저에서 활용한다.

오브젝트 통계 : 테이블의 블록 수, 칼럼의 고유값 개수, 인덱스 깊이, 리프 블록 수 등
시스템 통계 : CPU 속도, I/O 성능 등
```

### 실행계획과 비용
옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리 구조로 표현한 것
SQL 실행 절차 미리보기 같은 느낌

실행계획을 통해 SQL이 Full Scan을 하는지 인덱스 스캔을 하는지, 인덱스 스캔이면 어떤 인덱스로 하는지 등
SQL이 실행될 때 어떤 방식으로 실행되는지 상세히 나온다.

여러 실행계획 중 하나를 선택하는데 주된 근거는 비용이다.
```
---------------------------------------------------------------------------------
| Id  | Operation                   | Name    | Rows | Bytes | Cost (%CPU)| Time |
---------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |         | 2000 | 80000 |    15   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| USERS   | 2000 | 80000 |    15   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_AGE | 2000 |       |     5   (0)| 00:00:01 |
---------------------------------------------------------------------------------
```
cost가 비용인데 이는 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한다.

즉 옵티마이저가 제일 비용이 적게 드는 실행계획을 선택해서 실행하는 것이다.
이는 어디까지나 예상치일 뿐이고 실제로는 차이가 날 수 있다.

### 옵티마이저 힌트
옵티마이저는 대부분 좋은 선택을 하지만 완벽하진 않다.
이를 극복하기 위해 개발자가 직접 더 효율적인 액세스 경로를 알고 있을 경우 데이터 액세스 경로를 바꿀 수 있다.
```sql
SELECT /*+INDEX(A 고객_PK)*/
	고객명, 연락처, 주소
	FROM 고객 A
	WHERE rhrir ID = '00008'
>> 이처럼 주석기호에 '+'를 붙이면 된다.
```

하지만 몇 가지 주의사항이 있다.
```sql
1. ,(콤마)는 힌트와 힌트 사이에는 사용하면 안되고 힌트 안의 인자를 나열할 때만 사용
   /*+ INDEX(A A_X01) INDEX(B, B_X03)*/ >> 유효
   /*+ INDEX(A), INDEX(B)*/ >> 불가능

2. 테이블을 지정할 때 스키마명까지 명시하면 안된다.
   /*+ FULL(SCOTT.EMP)*/ >> 무효

3. FROM 절 테이블명 옆에 ALIAS를 명시했다면 힌트에도 반드시 ALIAS 사용
   /*+ FULL(EMP)*/ >> 무효
   FROM EMP E
```

힌트의 종류는 많으며 p.27을 보면 확인 가능


## SQL 공유 및 재사용

### 소프트 파싱 vs 하드 파싱
#### 라이브러리 캐시
SQL 파싱, SQL 최적화, 로우 소스 생성을 거처 생성한 내부 프로시저를 반복 재사용할 수 있게 캐싱해두는 메모리 공간
라이브러리 캐시는 SGA(System Global Area)의 구성 요소로 SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는
데이터와 제어 구조를 캐싱하는 메모리 공간
즉 라이브러리 캐시는 쿼리문 자체를 캐싱해두는 공간이다.

DBMS는 사용자가 SQL문을 전달하면 SQL 파싱 후 라이브러리 캐시에 해당 SQL이 존재하는지부터 확인한다.
없으면 기존 과정을 실행하고 있다면 라이브러리 캐시에 있는 것을 사용한다.

소프트 파싱 : 라이브러리 캐시에서 바로 실행 단계로 넘어가는 것
하드 파싱 : 라이브러리 캐시에 없어서 최적화 및 로우 소스 생성 단계를 모두 거치는 것

#### 최적화 과정이 하드한 이유
옵티마이저가 SQL을 최적화하는 과정 자체가 아주 무거운 작업이다.
예를 들어 다섯 개의 테이블을 조인한다고 한다면 조인 순서의 경우의 수만 120가지(5!)이다.
그 외에도 조인 방식, 풀스캔/인덱스 스캔 등 고려할 경우의 수가 매우 많다.
요즘 알고리즘과 하드웨어가 발전하면서 빠르게 처리하다 보니 잘 느껴지지 않지만 옵티마이저가 해야하는 연산은 아주 무겁다.
이렇게 최적화 가정이 무거운 작업이기 때문에 라이브러리 캐시를 통해 재활용한다.

### 바인드 변수의 중요성
#### 이름없는 SQL 문제
사용자 정의 함수/프로지서, 트리거 등은 생성할 때부터 이름을 갖는다.
컴파일한 상태로 딕셔너리에 저장되며 실행할 때 라이브러리 캐시에 적재해서 여러 사용자가 공유해서 사용한다.

하지만 SQL은 이름이 따로 없다. 전체 SQL 텍스트가 이름 역할을 한다.
딕셔너리에 저장되지도 않으며 처음 실행할 때 최적화 과정을 거쳐 생성된 내부 프로시저를 라이브러리 캐시에 적재한다.

SQL도 영구저장을 하면 좋겠지만 대부분의 DBMS는 그렇게하지 않는다.
SQL 자체가 이름이기 때문에 텍스트의 작은 부분이라도 수정되면 다른 객체가 탄생하는 구조여서 매우 비효율적이기 때문이다.

#### 공유 가능 sql
```sql
SELECT * FROM emp WHERE empno = 7900;
SELECT * FROM emp WHERE EMPNO = 8000;
select * FROM emp WHERE empno = 8100;
```
이는 의미상 같지만 텍스트가 달라서 각각 최적화를 진행하고 라이브러리 캐시에 별도 공간을 사용한다.

이를 하나의 쿼리로 인식해서 하나의 프로시저를 공유해서 사용하면 어떨까?
```sql
CREATE procedure FindEmpNo (empno in varchar2){...}
```
이처럼 파라미터 Driven 방식으로 작성하는 방법이 있는데 이게 바인드 변수이다.

이렇게 저장해 놓는다면 라이브러리 캐시에는 한 개의 SQL만 발견될 것이다.
```sql
SELECT * FROM EMP WHERE empno = :1
```


## 데이터 저장 구조 및 I/O 메커니즘
### SQL이 느린 이유
SQL이 느린 이유는 디스크 I/O 때문이다.
DBMS의 데이터는 디스크에 저장되어 있고 이를 읽는 과정인 디스크 I/O 동안 프로세스는 대기 상태에 빠진다.
cpu, 메모리의 데이터 처리 속도에 비해 디스크의 데이터 처리 속도가 매우 느리기 때문에 문제가 발생한다.
CPU, 메모리가 연산 및 데이터 처리가 가능한 상태더라도 디스크 I/O를 하는 동안에는 DBMS 프로세스가 대기해야하기 때문에 느린 것이다.

### 데이터베이스 저장 구조
![[Pasted image 20251210200348.png|750]]
테이블 스페이스 : 세그먼트를 담는 콘테이너로 여러 개의 데이터파일로 구성
세그먼트 : 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
익스텐트 : 공간을 확장하는 단위, 테이블이나 인덱스에 데이터 입력 중 공간이 부족하면 오브젝트가 속한 테이블 스페이스에게 익스텐트를 추가로 할당 받음
블록 : 데이터를 읽고 쓰는 가장 작은 단위
로우 or 레코드 : 테이블의 한 행, 블록에 소속 됨

```
# 하나의 테이블 하나를 생성하여 레코드 한 개를 저장한다고 가정
테이블 스페이스 지정
↓
테이블 스페이스에 소속된 세그먼트 할당
↓
1번 익스텐트 할당
↓
1번 블록 할당
↓
1번 블록 내에 레코드 저장
```

익스텐트 내 블록은 인접한 연속된 공간이지만 익스텐트 끼리는 연속된 공간이 아니다.
그 이유는 하나의 테이블 스페이스를 여러 데이터 파일로 구성하면 파일 경합을 줄이기 위해 DBMS가 데이터를 여러 데이터 파일로 분산하기 때문이다.

### 블록 단위 I/O
DBMS는  컬럼 하나만 읽고 싶어도 블록을 통째로 읽는다.
블록이 I/O의 최소 단위이기 때문이다.
이는 테이블 뿐만 아니라 인덱스에도 적용된다.

### 시퀀셜 액세스 vs 랜덤 액세스
#### 시퀀셜 액세스
논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
ex) 테이블 Full Scan

테이블 블록 간에는 서로 논리적인 연결고리가 없지만 차례대로 읽는 것이 가능한 이유는 익스텐트 맵 덕분이다.
세그먼트 헤더에 익스텐트 목록을 맵(map)으로 가지고 있어 각 익스텐트의 첫 번째 블록 주소 값을 알 수 있다.
#### 랜덤 액세스
논리적 또는 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식
ex) index scan

### 논리적 I/O vs 물리적 I/O
#### DB 버퍼 캐시
라이브러리 캐시는 함수/프로시저 등을 캐싱하는 코드캐시를 했었다.
반면 버퍼 캐시는 데이터를 캐싱하는 역할을 한다.(버퍼 캐시도 SGA에 존재함)
디스크에서 어렵게 읽은 데이터 블록을 캐싱해서 같은 블록에 대한 I/O call을 줄이는데 목적이 있다.

SQL 실행 전 디스크 I/O보다 버퍼 캐시를 먼저 확인하고 데이터가 버퍼 캐시에 없으면 디스크 I/O를 실행한다.
```
# 라이브러리 캐시와 버퍼 캐시 확인 시점의 차이
라이브러리 캐시 : SQL 파싱 후 실행 계획이 있는지 확인
버퍼 캐시 : SQL 실행 단계에서 데이터가 있는지 확인

ex) 실행할 SQL이 라이브러리 캐시에도 있고 실행결과 데이터가 버퍼 캐시에도 있는 경우 
유저 (SQL 전송)
  ↓
━━━━━━━━━━━━━━━━━━━━━━━━━
[파싱 단계]
  ↓
라이브러리 캐시 확인
  └─ 있음 → 소프트 파싱 (실행 계획 재사용)
━━━━━━━━━━━━━━━━━━━━━━━━━
[실행 단계]
  ↓
버퍼 캐시 확인
  └─ 있음 → 메모리에서 데이터 읽기
  ↓
데이터 반환
```

#### 논리적 I/O와 물리적 I/O
**논리적 I/O**
논리적 I/O는 SQL을 처리하는 과정에 발생한 총 블록 I/O를 뜻한다.
우선 SQL을 실행하면 I/O가 발생하는데 거의 모든 I/O가 메모리에 있는 버퍼 캐시를 경유하므로 메모리 I/O가 곧 논리적 I/O라고 봐도 무방하다.
(메모리를 경유하지 않는 Direct Path I/O가 있지만 논리적 I/O는 메모리 I/O와 Drirect Path I/O를 합친 개념이다.)

**물리적 I/O**
디스크에서 발생한 총 블록 I/O를 뜻한다.
즉 버퍼 캐시에 없어서 실제로 디스크 I/O를 실행한 경우를 의미한다.

#### 버퍼캐시 히트율
```
BHCR = (캐시에서 곧바로 찾은 블록수 / 총 읽은 블록수) * 100
	 = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100
```
읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율을 뜻함

물리적 I/O가 성능을 결정하지만 실제 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다.
```
물리적 I/O = 논리적 I/O * (100% - BCHR)
```
논리적 I/O는 일정하므로 물리적 I/O는 BCHR에 의해 결정된다.
BCHR은 시스템 상황에 따라 달라지므로  물리적 I/O는 결국 시스템 상황에 의해 결정되는 통제 불가능한 외생변수다.

따라서 SQL 성능을 높이기 위해서는 논리적 I/O를 줄이는 일 뿐이다.
```
# 논리적 I/O가 10,000개이고 BCHR이 70%일 때
물리적 I/O = 3,000개

# 논리적 I/O가 1,000개이고 BCHR이 70%일 때
물리적 I/O = 300개

이렇게 논리적 I/O를 줄이면 물리적 I/O가 줄어서 성능이 향상
```

논리적 I/O를 줄이는 방법은 SQL을 튜닝해서 읽는 총 블록 개수를 줄이면 된다.
논리적 I/O는 항상 일정하게 발생하지만 SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생 변수다.
**논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝이다.**

### Single block I/O vs Multi block I/O
#### Single Block I/O
한 번의 요청에 한 개의 블록을 가져오는 I/O
인덱스를 이용할 때는 기본적으로 인덱스와 테이블 모두 Single Block I/O 방식을 사용

#### Multi Block I/O
한 번의 요청에 여러 개의 블록을 가져오는 I/O
테이블 풀 스캔을 할 때 Multi Block I/O 방식을 사용

### Table Full Scan vs Index Range scan
#### Table Full Scan
테이블 전체를 스캔해서 읽는 방식
테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾음

#### Index Range scan
인덱스에서 일정량을 스캔하면서 얻은 ROWID(테이블 레코드의 디스크 상 주소)로 테이블 레코드를 찾아가는 방식

보통 인덱스를 활용하면 성능이 향상된다고 하지만 그렇지 않은 경우도 있다.
이는 앞서 봤던 시퀀셜 액세스/랜덤 액세스, 싱글 블락 I/O/멀티 블락 I/O의 개념을 보면 알 수 있다.

Table Full Scan은 시퀀셜 액세스와 Multi Block I/O 방식으로 디스크 블록을 읽는다.
한 블록에 속한 모든 레코드를 한 번에 읽어오고 여러 블록을 한 번에 가져온다.
이는 대량을 확인해야하는 Table Full Scan과 어울리는 방식이다.

반면 Index Range Scan은 랜덤 액세스와 Single Block I/O 방식을 사용한다.
한 번에 하나의 레코드를 읽어오고 한 블록만 가져온다.(레코드가 속한 블록만 가져오는 것)
이는 필요한 소수의 정보만 가져올 때 유용한 방식이다.

한번에 대량의 데이터를 찾을 때는 index Range Scan보다 Full Scan이 더 효율적이다.
대량을 찾아야 하는데 한 개의 블록 씩 여러번 왔다갔다 하는것 보다 한번에 여러 블록씩 가져오는것이 더 효율적이기 때문이다.
반면 소량의 데이터를 찾을 때는 전체를 읽는것 보다 정확히 필요한 데이터만 읽어오는 것이 더 효율적이다.

이처럼 상황에 맞게 활용하는 방법을 알아야한다.

### 캐시 탐색 메커니즘
#### 버퍼 캐시 구조
버퍼캐시는 해시 구조로 관리한다.
![[Pasted image 20251210212015.png|700]]
해시함수로 해시 체인을 찾고 버퍼 헤더에 있는 값을 찾아 버퍼 블록으로 이동해서 데이터를 가져온다.
```
해시 함수 실행(Block Header #1을 찾는 경우)
↓
해시 결과 값 = Hash Value #1(첫 번째 해시 체인에 위치한 Block Header라는 뜻)
↓
Hash Value #1 해시 체인으로 이동
↓
찾고 있던 Block Header #1로 이동
↓
Buffer Block 주소값 확인
↓
데이터 획득
```
버퍼 캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고 거기서 얻은 포인터로 버퍼 블록을 액세스하는 방식

#### 메모리 공유자원에 대한 액세스 직렬화
버퍼 캐시는 SGA의 구성요소로 공유자원이다.
만약 하나의 버퍼블록을 두 개 이상의 프로세스가 동시에 접근하려고 할 때 문제가 생길 수 있다.
마치 Lock의 개념처럼 순차적으로 접근하도록 하는 것이 직렬화 메커니즘이다.

프로세스들을 줄을 세워 대기시키는 메커니즘을 래치(Latch)라고 하며 버퍼 캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 있다.
또한 버퍼블록 자체에도 직렬화 메커니즘이 있으며 이를 버퍼 Lock이라고 한다.

래치에 의한 경합이 생겨서 성능이 나빠질 수 있다.
이런 경합을 줄이기 위해서는 SQL 튜닝을 통해 쿼리 일량(논리적 I/O) 자체를 줄여야 한다.
