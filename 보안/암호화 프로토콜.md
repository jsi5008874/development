  

네트워크에서 데이터를 암호화하여 안전하게 통신하는 프로토콜

  

### **SSL (Secure Sockets Layer)**

최초의 암호화 프로토콜

여러 보안 취약점이 존재해서 더 이상 사용되지 않음

오래된 암호화 방식(MD5, SHA-1)으로 취약점이 존재

  

[[SSL의 보안 취약점]]

### **TLS (Transport Layer Security)**

SSL이 개선된 버전(현재 가장 많이 사용)

  

TLS는 TLS 1.0을 초기 버전으로 시작하여 현재 TLS 1.3까지 발전되었다.

SSL에 비해 강력한 암호화 알고리즘을 지원하고 핸드셰이크 과정이 단순화되어 속도가 빠르다.

  

**여러 보안취약점 때문에 1.2 이상을 권장**

  

### TLS 통신 흐름(핸드셰이크 과정, RSA)

1. 클라이언트가 서버에게 TLS 연결 메세지 전송

>> 지원하는 TLS 버전, 사용 가능 알고리즘 목록 등 여러 정보 전송

1. 서버는 응답에 서버가 선택한 알고리즘 및 TLS 버전, 서버의 인증서, 공개키 전송
2. 클라이언트가 서버에서 보낸 인증서 검증

>> 서버의 인증서가 신뢰할 수 있는 기관(CA, Certificate Authority)에서 발급된 것인지 검증

인증서가 유효하지 않으면 연결 중단

1. 클라이언트는 서버의 공개 키를 사용하여 세션 키를 암호화하여 서버에게 전송
2. 서버는 자신의 개인 키를 사용하여 세션 키를 복호화
3. 클라이언트와 서버는 공유 된 세션 키를 이용하여 암호화 통신 진행

  

  

**공개키(Public Key) : 말 그대로 공개된 키로 암호화 할 때만 사용 노출되도 상관없음**

**개인키(Private Key) : 공개키로 암호화된 데이터를 복호화 할 때 사용**

**개인키는 서버만 소유하고 있음**

**세션키(Session Key) : 실제 데이터를 암복호화에 사용하는 대칭키**

  

공개키와 개인키는 핸드셰이크 과정에서 서버와 클라이언트가 공유 할 세션키를 보호하기 위한

역할이고 실제 암호화된 데이터는 **세션키를 이용해 암복호화**를 한다.

세션키는 대칭키로서 암복호화에 모두 사용된다.

  

즉 TLS는 서버와 클라이언트가 공유할 세션키를 안전하게 공유하기 위해 공개키와 개인키를

사용하고 이후에 실제 데이터가 오갈 때는 대칭키인 세션키를 활용

비대칭 > 대칭으로 변환된다.

  

### TLS 키교환 방식

  

**RSA(Rivest Shamir Adleman)**

서버가 고정된 개인 키/ 공개 키를 사용하여 클라이언트와 세션 키 교환

1. 클라이언트가 서버의 **공개 키**(Certificate 포함)를 받음
2. 클라이언트가 **세션 키를 생성**하고 서버의 **공개 키로 암호화**
3. 서버가 자신의 **개인 키로 복호화**하여 세션 키 획득
4. 이후 **세션 키(대칭 키)를 사용하여 데이터 암호화**

  

장점

구조가 간단하고 널리 사용 됨

  

단점

**서버의 개인 키가 유출되면 이전에 암호화된 데이터도 모두 복호화됨**

**>> RSA 방식은 세션마다 세션키는 모두 다르지만 공개키, 개인키가 고정된 값이어서 한번 노출되면**

**모든 세션키가 노출되어 모든 데이터가 복호화 될 수 있음**

연산량이 많아 속도가 느림

  

**ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)**

Diffie-Hellman 키 교환 방식에 타원 곡선 암호(Elliptic Curve Cryptography, ECC)를 적용

  

클라이언트와 서버는 같은 타원 곡선(E)과 기본점(G)을 사용

1. 서버와 클라이언트가 각자 개인키 생성

>>클라이언트는 개인키 a 생성, 서버는 개인키 b 생성

1. 클라이언트와 서버가 공개키 생성

>> 클라이언트는 공개키 Pa = aG를 계산, 서버는 공개키 Pb = bG를 계산

이미 공유된 기본점 G에 각자의 개인키를 활용해 계산

1. 클라이언트와 서버가 공개키 교환
2. 세션 키 계산

>> 클라이언트는 서버의 공개키 Pb를 활용해 자신의 개인키 a와 합해서 세션키 계산

S(세션키) = aPb = a(bG) = abG

서버도 동일하게 서버의 개인키를 합해서 세션키 계산

S(세션키) = bPa = b(aG) = abG

1. 동일하게 생성된 세션키를 활용해 데이터 암호화 후 통신

  

장점

한 번의 키 유출로 모든 통신이 복호화되지 않음

RSA보다 빠름(키 길이가 짧음)

  

단점

RSA보다 상대적으로 복잡한 연산 필요

  

### HTTPS와의 연관성

TLS는 HTTP 위에 SSL/TLS를 합하면 HTTPS가 되는 것이다.

![[image 251.png]]